var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "introduction_objectives",
  "level": "1",
  "url": "introduction_objectives.html",
  "type": "Section",
  "number": "1.1",
  "title": "Objectives",
  "body": " Objectives    To review the key ideas of computer science, programming, and problem-solving using the C++ language.    To understand abstraction and the role it plays in the problem-solving process.    To develop understanding of Big O notation and other important techniques of algorithm analysis.    To develop comfort with standard data structures including queues, stacks, and trees.    To become conversant with sorting algorithms, including the advantages and disadvantages of each.    To learn to write and analyze recursive programs, functions, and methods.    To learn to traverse and to implement linked data structures such as linked lists and trees.       "
},
{
  "id": "introduction_getting-started",
  "level": "1",
  "url": "introduction_getting-started.html",
  "type": "Section",
  "number": "1.2",
  "title": "Getting Started",
  "body": " Getting Started  The way we think about programming has undergone many changes in the years since the first electronic computers required patch cables and switches to convey instructions from human to machine. As is the case with many aspects of society, changes in computing technology provide computer scientists with a growing number of tools and platforms on which to practice their craft. Advances such as faster processors, high-speed networks, and large memory capacities have created a spiral of complexity through which computer scientists must navigate. Throughout all of this rapid evolution, a number of basic principles have remained constant. The science of computing is concerned with using computers to solve problems.  You have no doubt spent considerable time learning the basics of problem-solving and hopefully feel confident in your ability to take a problem statement and develop a solution. You have also learned that writing computer programs is often hard. The complexity of large problems and the corresponding complexity of the solutions can tend to overshadow the fundamental ideas related to the problem-solving process.  This chapter emphasizes two important areas for the rest of the text. First, it reviews the framework within which computer science and the study of algorithms and data structures must fit, in particular, the reasons why we need to study these topics and how understanding these topics helps us to become better problem solvers. Second, we review the C++ programming language. Although we cannot provide a detailed, exhaustive reference, we will give examples and explanations for the basic constructs and ideas that will occur throughout the remaining chapters.     "
},
{
  "id": "introduction_what-is-computer-science",
  "level": "1",
  "url": "introduction_what-is-computer-science.html",
  "type": "Section",
  "number": "1.3",
  "title": "What Is Computer Science?",
  "body": " What Is Computer Science?  computer science  Computer science can be considered difficult to define. This is probably due to the unfortunate use of the word computer in the name. As you are perhaps aware, computer science is not simply the study of computers. Although computers play an important supporting role as a tool in the discipline, they are just that–tools.   algorithm Computer science is the study of problems, problem-solving, and the solutions that come out of the problem-solving process. Given a problem, a computer scientist's goal is to develop an algorithm , a step-by-step list of instructions for solving any instance of the problem that might arise. Algorithms are finite processes that if followed will solve the problem. Algorithms are solutions.  Computer science can be thought of as the study of algorithms. Some problems do not have solutions at all. Other problems do have solutions, but these solutions cannot be executed in a reasonable amount of time. Although proving these statements is beyond the scope of this text, the fact that some problems cannot be solved and\/or cannot be solved in the amount of time available is important for those who study computer science. We can fully define computer science, then, by including these types of problems and stating that computer science is the study of solutions to problems as well as the study of problems without fast solutions and including the study of problems without any solutions at all.   computable Hence, it is very common to include the word computable when describing problems and solutions. We say that a problem is computable if an algorithm exists for solving it. An alternative definition for computer science, then, is to say that computer science is the study of problems that are and that are not computable, the study of the existence and the nonexistence of algorithms as well as the analysis of the relative speed of those algorithms. Here, you will note that the word computer did not come up at all. Solutions are and should be considered independent from the machine.  abstraction Computer science, as it pertains to the problem-solving process itself, is also the study of abstraction . Abstraction allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives. The basic idea is familiar to us in a common example.  Consider the automobile that you may have driven to school or work today. As a driver, a user of the car, you have certain interactions that take place in order to utilize the car for its intended purpose. You get in, insert the key, start the car, shift, brake, accelerate, and steer in order to drive. From an abstraction point of view, we can say that you are seeing the logical perspective of the automobile. You are using the functions provided by the car designers for the purpose of transporting you from one location to another. These functions are sometimes also referred to as the interface .  On the other hand, the mechanic who must repair your automobile takes a very different point of view. She not only knows how to drive but must know all of the details necessary to carry out all the functions that we take for granted. She needs to understand how the engine works, how the transmission shifts gears, how temperature is controlled, and so on. This is known as the physical perspective, the details that take place under the hood.  The same thing happens when we use computers. Most people use computers to write documents, send and receive email, surf the web, play music, store images, and play games without any knowledge of the details that take place to allow those types of applications to work. They view computers from a logical or user perspective. Computer scientists, programmers, technology support staff, and system administrators take a very different view of the computer. They must know the details of how operating systems work, how network protocols are configured, and how to code various scripts that control function. They must be able to control the low-level details that a user simply assumes.  The common point for both of these examples is that the user of the abstraction, sometimes also called the client, does not need to know the details as long as the user is aware of the way the interface works. This interface is the way we as users communicate with the underlying complexities of the implementation. As another example of abstraction, consider the C++ cmath module. Once we import the module, we can perform computations as in the following example:    \/\/Outputs the square root of a given number. #include <iostream> #include <cmath> using namespace std; int main() { cout << sqrt(16); }     #Outputs the square root of a given number. import math print(math.sqrt(16))     procedural abstraction This is an example of procedural abstraction . We do not necessarily know how the square root is being calculated, but we know what the function is called and how to use it. If we perform the import correctly, we can assume that the library is correct and any function using it will provide us with the correct results. We know that someone implemented a solution to the square root problem and we only need to know how to use it. This is sometimes referred to as a black box view of a process. We simply describe the interface: the name of the function, what is needed (the parameters), and what will be returned. The details are hidden inside (see ).   Procedural Abstraction   Diagram illustrating the concept of procedural abstraction with a central box labeled 'sqrt()' representing a function. An arrow labeled 'n' points to the box, indicating the input, and another arrow points away from the box, labeled 'square root of n', indicating the output.       "
},
{
  "id": "introduction_what-is-computer-science-4",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#introduction_what-is-computer-science-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "algorithm "
},
{
  "id": "introduction_what-is-computer-science-6",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#introduction_what-is-computer-science-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "computable "
},
{
  "id": "introduction_what-is-computer-science-7",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#introduction_what-is-computer-science-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "abstraction "
},
{
  "id": "introduction_what-is-computer-science-8",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#introduction_what-is-computer-science-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "interface "
},
{
  "id": "introduction_what-is-computer-science-14",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#introduction_what-is-computer-science-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "procedural abstraction "
},
{
  "id": "fig-procabstraction",
  "level": "2",
  "url": "introduction_what-is-computer-science.html#fig-procabstraction",
  "type": "Figure",
  "number": "1.3.1",
  "title": "",
  "body": " Procedural Abstraction   Diagram illustrating the concept of procedural abstraction with a central box labeled 'sqrt()' representing a function. An arrow labeled 'n' points to the box, indicating the input, and another arrow points away from the box, labeled 'square root of n', indicating the output.   "
},
{
  "id": "introduction_what-is-programming",
  "level": "1",
  "url": "introduction_what-is-programming.html",
  "type": "Section",
  "number": "1.4",
  "title": "What Is Programming?",
  "body": " What Is Programming?  programming Programming is the process of taking an algorithm and encoding it into a notation, a programming language, so that it can be executed by a computer. Although many programming languages and many different types of computers exist, the important first step is the need to have the solution. Without an algorithm there can be no program.  Computer science is not the study of programming. Programming, however, is an important part of what a computer scientist does. Programming is often the way that we create a representation for our solutions. Therefore, this language representation and the process of creating it becomes a fundamental part of the discipline.  Algorithms describe the solution to a problem in terms of the data needed to represent the problem instance and the set of steps necessary to produce the intended result. Programming languages must provide a notational way to represent both the process and the data. To this end, languages provide control constructs and data types.  Control constructs allow algorithmic steps to be represented in a convenient yet unambiguous way. At a minimum, algorithms require constructs that perform sequential processing, selection for decision-making, and iteration for repetitive control. As long as the language provides these basic statements, it can be used for algorithm representation.  data type All data items in the computer are represented as strings of binary digits. In order to give these strings meaning, we need to have data types . Data types provide an interpretation for this binary data so that we can think about the data in terms that make sense with respect to the problem being solved. These low-level, built-in data types (sometimes called the primitive data types) provide the building blocks for algorithm development.  For example, most programming languages provide a data type for integers. Strings of binary digits in the computer's memory can be interpreted as integers and given the typical meanings that we commonly associate with integers (e.g. 23, 654, and -19). In addition, a data type also provides a description of the operations that the data items can participate in. With integers, operations such as addition, subtraction, and multiplication are common. We have come to expect that numeric types of data can participate in these arithmetic operations.  The difficulty that often arises for us is the fact that problems and their solutions are very complex. These simple, language-provided constructs and data types, although certainly sufficient to represent complex solutions, are typically at a disadvantage as we work through the problem-solving process. We need ways to control this complexity and assist with the creation of solutions.     "
},
{
  "id": "introduction_what-is-programming-2",
  "level": "2",
  "url": "introduction_what-is-programming.html#introduction_what-is-programming-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Programming "
},
{
  "id": "introduction_what-is-programming-6",
  "level": "2",
  "url": "introduction_what-is-programming.html#introduction_what-is-programming-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "data types "
},
{
  "id": "introduction_why-study-data-structures-and-abstract-data-types",
  "level": "1",
  "url": "introduction_why-study-data-structures-and-abstract-data-types.html",
  "type": "Section",
  "number": "1.5",
  "title": "Why Study Data Structures and Abstract Data Types?",
  "body": " Why Study Data Structures and Abstract Data Types?  To manage the complexity of problems and the problem-solving process, computer scientists use abstractions to allow them to focus on the big picture without getting lost in the details. By creating models of the problem domain, we are able to utilize a better and more efficient problem-solving process. These models allow us to describe the data that our algorithms will manipulate in a much more consistent way with respect to the problem itself.  data abstraction  abstract data type (ADT)  encapsulation Earlier, we referred to procedural abstraction as a process that hides the details of a particular function to allow the user or client to view it at a very high level. We now turn our attention to a similar idea, that of data abstraction . An abstract data type , sometimes abbreviated ADT , is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented. This means that we are concerned only with what the data is representing and not with how it will eventually be constructed. By providing this level of abstraction, we are creating an encapsulation around the data. The idea is that by encapsulating the details of the implementation, we are hiding them from the user's view. This is called information hiding .  shows a picture of what an abstract data type is and how it operates. The user interacts with the interface, using the operations that have been specified by the abstract data type. The abstract data type is the shell that the user interacts with. The implementation is hidden one level deeper. The user is not concerned with the details of the implementation.   Abstract Data Type   Concentric circles diagram representing an Abstract Data Type (ADT) structure. The innermost circle is labeled 'Implementation', surrounded by a middle layer labeled 'Operations', and an outer layer labeled 'Interface'. An arrow from the top points to the 'Interface' layer, labeled 'User', illustrating the interaction flow.     data structure  implementation-independent The implementation of an abstract data type, often referred to as a data structure , will require that we provide a physical view of the data using some collection of programming constructs and primitive data types. As we discussed earlier, the separation of these two perspectives will allow us to define the complex data models for our problems without giving any indication as to the details of how the model will actually be built. This provides an implementation-independent view of the data. Since there will usually be many different ways to implement an abstract data type, this implementation independence allows the programmer to switch the details of the implementation without changing the way the user of the data interacts with it. The user can remain focused on the problem-solving process.     "
},
{
  "id": "introduction_why-study-data-structures-and-abstract-data-types-3",
  "level": "2",
  "url": "introduction_why-study-data-structures-and-abstract-data-types.html#introduction_why-study-data-structures-and-abstract-data-types-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "data abstraction abstract data type ADT encapsulation information hiding "
},
{
  "id": "fig-adt",
  "level": "2",
  "url": "introduction_why-study-data-structures-and-abstract-data-types.html#fig-adt",
  "type": "Figure",
  "number": "1.5.1",
  "title": "",
  "body": " Abstract Data Type   Concentric circles diagram representing an Abstract Data Type (ADT) structure. The innermost circle is labeled 'Implementation', surrounded by a middle layer labeled 'Operations', and an outer layer labeled 'Interface'. An arrow from the top points to the 'Interface' layer, labeled 'User', illustrating the interaction flow.   "
},
{
  "id": "introduction_why-study-data-structures-and-abstract-data-types-6",
  "level": "2",
  "url": "introduction_why-study-data-structures-and-abstract-data-types.html#introduction_why-study-data-structures-and-abstract-data-types-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "data structure implementation-independent "
},
{
  "id": "introduction_why-study-algorithms",
  "level": "1",
  "url": "introduction_why-study-algorithms.html",
  "type": "Section",
  "number": "1.6",
  "title": "Why Study Algorithms?",
  "body": " Why Study Algorithms?  Computer scientists learn by experience. We learn by seeing others solve problems and by solving problems by ourselves. Being exposed to different problem-solving techniques and seeing how different algorithms are designed helps us to take on the next challenging problem that we are given. By considering a number of different algorithms, we can begin to develop pattern recognition so that the next time a similar problem arises, we are better able to solve it.  Algorithms are often quite different from one another. Consider the example of sqrt seen earlier. It is entirely possible that there are many different ways to implement the details to compute the square root function. One algorithm may use many fewer resources than another. One algorithm might take 10 times as long to return the result as the other. We would like to have some way to compare these two solutions. Even though they both work, one is perhaps better than the other. We might suggest that one is more efficient or that one simply works faster or uses less memory. As we study algorithms, we can learn analysis techniques that allow us to compare and contrast solutions based solely on their own characteristics, not the characteristics of the program or computer used to implement them.  In the worst case scenario, we may have a problem that is intractable, meaning that there is no algorithm that can solve the problem in a realistic amount of time. It is important to be able to distinguish between those problems that have solutions, those that do not, and those where solutions exist but require too much time or other resources to work reasonably.  There will often be trade-offs that we will need to identify and decide upon. As computer scientists, in addition to our ability to solve problems, we will also need to know and understand solution evaluation techniques. In the end, there are often many ways to solve a problem. Finding a solution and then deciding whether it is a good one are tasks that we will do over and over again.     "
},
{
  "id": "introduction_reviewing-basic-c",
  "level": "1",
  "url": "introduction_reviewing-basic-c.html",
  "type": "Section",
  "number": "1.7",
  "title": "Reviewing Basic C++",
  "body": " Reviewing Basic C++  In this section, we will review the programming language C++ and also provide some more detailed examples of the ideas from the previous section. If you are new to C++ or find that you need more information about any of the topics presented, we recommend that you consult a resource such as the C++ Reference or a C++ Tutorial . Our goal here is to reacquaint you with the C++ language and also reinforce some of the concepts that will be central to later chapters.  compiler machine mode C++ is an object-oriented programming language. It has a powerful set of built-in data types and control constructs. Since C++ is a compiled language, all the code written in this language, when run, are translated to machine code by a program called the compiler .  The following is an example of C++ code that writes to the console:   \/\/Outputs strings to command line. #include <iostream> using namespace std; int main() { cout << \"Welcome to Problem Solving with\" << endl; cout << \"Algorithms and Data Structures!\" << endl; return 0; }      "
},
{
  "id": "introduction_reviewing-basic-c-3",
  "level": "2",
  "url": "introduction_reviewing-basic-c.html#introduction_reviewing-basic-c-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "machine code compiler "
},
{
  "id": "introduction_getting-started-with-data",
  "level": "1",
  "url": "introduction_getting-started-with-data.html",
  "type": "Section",
  "number": "1.8",
  "title": "Getting Started with Data",
  "body": " Getting Started with Data   class  object C++ considers data to be the focal point of the problem-solving process. We stated above that C++ supports the object-oriented programming paradigm. In C++, as well as in any other object-oriented programming language, we define a class to be a description of what the data looks like (the state) and what the data can do (the behavior). Classes are analogous to abstract data types because a user of a class only sees the state and behavior of a data item. Data items are called objects in the object-oriented paradigm. An object is an instance of a class.     "
},
{
  "id": "introduction_getting-started-with-data-2",
  "level": "2",
  "url": "introduction_getting-started-with-data.html#introduction_getting-started-with-data-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "class objects "
},
{
  "id": "introduction_built-in-atomic-data-types",
  "level": "1",
  "url": "introduction_built-in-atomic-data-types.html",
  "type": "Section",
  "number": "1.9",
  "title": "Built-in Atomic Data Types",
  "body": " Built-in Atomic Data Types   C++ requires users to specify the data type of each variable before it is used. The primary C++ built-in atomic data types are: integer ( int ), floating point ( float ), double precision floating point ( double ), Boolean ( bool ), and character ( char ). There is also a special type which holds a memory location called pointer . C++ also has collection or compound data types, which will be discussed in a future chapter.    Q-1: After reading the above paragraph, what makes a data type categorized as an atomic data type? (hint: arrays and vectors are not atomic)     It must be mutable so that it can change at any time.    Incorrect, Atomic data types are not required to be mutable.      Its memory size cannot be too big, relating to how atoms are naturally very small.    Incorrect, The data type can be any size, but you're close. (hint: atomic data types got their name when scientists thought atoms were the smallest things in existence.)      It must be statically allocated so it cannot change in size.    Incorrect, atomic data types have nothing to do with being static or dynamic.      It cannot be broken down any smaller while still being easily operable.    Correct, the atomic data type actually got its name when scientists thought atoms were the smallest things in existence. That is why they are data types that cannot be broken down.      Numeric Data  Numeric C++ data types include int for integer, float for floating point, double for double precision floating point.  The standard arithmetic operations, +, -, *, and \/ are used with optional parentheses to force the order of operations away from normal operator precedence.  When two integers are divided in C++, the integer portion of the quotient is returned and the fractional portion is removed. i.e. When two integers are divided, integer division is used. To get the whole quotient, declaring one of the numbers as a float will convert the entire result into floating point.  Exponentiation in C++ is done using pow() from the cmath library and the remainder (modulo) operator is done with % .  Run the following code to see that you understand each result.    \/\/outputs results from various math expressions #include <iostream> #include <cmath> using namespace std; int main(){ cout << (2+3*4) << endl; cout << (2+3)*4 << endl; cout << pow(2, 10) << endl; cout << float(6)\/3 << endl; cout << float(7)\/3 << endl; cout << 7\/3 << endl; \/\/In C++ this is integer division cout << 7%3 << endl; cout << float(3)\/6 << endl; cout << 3\/6 << endl; cout << 3%6 << endl; cout << pow(2, 100) << endl; return 0; }     #outputs results from various math expressions def main(): print(2+3*4) print((2+3)*4) print(2**10) print(6\/3) print(7\/3) print(7\/\/3) print(7%3) print(3\/6) print(3\/\/6) print(3%6) print(2**100) main()    When declaring numeric variables in C++, modifiers like short , long , and unsigned can optionally be used to help to ensure space is used as efficiently as possible.   Q-4: what is the result of dividing 3\/2 in C++?     1    Right!      1.5    No. Integer division is used. Try again.      2    No. Integer division is used. Try again.      A run-time error will occur.    No, C++ generally will try to do as you ask.      none of the above    One of the above is correct.      Q-5: How do I raise 4 to 5th power in C++?     ``4**5``    No, ``**`` is used in other languages, but not C++.      ``5**4``    No, ``**`` is used in other languages, but not C++, and the operators are reversed.      ``4^5``    No. The ``^`` is a valid operator in C++, but it does something else.      ``pow(4, 5)``    You got it! Remember the cmath library will need to be included for pow() to work.       Boolean Data  Boolean data types are named after George Boole who was an English mathematician, so the word “Boolean” should be capitalized. However, the Boolean data type, in C++ uses the keyword bool which is not capitalized. The possible state values for a C++ Boolean are lower case true and false .  C++ uses the standard Boolean operators, “and” is given by && , “or” is given by || , and “not” is given by ! . Note that the internally stored values representing true and false are actually 1 and 0 respectively. Hence, we see this in output as well.    \/\/outputs boolean results to the command line #include <iostream> using namespace std; int main() { cout << true << endl; cout << false << endl; cout << (true || false) << endl; cout << (true && false) << endl; return 0; }     #outputs boolean results to the command line def main(): print(True) print(False) print(True or False) print(True and False) main()    Boolean data objects are also used as results for comparison operators such as equality (==) and greater than ( > ). In addition, relational operators and logical operators can be combined together to form complex logical questions. shows the relational and logical operators with examples shown in the session that follows.    C++ Relational and Logical Operators    Operation Name    Operator    Explanation     less than   <   Less than operator    greater than   >   Greater than operator    less than or equal   <=   Less than or equal to operator    greater than or equal   >=   Greater than or equal to operator    equal   ==   Equality operator    not equal   !=   Not equal operator    logical and   &&   Both operands true for result to be true    logical or   ||   One or the other operand is true for the result to be true    logical not   !   Negates the truth value, false becomes true, true becomes false       \/\/outputs the results from the relational and logical operators #include <iostream> using namespace std; int main(){ cout << (5 == 10) << endl; cout << (10 > 5) << endl; cout << ((5 >= 1) && (5 <= 10)) << endl; return 0; }     #outputs the results from the relational and logical operators def main(): print(5 == 10) print(10 > 5) print((5 >= 1) and (5 <= 10)) main()    When a C++ variable is declared space in memory is set aside to hold this type of value. A C++ variable can optionally be initialized in the declaration by using a combination of a declaration and an assignment statement.  Consider the following session:   \/\/showcases how variables work in C++ #include <iostream> using namespace std; int main(){ int theSum = 4; cout << theSum << endl; theSum = theSum + 1; cout << theSum << endl; bool theBool = true; cout << theBool << endl; theBool = 4; cout << theBool << endl; return 0; }   The declaration int theSum = 0; creates a variable called theSum and initializes it to hold the data value of 0 . The right-hand side of each assignment statement is evaluated and the resulting data value is “assigned” to the variable named on the left-hand side. Here the type of the variable is integer.  In C++, the data type cannot change. This is a characteristic of C++’s static typing. A variable can hold ever only one type of data. Pitfall: C++ will often simply try to do the assignment you requested without complaining. Note what happened in the code above in the final output.   Q-11: Why did theBool output a value of 1 after being set to 4?     Setting theBool to anything other than true or false is ignored.    No. Try changing the code and setting theBool to 0.      Setting theBool to anything > 0 will be true and false otherwise.    No. Try changing the code and setting theBool to -4.      false == 0 and true = !false i.e. anything that is not zero and can be converted to a Boolean is not false, thus it must be true.    Correct!      None of the above.    Try again. One of the above is correct. You might try changing the code and rerunning.       Character Data  In C++ single quotes are used for the character ( char ) data type, and double quotes are used for the string data type.  Consider the following code.    #outputs the boolean results to show how strings and chars differ in C++ def main(): strvar = \"b\" charvar = 'b' print('b' == charvar) print(\"b\" == strvar) print('a' == \"a\") main()     \/\/outputs the boolean results to show how strings and chars differ in C++ #include <iostream> #include <string> using namespace std; int main(){ string strvar = \"b\"; char charvar = 'b'; cout << ('b' == charvar) << endl; cout << (\"b\" == strvar) << endl; \/\/cout << ('a' == \"a\") << endl; \/\/ will error! return 0; }    Try the following question.   Q-14: If I want to create a string in C++, what set of symbols may be used?     ' '    No, single quotes are only used for single characters.      \" \"    Good job reading!      ' ' or \" \" may be used    No. Only one set of symbols may be used.      It depends upon the implementation.    No. No matter what, the implementation is consistent.      none of the above    One of the above is indeed correct.       Pointers   A C++ pointer is a variable that stores a memory address.  We know that variables in a computer program are used to label data with a descriptive identifier so that the data can be accessed and used by that computer program. How C++ variables are implemented is worthy of discussion.  In C++ the value of each variable is stored directly in memory without the need for either a reference or an object. This makes access faster, but it is one of the reasons we need to declare each variable because different types take differing amounts of space in memory!  The following code declares a variable called varN that has in it a value of 100:  \/\/ C++ variable declaration and assignment of an integer value int varN = 100;  In C++ the results of running this code will look like the diagram below:   Figure 4: C++ variable    When we want to output the value to the console, we use the variable name to do so.  But, we can also identify the memory location of the variable, which is sometimes very valuable. This address may change each time the program is run. In C++, this will always look odd because it will be the actual memory address written in a hexadecimal code which is a base 16 code like 0x7ffd93f25244.  In C++ we use the address-of operator , & to reference the address.  Variables are stored in memory locations which are dependent upon the run itself. If you repeatedly run the above code you may see the location change.  In C++, variables store values directly, making them faster to reference.  If in C++, we want to create a reference to a memory location in C++, we must use a special syntax called a pointer .     \/\/outputs both the value of varN and the location in memory of varN #include <iostream> using namespace std; int main(){ int varN = 101; cout << varN << endl; cout << &varN << endl; return 0; }     #because python is an interpreted language, variables stored at a virtual memory address. def main(): varN = 101; print(varN) print(id(varN)) main()     Pointer Syntax  When declaring a pointer in C++ that will “point” to the memory address of some data type, you will use the same rules of declaring variables and data types. The key difference is that there must be an asterisk (*) between the data type and the identifier.  variableType *identifier; \/\/ syntax to declare a C++ pointer int *ptrx; \/\/ example of a C++ pointer to an integer  White space in C++ generally does not matter, so the following pointer declarations are identical:  SOMETYPE *variablename; \/\/ preferable SOMETYPE * variablename; SOMETYPE* variablename;  However, the first declaration is preferable because it is clearer to the programmer that the variable is in fact a pointer because the asterisk is closer to the variable name.    The address-of operator, &  Now that we know how to declare pointers, how do we give them the address of where the value is going to be stored? One way to do this is to have a pointer refer to another variable by using the address-of operator, which is denoted by the ampersand symbol, & . The address-of operator & does exactly what it indicates, namely it returns the address.  The syntax is shown below, where varN stores the value, and ptrN stores the address of where varN is located:  variableType varN; \/\/ a variable to hold the value variableType *ptrN = &varN; \/\/ a variable pointing to the address of varN  Keep in mind that when declaring a C++ pointer, the pointer needs to reference the same type as the variable or constant to which it points.  Expanding on the example above where varN has the value of 100.  \/\/variable declaration for a single integer value int varN = 100; int *ptrN; ptrN = &varN;  The results of running this C++ code will look like the diagram below.   Figure 5: View into memory with pointers      Accessing Values from Pointers  So, once you have a C++ pointer, how do you access the values associated with that location? You use the asterisk before the pointer variable, which goes to that address, effectively dereferencing the pointer, meaning that it will find the location of the value stored where the pointer was pointing.  In other words, varN and *ptrN (note the asterisk in front!) reference the same value in the code above.  Let’s extend the example above to output the value of a variable and its address in memory:  … _dereferencing:    \/\/prints a variable by pointer and value #include <iostream> using namespace std; int main( ) { int varN = 100; int *ptrN = &varN; \/\/ ptrN points to varN address cout << \"varN value: \" << varN << endl; cout << \"varN location: \" << ptrN << endl; cout << \"dereference ptrN: \" << *ptrN << \"endl\"; return 0; }     Q-18: If the lines (varN = 50;) and (cout << *ptrN << endl;) were inserted into line 7-8, what would it cout?     varPntr: 100    Not quite, the variable varN no longer equals 100 past line 7!      varPntr: 50    Right!      varPntr: 150    No, the values do not add together!      0x7ffeb9ce053c    We are dereferencing the pointer, so you would not get the address of varN. Try again!      none of the above    One of the above is indeed correct.     Compiling and running the above code will have the program output the value in varN, what is in ptrN (the memory address of varN), and what value is located at that memory location.  The second output sentence is the address of varN, which would most likely be different if you run the program on your machine.  WARNING: What happens if you forget the asterisk when assigning a value to a pointer and had the following instructions instead?    \/\/showcases what happens when reading from unknown memory locations #include <iostream> using namespace std; int main() { int varN = 100; int *ptrN = varN; \/\/ Note: no asterisk, \/\/ ptrN now refers to memory position 100, \/\/ whatever happens to be there! \/\/ You might get an error or you might not! cout << \"varN value: \" << varN << endl; cout << \"varN location: \" << ptrN << endl; cout << \"ptrN points to varN: \" << endl; cout << \"dereference ptrN: \" << *ptrN << \"\\n\\n\"; return 0; }     This is BAD, BAD, BAD!    Figure 6: dangling pointer reference    If your compiler does not catch that error (the one for this class may), the first cout instruction outputs:  After changing *ptrN, varN now has: 50  which is expected because you changed where ptrN is pointing to and NOT the contents of where it is pointing.  The second cout instruction is a disaster because     You don’t know what is stored in location 100 in memory, and     (2) that location is outside of your segment (area in memory reserved for your program), so the operating system will jump in with a message about a “segmentation fault”. Although such an error message looks bad, a “seg fault” is in fact, a helpful error because unlike the elusive logical errors, the reason is fairly localized.    The NULL pointer  The NULL pointer in C++ points to nothing and is often denoted by the keyword NULL (all caps) or by 0. The NULL pointer is often used in conditions and\/or in logical operations.  The following example demonstrates how the NULL pointer works. The variable ptrx initially has the address of x when it is declared. On the first iteration of the loop, it is assigned the value of NULL (i.e. 0) thereby ending the loop:    \/\/showcases how you can use NULL. #include <iostream> using namespace std; int main( ) { int x = 12345; int *ptrx = &x; while (ptrx) { cout << \"Pointer ptrx points to \" << ptrx << endl; ptrx = NULL; } cout << \"Pointer ptrx points to nothing!\" <<endl; }    Helpful Tip: The NULL pointer becomes very useful when you must test the state of a pointer, such as whether the assignment to an address is valid or not.   Q-21: If I want to use the char type in C++, what set of symbols must be used?     ' '    Right!      \" \"    No. Double quotes are only used for strings.      ' ' or \" \" may be used    No. Only one set of symbols may be used.      It depends upon the implementation.    No. The implementation is consistent.      none of the above    One of the above is indeed correct.      Q-22: A\/an ___ is used to store a memory address in C++?       Right!      Be more specific!      That’s a general description of what it is, not a C++ term!      Incorrect. Please try again       Q-23: How may one reference a variable’s memory address in C++?     using ``&``    Right! ``&`` is the \"address-of\" operator, used to reference an address.      using ``*``    No. ``int *p;`` defines a pointer to an integer, and ``*p`` would dereference that pointer, i.e. retrieve the data that p points to.      using ``id``    No. This is used in other languages such as Python.      It depends upon the implementation.    No. The implementation remains consistent.      none of the above    One of the above is indeed correct.          "
},
{
  "id": "atomicq1",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#atomicq1",
  "type": "Checkpoint",
  "number": "1.9.1",
  "title": "",
  "body": " Q-1: After reading the above paragraph, what makes a data type categorized as an atomic data type? (hint: arrays and vectors are not atomic)     It must be mutable so that it can change at any time.    Incorrect, Atomic data types are not required to be mutable.      Its memory size cannot be too big, relating to how atoms are naturally very small.    Incorrect, The data type can be any size, but you're close. (hint: atomic data types got their name when scientists thought atoms were the smallest things in existence.)      It must be statically allocated so it cannot change in size.    Incorrect, atomic data types have nothing to do with being static or dynamic.      It cannot be broken down any smaller while still being easily operable.    Correct, the atomic data type actually got its name when scientists thought atoms were the smallest things in existence. That is why they are data types that cannot be broken down.    "
},
{
  "id": "intro_numeric-ex1",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#intro_numeric-ex1",
  "type": "Checkpoint",
  "number": "1.9.2",
  "title": "",
  "body": "  \/\/outputs results from various math expressions #include <iostream> #include <cmath> using namespace std; int main(){ cout << (2+3*4) << endl; cout << (2+3)*4 << endl; cout << pow(2, 10) << endl; cout << float(6)\/3 << endl; cout << float(7)\/3 << endl; cout << 7\/3 << endl; \/\/In C++ this is integer division cout << 7%3 << endl; cout << float(3)\/6 << endl; cout << 3\/6 << endl; cout << 3%6 << endl; cout << pow(2, 100) << endl; return 0; }     #outputs results from various math expressions def main(): print(2+3*4) print((2+3)*4) print(2**10) print(6\/3) print(7\/3) print(7\/\/3) print(7%3) print(3\/6) print(3\/\/6) print(3%6) print(2**100) main()   "
},
{
  "id": "mc_integer_div",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_integer_div",
  "type": "Checkpoint",
  "number": "1.9.3",
  "title": "",
  "body": " Q-4: what is the result of dividing 3\/2 in C++?     1    Right!      1.5    No. Integer division is used. Try again.      2    No. Integer division is used. Try again.      A run-time error will occur.    No, C++ generally will try to do as you ask.      none of the above    One of the above is correct.    "
},
{
  "id": "mc_exponentiation",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_exponentiation",
  "type": "Checkpoint",
  "number": "1.9.4",
  "title": "",
  "body": " Q-5: How do I raise 4 to 5th power in C++?     ``4**5``    No, ``**`` is used in other languages, but not C++.      ``5**4``    No, ``**`` is used in other languages, but not C++, and the operators are reversed.      ``4^5``    No. The ``^`` is a valid operator in C++, but it does something else.      ``pow(4, 5)``    You got it! Remember the cmath library will need to be included for pow() to work.    "
},
{
  "id": "intro_builtin-ex_printbool",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#intro_builtin-ex_printbool",
  "type": "Checkpoint",
  "number": "1.9.5",
  "title": "",
  "body": "  \/\/outputs boolean results to the command line #include <iostream> using namespace std; int main() { cout << true << endl; cout << false << endl; cout << (true || false) << endl; cout << (true && false) << endl; return 0; }     #outputs boolean results to the command line def main(): print(True) print(False) print(True or False) print(True and False) main()   "
},
{
  "id": "introduction_tab-relational",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#introduction_tab-relational",
  "type": "Table",
  "number": "1.9.6",
  "title": "",
  "body": "  C++ Relational and Logical Operators    Operation Name    Operator    Explanation     less than   <   Less than operator    greater than   >   Greater than operator    less than or equal   <=   Less than or equal to operator    greater than or equal   >=   Greater than or equal to operator    equal   ==   Equality operator    not equal   !=   Not equal operator    logical and   &&   Both operands true for result to be true    logical or   ||   One or the other operand is true for the result to be true    logical not   !   Negates the truth value, false becomes true, true becomes false    "
},
{
  "id": "intro_logical-printops",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#intro_logical-printops",
  "type": "Checkpoint",
  "number": "1.9.7",
  "title": "",
  "body": "  \/\/outputs the results from the relational and logical operators #include <iostream> using namespace std; int main(){ cout << (5 == 10) << endl; cout << (10 > 5) << endl; cout << ((5 >= 1) && (5 <= 10)) << endl; return 0; }     #outputs the results from the relational and logical operators def main(): print(5 == 10) print(10 > 5) print((5 >= 1) and (5 <= 10)) main()   "
},
{
  "id": "mc_bool",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_bool",
  "type": "Checkpoint",
  "number": "1.9.8",
  "title": "",
  "body": " Q-11: Why did theBool output a value of 1 after being set to 4?     Setting theBool to anything other than true or false is ignored.    No. Try changing the code and setting theBool to 0.      Setting theBool to anything > 0 will be true and false otherwise.    No. Try changing the code and setting theBool to -4.      false == 0 and true = !false i.e. anything that is not zero and can be converted to a Boolean is not false, thus it must be true.    Correct!      None of the above.    Try again. One of the above is correct. You might try changing the code and rerunning.    "
},
{
  "id": "intro_logical-printchar",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#intro_logical-printchar",
  "type": "Checkpoint",
  "number": "1.9.9",
  "title": "",
  "body": "  #outputs the boolean results to show how strings and chars differ in C++ def main(): strvar = \"b\" charvar = 'b' print('b' == charvar) print(\"b\" == strvar) print('a' == \"a\") main()     \/\/outputs the boolean results to show how strings and chars differ in C++ #include <iostream> #include <string> using namespace std; int main(){ string strvar = \"b\"; char charvar = 'b'; cout << ('b' == charvar) << endl; cout << (\"b\" == strvar) << endl; \/\/cout << ('a' == \"a\") << endl; \/\/ will error! return 0; }   "
},
{
  "id": "mc_cpp_strings",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_cpp_strings",
  "type": "Checkpoint",
  "number": "1.9.10",
  "title": "",
  "body": " Q-14: If I want to create a string in C++, what set of symbols may be used?     ' '    No, single quotes are only used for single characters.      \" \"    Good job reading!      ' ' or \" \" may be used    No. Only one set of symbols may be used.      It depends upon the implementation.    No. No matter what, the implementation is consistent.      none of the above    One of the above is indeed correct.    "
},
{
  "id": "introduction_pointers-2-1",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#introduction_pointers-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pointer "
},
{
  "id": "id2-fig-cpp-reference",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#id2-fig-cpp-reference",
  "type": "Figure",
  "number": "1.9.11",
  "title": "",
  "body": " Figure 4: C++ variable   "
},
{
  "id": "introduction_pointers-2-13",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#introduction_pointers-2-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pointer "
},
{
  "id": "intro_pointers-ex_print_ptr",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#intro_pointers-ex_print_ptr",
  "type": "Checkpoint",
  "number": "1.9.12",
  "title": "",
  "body": "  \/\/outputs both the value of varN and the location in memory of varN #include <iostream> using namespace std; int main(){ int varN = 101; cout << varN << endl; cout << &varN << endl; return 0; }     #because python is an interpreted language, variables stored at a virtual memory address. def main(): varN = 101; print(varN) print(id(varN)) main()   "
},
{
  "id": "id3-fig-point2",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#id3-fig-point2",
  "type": "Figure",
  "number": "1.9.13",
  "title": "",
  "body": " Figure 5: View into memory with pointers   "
},
{
  "id": "mc_pntrhlp",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_pntrhlp",
  "type": "Checkpoint",
  "number": "1.9.14",
  "title": "",
  "body": " Q-18: If the lines (varN = 50;) and (cout << *ptrN << endl;) were inserted into line 7-8, what would it cout?     varPntr: 100    Not quite, the variable varN no longer equals 100 past line 7!      varPntr: 50    Right!      varPntr: 150    No, the values do not add together!      0x7ffeb9ce053c    We are dereferencing the pointer, so you would not get the address of varN. Try again!      none of the above    One of the above is indeed correct.    "
},
{
  "id": "introduction_accessing-values-from-pointers-12",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#introduction_accessing-values-from-pointers-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "This is BAD, BAD, BAD! "
},
{
  "id": "id4-fig-point3",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#id4-fig-point3",
  "type": "Figure",
  "number": "1.9.15",
  "title": "",
  "body": " Figure 6: dangling pointer reference   "
},
{
  "id": "mc_characters",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_characters",
  "type": "Checkpoint",
  "number": "1.9.16",
  "title": "",
  "body": " Q-21: If I want to use the char type in C++, what set of symbols must be used?     ' '    Right!      \" \"    No. Double quotes are only used for strings.      ' ' or \" \" may be used    No. Only one set of symbols may be used.      It depends upon the implementation.    No. The implementation is consistent.      none of the above    One of the above is indeed correct.    "
},
{
  "id": "memoryvar",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#memoryvar",
  "type": "Checkpoint",
  "number": "1.9.17",
  "title": "",
  "body": " Q-22: A\/an ___ is used to store a memory address in C++?       Right!      Be more specific!      That’s a general description of what it is, not a C++ term!      Incorrect. Please try again     "
},
{
  "id": "mc_memory",
  "level": "2",
  "url": "introduction_built-in-atomic-data-types.html#mc_memory",
  "type": "Checkpoint",
  "number": "1.9.18",
  "title": "",
  "body": " Q-23: How may one reference a variable’s memory address in C++?     using ``&``    Right! ``&`` is the \"address-of\" operator, used to reference an address.      using ``*``    No. ``int *p;`` defines a pointer to an integer, and ``*p`` would dereference that pointer, i.e. retrieve the data that p points to.      using ``id``    No. This is used in other languages such as Python.      It depends upon the implementation.    No. The implementation remains consistent.      none of the above    One of the above is indeed correct.    "
},
{
  "id": "introduction_collections",
  "level": "1",
  "url": "introduction_collections.html",
  "type": "Section",
  "number": "1.10",
  "title": "Collections",
  "body": " Collections   In addition to the numeric, Boolean, and character types, C++ also offers built-in collection types. A collection data type is a grouping of some number of other data items (possibly only zero or one) that have some shared significance or need to be operated upon together.  Arrays, vectors, strings, sets, and hash tables are among these useful C++ collection types.    Arrays  What is an Array? An array is a data structure consisting of an ordered collection of data elements, of identical type in which each element can be identified by an array index. More technically, an array data structure is an ordered arrangement of values located at equally spaced addresses in contiguous computer memory.  NOTE: A C++ array is always stored in contiguous memory. C++ arrays can be allocated in two different ways:     statically allocated in which the array size is fixed at compile-time and cannot change    dynamically allocated in which pointers are used in the allocation process so the size can change at run-time     In modern C++, the statically allocated array is typically used in situations when speed is essential or where hardware constraints exist, and a data structure called a vector is typically used when more flexibility is required.  Because C++ stores variables directly, each element of a C++ array must be of identical data type. The indices for arrays start counting with 0.  The use of arrays permits us to utilize an ordered set of memory locations that we can then manipulate as a single entity, and that at the same time gives us direct access to each individual component.  Why use an Array?  C++ is a language often used for real-time or low-level processing where speed is essential and\/or there is only a fixed amount of space available.  The fact that array elements are stored in memory in contiguous memory locations making look-up via index very, very fast. In computing, a word is the unit of data used by a particular processor design, such as 32 or 64 bits. For example, an array of 100 integer variables, with indices 0 through 99, might be stored as 100 words at memory addresses 20000, 20004, 20008, … 20396. The element with index i would be located at the address 20000 + 4 × i.  Statically allocated C++ arrays must be declared with both a type and a size at compile-time.  double darray[4]; int iarray[10]; char arr2[3000];  It is also possible to initialize statically allocated arrays at compile time, in which case the number of items determines the array's size.  int arr[] = {1, 2, 3, 4}; \/\/ This is size 4. char arr2[] = {'a', 'b', 'c'}; \/\/ This is size 3. string arr3[] = {\"this\", \"is\", \"an\", \"array\"}; \/\/ This is size 4.  Note that an array with a single element is not the same type as the atomic type, so the following are not the same.  double darray[] = {1.2}; \/\/ must use index to access value double ddouble = 1.2; \/\/ can't use index to access value  Be Cautious with Arrays  The speed and low-level control that arrays offer us as programmers is powerful… and dangerous. C++ is designed for speed, and using a C++ array will help you better understand the trade-offs inherent in this.  Here are examples of iteration.    \/\/showcases an iteration through an array in C++ #include <iostream> using namespace std; int main(){ int myarray[] = {2,4,6,8}; for (int i=0; i<4; i++){ cout << myarray[i] << endl; } return 0; }     #showcases an iteration through an array in Python def main(): mylist = [2, 4, 6, 8] for i in range(4): print(mylist[i]) main()    C++ is designed for speed. C++ will not only let you iterate beyond either end of an array, but it will let you change the values beyond either end of the array with sometimes catastrophic results.  The phrase, be careful what you wish for is a great one to remember when programming in C++. Because C++ will generally try to do everything you ask for.    \/\/outputs the result of trying to access a value outside of an array #include <iostream> using namespace std; int main(){ int myarray[] = {2,4,6,8}; for (int i=0; i<=8; i++){ cout << myarray[i] << endl; cout << \"id: \" << &myarray[i] << endl; } return 0; }     #outputs the result of trying to access a value outside of an array def main(): mylist = [2,4,6,8] print(mylist) for i in range(5): print(mylist[i]) print(\"id: \"+str(id(mylist[i]))) main()    The speed of C++ comes at the cost of minimal to no error checking. Sometimes this can have perplexing results such as in the next example.  You should use an array when you have a need for speed or you need to work with hardware constraints. Otherwise, you may want to consider using another collection data type, the vector .    \/*shows how C++ allows you to easily overwrite values in memory even when you don't mean to. *\/ #include <iostream> using namespace std; int main(){ int myarray[] = {2, 4}; int otherdata[]={777, 777}; for (int i=0; i<4; i++){ myarray[i]=0; cout <<\"myarray[\" << i << \"]=\"; cout << myarray[i] << endl; cout << \"add:\" << &myarray[i] << endl; } for (int i=0; i<2; i++){ cout << \"otherdata[\" << i << \"]=\"; cout << otherdata[i] << endl; cout << \"add:\" << &otherdata[i] << endl; } return 0; }     \"\"\"shows how C++ allows you to easily overwrite values in memory even when you dont mean to.\"\"\" def main(): mylist = [2, 4] otherdata = [777, 777] for i in range(4): print(mylist[i]) print(\"id: \"+str(id(mylist[i]))) for j in range(2): print(otherdata[i]) print(\"id: \"+str(id(otherdata[i]))) main()      Vectors   Vectors use a dynamically allocated array to store their elements, so they can change size, and they have other friendly features as well. Because they use a dynamically allocated array, they use contiguous storage locations which means that their elements can be accessed and traversed, and they can also be accessed randomly using indexes. However, vectors are dynamically sized, so their size can change automatically. A new element can be inserted into or deleted from any part of a vector, and automatic reallocation for other existing items in the vector will be applied. Vectors are homogeneous, so every element in the vector must be of the same type.  Vectors are a class that is available through a library called the Standard Template Library (STL), and one uses a < > notation to indicate the data type of the elements. In order to use vectors, One needs to include the vector library.  #include <vector>   Common C++ Vector Operators    Vector Operation    Use    Explanation      [ ]    myvector[i]   access value of element at index i     =    myvector[i]=value   assign value to element at index i     push_back    myvect.push_back(item)   Appends item to the far end of the vector     pop_back    myvect.pop_back()   Deletes last item (from far end) of the vector     insert    myvect.insert(i, item)   Inserts an item at index i     erase    myvect.erase(i)   Erases an element from index i     size    myvect.size()   Returns the actual size used by elements     capacity    myvect.capacity()   Returns the size of allocated storage capacity     reserve    myvect.reserve(amount)   Request a change in capacity to amount    A very common programming task is to grow a vector using the push_back() method to append to the vector as we see in the next example. Because vectors can change size, vectors typically allocate some extra storage to accommodate for possible growth. Thus the vector typically has an actual capacity greater than the storage size strictly needed to contain its elements.    Matching    \/*shows the use of the reserve member, and how it can be effective in saving time with a growing vector.*\/ #include <iostream> #include <vector> using namespace std; int main(){ vector<int> intvector; intvector.reserve(50); for (int i=0; i<50; i++){ intvector.push_back(i*i); cout << intvector[i] << endl; } return 0; }     #Python doesn't have vectors, simply stating the limit is enough def main(): intlist=[] for i in range(50): intlist.append(i*i) print(intlist[i]) main()    In the above example, the use of reserve was optional. However, it is a good idea to use it before growing a vector in this way because it will save time. Because vectors are stored in underlying arrays which require contiguous memory, every time the vector's size gets too large for the capacity, the entire vector must be moved to a larger location in memory, and all that copying takes time. In a typical implementation, the capacity is doubled each time. as in the example that follows.   \/\/code from above but without the reserve #include <iostream> #include <vector> using namespace std; int main(){ vector<int> intvector; \/\/ without intvector.reserve(50); for (int i=0; i<50; i++){ intvector.push_back(i*i); cout << intvector[i] << endl; cout << \"capacity: \" << intvector.capacity() << endl; } return 0; }   Remembering that C++ is designed for speed, not protection, we will likely not be surprised by the following:    \/\/shows errors when a vector goes out of bounds #include <iostream> #include <vector> using namespace std; int main(){ vector<int> intvector; intvector.reserve(10); for (int i=0; i<10; i++){ intvector.push_back(i); } for (int i=0; i<=10; i++){ cout << \"intvector[\" << i << \"]=\"<<intvector[i] << endl; } return 0; }     #shows errors when a vector goes out of bounds def main(): intlist=[] for i in range(10): intlist.append(i) for i in range(11): print(\"intlist[\" + str(i) + \"]=\" + str(intlist[i])) main()       Strings   Strings are sequential collections of zero or more characters such as letters, numbers and other symbols. There are actually two types of strings in C++ . The C++ string or just string from the <string> library is the more modern type. The old style C-string which is essentially an array of char type. The char type itself is actually distinct from both types of strings.  char cppchar = 'a'; \/\/ char values use single quotes string cppstring = \"Hello World!\"; \/\/ C++ strings use double quotes char cstring[] = {\"Hello World!\"}; \/\/ C-string or char array uses double quotes  In older versions of C++, you must use a char array to work with filenames. In modern C++ (from C++11 onward), however, you can use a C++ string for everything. Since C++ strings are so much nicer, I would not recommend using C-strings unless you have a reason.  Because strings are sequences, all of the typical sequence operations work as you would expect. In addition, the string library offers a huge number of methods, some of the most useful of which are shown in .   String Methods Provided in C++    Method Name    Use    Explanation      [ ]    astring[i]   access value of character at index i     =    astring[i]=value   change value of character at index i     +    string1 + astring2   concatenate strings     append    astring.append(string)   Append to string the end of the string     push_back    astring.push_back(char)   Appends a character to the end of the string     pop_back    astring.pop_back()   Deletes the last character from the end of the string     insert    astring.insert(i, string)   Inserts a string at a specific index     erase    astring.erase(i, j)   Erases an element from one index to another     find    astring.find(item)   Returns the index of the first occurrence of item     size    astring.size()   Returns the size of the string      Matching    \/\/shows basic string usage in C++ #include <iostream> #include <string> using namespace std; int main(){ string mystring1 = \"Hello\"; string mystring2 = \"World!\"; string mystring3; mystring3 = mystring1 + \" \" + mystring2; cout << mystring3 << endl; cout << mystring2 << \" begins at \"; cout << mystring3.find(mystring2) << endl; return 0; }     #shows basic string usage in Python def main(): mystring1 = \"Hello\" mystring2 = \"World!\" mystring3 = mystring1 + \" \" + mystring2 print(mystring3) print(mystring2, end=\" \") print(\"begins at\", end=\" \") print(str(mystring3.find(mystring2))) main()    Check your understanding by completing the following question.     Hash Tables  A hash table is a collection of associated pairs of items where each pair consists of a key and a value . Hash tables are often called the more general term map because the associated hash function maps the key to the value. Nevertheless, it is better to use the more precise term, hash table because other kinds of maps are sometimes implemented with a different underlying data structure.  Each hash table has a hash function which given the key as input to the hash function returns the location of the associated value as the output. This makes look up fast.  In C++, the unordered_map implements the hash table, and the <unordered_map> library must be included as follows:  #include <unordered_map>  The syntax for hash table access is much like we might expect except that instead of using the index of the item for look-up, we use the key. Hash tables can be initialized with key-value pairs and key-value pairs can also be added later as we see in the following example. In C++, the keyword first is used for the key, and second is used for the associated value.    \/\/shows how hash tables can be used in C++ #include <iostream> #include <unordered_map> #include <string> using namespace std; int main() { unordered_map<string, string> spnumbers; spnumbers = { {\"one\", \"uno\"}, {\"two\", \"dos\"} }; spnumbers[\"three\"] = \"tres\"; spnumbers[\"four\"] = \"cuatro\"; cout << \"one is \"; cout << spnumbers[\"one\"] << endl; cout << spnumbers.size() << endl; }     #shows how hash tables can be used in python def main(): spnumbers = {\"one\":\"uno\",\"two\":\"dos\"} spnumbers[\"four\"]=\"cuatro\" spnumbers[\"three\"]=\"tres\" print(\"one is\", end=\" \") print(spnumbers[\"one\"]) print(len(spnumbers)) main()    It is important to note that hash tables are organized by the location given by the hash function rather than being in any particular order with respect to the keys. This makes look-up extremely fast. Hence, although it is possible to iterate through a hash table, it is an odd thing to do because the data is not typically stored sequentially. Iterators of an unordered_map are implemented using pointers to point to elements of the value type as we see in the following example.    \/\/shows how to iterate through a hash table in C++ #include <iostream> #include <unordered_map> #include <string> using namespace std; int main() { unordered_map<string, string> spnumbers; spnumbers = { {\"one\",\"uno\"},{\"two\",\"dos\"},{\"three\",\"tres\"},{\"four\",\"cuatro\"},{\"five\",\"cinco\"} }; for (auto i=spnumbers.begin(); i!=spnumbers.end(); i++ ){ cout << i->first << \":\"; cout << i->second << endl; } }     #shows how to iterate through a hash table in python def main(): spnumbers = {\"one\":\"uno\",\"two\":\"dos\",\"three\":\"tres\",\"four\":\"cuatro\",\"five\":\"cinco\" } for key in spnumbers: print(key, end=\":\") print(spnumbers[key]) main()    Hash Tables have both methods and operators. describes them, and the session shows them in action.   Important Hash Table Operators Provided in C++    Operator    Use    Explanation      [ ]    mymap[k]   Returns the value associated with k , otherwise throws error     count    mymap.count(key)   Returns true if key is in mymap , false otherwise     erase    mymap.erase(key)   Removes the entry from mymap      begin    mymap.begin()   An iterator to the first element in mymap      end    mymap.end(key)   An iterator pointing to past-the-end element of mymap       Unordered Sets  An unordered_set is an unordered collection of zero or more unique C++ data values of a particular type. To use unordered_sets, you import unordered_set from the Standard template library with #include <unorderd_set> .  Unordered_sets allow for fast retrieval of individual elements based on their value. In an unordered_set, the value of an element is at the same time its key, that identifies it uniquely. Keys are immutable , therefore, the elements in an unordered_set cannot be modified once in the container - However, they can be inserted and removed.  Unordered sets do not allow duplicates and are initialized using comma-delimited values enclosed in curly braces. The collection can be assigned to a variable as shown below.  set<int> mySet = {3, 6, 4, 78, 10}  Unordered sets support a number of methods that should be familiar to those who have worked with sets in a mathematics setting. provides a summary. Examples of their use follow.   Methods Provided by Sets in C++    Method Name    Use    Explanation      union    set_union()   Returns a new set with all elements from both sets     intersection    set_intersection()   Returns a new set with only those elements common to both sets     difference    set_difference()   Returns a new set with all items from first set not in second     add    aset.insert(item)   Adds item to the set     remove    aset.erase(item)   Removes item from the set     clear    aset.clear()   Removes all elements from the set    The code below is an example of a program that can detect if a specific char is in an unordered set.   \/\/code detects if a specific char is in an unordered set. #include <iostream> #include <unordered_set> using namespace std; void checker(unordered_set<char> set, char letter){ if(set.find(letter) == set.end()){ cout << \"letter \" << letter << \" is not in the set.\" << endl; } else{ cout << \"letter \" << letter << \" is in the set.\" << endl; } } int main(){ unordered_set<char> charSet = {'d', 'c', 'b', 'a'}; char letter = 'e'; checker(charSet, letter); charSet.insert('e'); checker(charSet, letter); return 0; }   the find method used for a conditional in Checker compares each item in the set with the given parameter until there is a match. the set.find(letter) == set.end() section means that if find cannot find the letter before reaching the end of the set, then letter is not contained in the set.   Reading Questions  Match the Hash Table operations with their corresponding explination. Feedback shows incorrect matches.   begin  An iterator to the first element in the hash table.    [ ]  Returns the value associated with the key, creating a default entry if necessary.    erase  Deletes the entry from the hash table.    at  Returns the value associated with the key, otherwise throws error.    end  An iterator pointing to past-the-end element of the hash table.    count  Returns true if key is in the hash table, and false otherwise.    Match the Unordered Sets operations with their corresponding explanation. Feedback shows incorrect matches. union Returns a new set with all elements from both sets. intersection Returns a new set with only those elements common to both sets. difference Returns a new set with all items from first set not in second. add Adds item to the set. remove erases item from the set. clear Removes all elements from the set.   Which C++ structure is the best choice for a group of ordered data of a fixed length?     An array    Correct!      A hash table    No. hash tables are not ordered.      A string    A string would only work for character data. Try again.      A vector    There is a better choice given that the group is fixed length      More than one of the above    Only of the above is best.     Drag each data type to its' corresponding C++ initialization syntax. Feedback shows incorrect matches. Array { What , am , I , \"am\"} Set { What , am , I } String What am I Hash Table { { What , am I } }   In the above example, what happened to otherdata[ ] in C++?     Nothing. Everything is fine.    Actually, there is a problem. Look carefully.      All data was automatically reinitialized.    No. C++ just does what you tell it to do.      I have no idea. Please give me a hint.    Try again. One of these is indeed correct. Look at the memory addresses.      The first loop went out of bounds and wrote over the values in otherdata.    Right!      None of the above.    One of the above is indeed correct.      What is the correct way to declare an array in C++?     int myarray(5);    Check the characters at the end of the array! Right now that is a function!      myarray[5];    You are forgetting something important!      int myarray[5];    Good work!      None of the above.    Check the characters at the end of the array!     Match the Vector operations with their corresponding explination. Feedback shows incorrect matches.  [ ] Accesses value of an element.  = Assigns value to an element.  push_back Appends item to the end of the vector.  pop_back Deletes last item of the vector.   Match the Vector operations with their corresponding explination. Feedback shows incorrect matches.  insert Injects an item into the vector.  erase Deletes an element from the choosen index.  size Returns the actual capacity used by elements.  capacity Returns the ammount of allocated storage space.  reserve Request a change in space to amount.    Which of the following is the biggest difference between a C++ array and a C++ vector?     Vectors can change size.    Yes, however, there are more benefits to using vectors.      Vectors offer many more features and protections than arrays.    Not all of the protections of arrays are offered by vectors; one can still iterate off of either end.      Vectors don't use contiguous memory, so elements can be inserted.    No. Although elements can be inserted in vectors, they do require contiguous memory.      More than one of the above.    Right! Good job!      None of the above.    One of the above is indeed correct.      What good is the reserve method in a vector?     Nothing. It is completely optional.    It is optional but it does serve a purpose. Try again.      Using it will save time if you know the maximum size needed.    Right!      It is required so memory can be allocated.    It is not required.      None of the above.    One of the above is indeed correct.      What is the correct definition of c-strings?     An array of characters that ends with a terminating null character. For instance, \"\\0\".    Correct! a c-string is different from a string.      A sequential data structure consisting of zero or more characters.    Close, but that is the definition of a string, not a c-string.      A data structure consisting of an ordered collection of data elements of identical type in which each element can be identified by an array index.    Sorry, thats not a string or a c-string.      Sequence container storing data of a single type that is stored in a dynamically allocated array which can change in size.    No, that's a vector.     Match the String operations with their corresponding explination. Feedback shows incorrect matches. [ ] Accesses value of an element. find Returns the index of the first occurrence of item. = Assigns value to an element. push_back Adjoins a character to the end of the string. pop_back Removes the last character from the end of the string. insert Injects a string at a specific index. erase Deletes an element from one index to another. size Returns the capacity of the string. + connects strings. append Adjoins a string to the end of the string.  Drag each data type to its' corresponding C++ initialization syntax. Feedback shows incorrect matches. char 'a' char array {'a'} string \"a\"  Match the Hash Table operations with their corresponding explination. Feedback shows incorrect matches. [ ] Returns the value associated with the key, otherwise throws error. erase Deletes the entry from the hash table. count Returns true if key is in the hash table, and false otherwise. begin An iterator to the first element in the hash table. end An iterator pointing to past-the-end element of the hash table.       "
},
{
  "id": "introduction_collections-2-1",
  "level": "2",
  "url": "introduction_collections.html#introduction_collections-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "collection "
},
{
  "id": "introduction_arrays-2",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "What is an Array? "
},
{
  "id": "introduction_arrays-3",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "array "
},
{
  "id": "introduction_arrays-8",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Why use an Array? "
},
{
  "id": "introduction_arrays-10",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "word "
},
{
  "id": "introduction_arrays-15",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "atomic "
},
{
  "id": "introduction_arrays-17",
  "level": "2",
  "url": "introduction_collections.html#introduction_arrays-17",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Be Cautious with Arrays "
},
{
  "id": "introduction_vectors-2-1",
  "level": "2",
  "url": "introduction_collections.html#introduction_vectors-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Vectors "
},
{
  "id": "introduction_id4",
  "level": "2",
  "url": "introduction_collections.html#introduction_id4",
  "type": "Table",
  "number": "1.10.1",
  "title": "",
  "body": " Common C++ Vector Operators    Vector Operation    Use    Explanation      [ ]    myvector[i]   access value of element at index i     =    myvector[i]=value   assign value to element at index i     push_back    myvect.push_back(item)   Appends item to the far end of the vector     pop_back    myvect.pop_back()   Deletes last item (from far end) of the vector     insert    myvect.insert(i, item)   Inserts an item at index i     erase    myvect.erase(i)   Erases an element from index i     size    myvect.size()   Returns the actual size used by elements     capacity    myvect.capacity()   Returns the size of allocated storage capacity     reserve    myvect.reserve(amount)   Request a change in capacity to amount   "
},
{
  "id": "introduction_strings-2-1",
  "level": "2",
  "url": "introduction_collections.html#introduction_strings-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Strings "
},
{
  "id": "introduction_tab-stringmethods",
  "level": "2",
  "url": "introduction_collections.html#introduction_tab-stringmethods",
  "type": "Table",
  "number": "1.10.2",
  "title": "",
  "body": " String Methods Provided in C++    Method Name    Use    Explanation      [ ]    astring[i]   access value of character at index i     =    astring[i]=value   change value of character at index i     +    string1 + astring2   concatenate strings     append    astring.append(string)   Append to string the end of the string     push_back    astring.push_back(char)   Appends a character to the end of the string     pop_back    astring.pop_back()   Deletes the last character from the end of the string     insert    astring.insert(i, string)   Inserts a string at a specific index     erase    astring.erase(i, j)   Erases an element from one index to another     find    astring.find(item)   Returns the index of the first occurrence of item     size    astring.size()   Returns the size of the string   "
},
{
  "id": "introduction_hash-tables-2",
  "level": "2",
  "url": "introduction_collections.html#introduction_hash-tables-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hash table "
},
{
  "id": "introduction_tab-hashopers",
  "level": "2",
  "url": "introduction_collections.html#introduction_tab-hashopers",
  "type": "Table",
  "number": "1.10.3",
  "title": "",
  "body": " Important Hash Table Operators Provided in C++    Operator    Use    Explanation      [ ]    mymap[k]   Returns the value associated with k , otherwise throws error     count    mymap.count(key)   Returns true if key is in mymap , false otherwise     erase    mymap.erase(key)   Removes the entry from mymap      begin    mymap.begin()   An iterator to the first element in mymap      end    mymap.end(key)   An iterator pointing to past-the-end element of mymap    "
},
{
  "id": "introduction_unordered-sets-2",
  "level": "2",
  "url": "introduction_collections.html#introduction_unordered-sets-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "unordered_set "
},
{
  "id": "introduction_unordered-sets-3",
  "level": "2",
  "url": "introduction_collections.html#introduction_unordered-sets-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "immutable "
},
{
  "id": "introduction_tab-setmethods",
  "level": "2",
  "url": "introduction_collections.html#introduction_tab-setmethods",
  "type": "Table",
  "number": "1.10.4",
  "title": "",
  "body": " Methods Provided by Sets in C++    Method Name    Use    Explanation      union    set_union()   Returns a new set with all elements from both sets     intersection    set_intersection()   Returns a new set with only those elements common to both sets     difference    set_difference()   Returns a new set with all items from first set not in second     add    aset.insert(item)   Adds item to the set     remove    aset.erase(item)   Removes item from the set     clear    aset.clear()   Removes all elements from the set   "
},
{
  "id": "matching_ht",
  "level": "2",
  "url": "introduction_collections.html#matching_ht",
  "type": "Reading Question",
  "number": "1.10.5.1",
  "title": "",
  "body": "Match the Hash Table operations with their corresponding explination. Feedback shows incorrect matches.   begin  An iterator to the first element in the hash table.    [ ]  Returns the value associated with the key, creating a default entry if necessary.    erase  Deletes the entry from the hash table.    at  Returns the value associated with the key, otherwise throws error.    end  An iterator pointing to past-the-end element of the hash table.    count  Returns true if key is in the hash table, and false otherwise.   "
},
{
  "id": "matching_us",
  "level": "2",
  "url": "introduction_collections.html#matching_us",
  "type": "Reading Question",
  "number": "1.10.5.2",
  "title": "",
  "body": "Match the Unordered Sets operations with their corresponding explanation. Feedback shows incorrect matches. union Returns a new set with all elements from both sets. intersection Returns a new set with only those elements common to both sets. difference Returns a new set with all items from first set not in second. add Adds item to the set. remove erases item from the set. clear Removes all elements from the set. "
},
{
  "id": "mc_fixed",
  "level": "2",
  "url": "introduction_collections.html#mc_fixed",
  "type": "Reading Question",
  "number": "1.10.5.3",
  "title": "",
  "body": " Which C++ structure is the best choice for a group of ordered data of a fixed length?     An array    Correct!      A hash table    No. hash tables are not ordered.      A string    A string would only work for character data. Try again.      A vector    There is a better choice given that the group is fixed length      More than one of the above    Only of the above is best.    "
},
{
  "id": "collect_data_types",
  "level": "2",
  "url": "introduction_collections.html#collect_data_types",
  "type": "Reading Question",
  "number": "1.10.5.4",
  "title": "",
  "body": "Drag each data type to its' corresponding C++ initialization syntax. Feedback shows incorrect matches. Array { What , am , I , \"am\"} Set { What , am , I } String What am I Hash Table { { What , am I } } "
},
{
  "id": "mc_werror",
  "level": "2",
  "url": "introduction_collections.html#mc_werror",
  "type": "Reading Question",
  "number": "1.10.5.5",
  "title": "",
  "body": " In the above example, what happened to otherdata[ ] in C++?     Nothing. Everything is fine.    Actually, there is a problem. Look carefully.      All data was automatically reinitialized.    No. C++ just does what you tell it to do.      I have no idea. Please give me a hint.    Try again. One of these is indeed correct. Look at the memory addresses.      The first loop went out of bounds and wrote over the values in otherdata.    Right!      None of the above.    One of the above is indeed correct.    "
},
{
  "id": "mc_array",
  "level": "2",
  "url": "introduction_collections.html#mc_array",
  "type": "Reading Question",
  "number": "1.10.5.6",
  "title": "",
  "body": " What is the correct way to declare an array in C++?     int myarray(5);    Check the characters at the end of the array! Right now that is a function!      myarray[5];    You are forgetting something important!      int myarray[5];    Good work!      None of the above.    Check the characters at the end of the array!    "
},
{
  "id": "matching_vectors",
  "level": "2",
  "url": "introduction_collections.html#matching_vectors",
  "type": "Reading Question",
  "number": "1.10.5.7",
  "title": "",
  "body": "Match the Vector operations with their corresponding explination. Feedback shows incorrect matches.  [ ] Accesses value of an element.  = Assigns value to an element.  push_back Appends item to the end of the vector.  pop_back Deletes last item of the vector.  "
},
{
  "id": "matching_vectors2",
  "level": "2",
  "url": "introduction_collections.html#matching_vectors2",
  "type": "Reading Question",
  "number": "1.10.5.8",
  "title": "",
  "body": "Match the Vector operations with their corresponding explination. Feedback shows incorrect matches.  insert Injects an item into the vector.  erase Deletes an element from the choosen index.  size Returns the actual capacity used by elements.  capacity Returns the ammount of allocated storage space.  reserve Request a change in space to amount.  "
},
{
  "id": "mc_array_vector",
  "level": "2",
  "url": "introduction_collections.html#mc_array_vector",
  "type": "Reading Question",
  "number": "1.10.5.9",
  "title": "",
  "body": " Which of the following is the biggest difference between a C++ array and a C++ vector?     Vectors can change size.    Yes, however, there are more benefits to using vectors.      Vectors offer many more features and protections than arrays.    Not all of the protections of arrays are offered by vectors; one can still iterate off of either end.      Vectors don't use contiguous memory, so elements can be inserted.    No. Although elements can be inserted in vectors, they do require contiguous memory.      More than one of the above.    Right! Good job!      None of the above.    One of the above is indeed correct.    "
},
{
  "id": "mc_vector1",
  "level": "2",
  "url": "introduction_collections.html#mc_vector1",
  "type": "Reading Question",
  "number": "1.10.5.10",
  "title": "",
  "body": " What good is the reserve method in a vector?     Nothing. It is completely optional.    It is optional but it does serve a purpose. Try again.      Using it will save time if you know the maximum size needed.    Right!      It is required so memory can be allocated.    It is not required.      None of the above.    One of the above is indeed correct.    "
},
{
  "id": "cstringquestion1_1",
  "level": "2",
  "url": "introduction_collections.html#cstringquestion1_1",
  "type": "Reading Question",
  "number": "1.10.5.11",
  "title": "",
  "body": " What is the correct definition of c-strings?     An array of characters that ends with a terminating null character. For instance, \"\\0\".    Correct! a c-string is different from a string.      A sequential data structure consisting of zero or more characters.    Close, but that is the definition of a string, not a c-string.      A data structure consisting of an ordered collection of data elements of identical type in which each element can be identified by an array index.    Sorry, thats not a string or a c-string.      Sequence container storing data of a single type that is stored in a dynamically allocated array which can change in size.    No, that's a vector.    "
},
{
  "id": "matching_strings",
  "level": "2",
  "url": "introduction_collections.html#matching_strings",
  "type": "Reading Question",
  "number": "1.10.5.12",
  "title": "",
  "body": "Match the String operations with their corresponding explination. Feedback shows incorrect matches. [ ] Accesses value of an element. find Returns the index of the first occurrence of item. = Assigns value to an element. push_back Adjoins a character to the end of the string. pop_back Removes the last character from the end of the string. insert Injects a string at a specific index. erase Deletes an element from one index to another. size Returns the capacity of the string. + connects strings. append Adjoins a string to the end of the string. "
},
{
  "id": "string_types",
  "level": "2",
  "url": "introduction_collections.html#string_types",
  "type": "Reading Question",
  "number": "1.10.5.13",
  "title": "",
  "body": "Drag each data type to its' corresponding C++ initialization syntax. Feedback shows incorrect matches. char 'a' char array {'a'} string \"a\" "
},
{
  "id": "matching_HT",
  "level": "2",
  "url": "introduction_collections.html#matching_HT",
  "type": "Reading Question",
  "number": "1.10.5.14",
  "title": "",
  "body": "Match the Hash Table operations with their corresponding explination. Feedback shows incorrect matches. [ ] Returns the value associated with the key, otherwise throws error. erase Deletes the entry from the hash table. count Returns true if key is in the hash table, and false otherwise. begin An iterator to the first element in the hash table. end An iterator pointing to past-the-end element of the hash table. "
},
{
  "id": "introduction_defining-c-functions",
  "level": "1",
  "url": "introduction_defining-c-functions.html",
  "type": "Section",
  "number": "1.11",
  "title": "Defining C++ Functions",
  "body": " Defining C++ Functions   In general, we can hide the details of any computation by defining a function. A function definition requires a name, a group of parameters, a return type, and a body. It may either return a variable, value, or nothing (specified by the keyword void). For example, the simple function defined below returns an integer which is the double of the value you pass into it.    #include <iostream> using namespace std; int timesTwo(int num) { \/* return type int which indicates that an integer is being returned *\/ return num*2; } int main() { \/* return type int which indicates that an integer is being returned *\/ cout<<timesTwo(5)<<endl; return 0; }    The syntax for this function definition includes the name, timesTwo , and a parenthesized list of formal parameters and their types. For this function an int named num is the only formal parameter, which suggests that timesTwo needs only one piece of data to do its work. The details, hidden inside the box, simply compute the result of num*2 and return it. We can invoke or call the timesTwo function by asking the C++ to evaluate it, passing an actual parameter value, in this case, 3 . Note that the call to timesTwo returns an integer that can in turn be passed to another invocation.  Let us look at a similar function.    #include <iostream> using namespace std; void timesTwoVoid(int num) { \/* return type void which indicates that an nothing is being returned *\/ cout<< num*2<<endl; } int main() { \/* return type int which indicates that an integer is being returned *\/ timesTwoVoid(5); return 0; }    timesTwoVoid behave very similarly to timesTwo . However, there is one key difference between them. Instead of the int in timesTwo , timesTwoVoid has a void in front of its function definition. Unlike timesTwo , timesTwoVoid is a non-fruitful function meaning it does not return a value even though it can still print something out.  We could go a step further and implement our own square root function by using a well-known technique called Newton's Method. Newton's Method for approximating square roots performs an iterative computation that converges on the correct value. The equation takes a value and repeatedly guesses the square root by making each the in the subsequent iteration. The initial guess used here is . shows a function definition that accepts a value and returns the square root of after making 20 guesses. Again, the details of Newton's Method are hidden inside the function definition and the user does not have to know anything about the implementation to use the function for its intended purpose. also shows the use of the \/\/ characters as a comment marker. Any characters that follow the \/\/ on a line are ignored.    #include <iostream> using namespace std; double squareroot(double n) { \/*return type int which indicates that a decimal is being returned*\/ double root = n \/ 2; for (int i = 0; i < 20; i++) { root = (.5) * (root + (n \/ root)); } return root; } int main() { cout << squareroot(9) << endl; cout << squareroot(4563) << endl; return 0; }     Parameter Passing: by Value versus by Reference  pass-by-value In all of the functions we have written thus far, we have used a function calling mechanism called pass-by-value . Calling a function by value involves copying the contents of the arguments into the memory locations of the corresponding formal parameters. If the function changes the values of the parameters, the original contents in the memory referenced by the arguments of the calling function do not change.  Consider the following two function definitions:  void functionExample( int inputVar ) { \/*return type void which indicates that nothing is being returned*\/ int nextVar = inputVar * 2; inputVar = 4; cout << \"nextVar = \" << nextVar << \" inputVar = \" << inputVar; } void callingFunction() { \/*return type int which indicates that nothing is being returned*\/ int myVar = 10; functionExample( myVar ); cout << \"myVar = \" << myVar; }  When the function callingFunction() executes, it calls functionExample(...) with the variable myVar having the value 10. Within functionExample(...) , the value of 10 is copied from myVar to the formal parameter inputVar , so the value of nextVar is 10x2, or 20. The next statement changes the contents of inputVar to 4, so the cout statement within this function produces the output:  nextVar = 20 inputVar = 4  Notice what happens when functionExample(...) ends and execution returns to callingFunction() . The contents of myVar is still the same , as the location for myVar differs from where inputVar is stored. Thus, myVar still has the value 10, and the cout statement after the function call will produce the output:  myVar = 10  In other words, any changes to the variables are local to the function, which is exactly what we want.   However, there is a problem.  pass-by-reference We have seen examples of C++ functions that return no value or a single value. How about when we want the function to return more than one value? We need another function calling mechanism called pass-by-reference . When using this mechanism, the actual location in memory referenced by the arguments are sent rather than the values in that location. To let the compiler know that you intend to use pass by reference, you attach an & to the end of the type name in the formal parameter list in the function declaration and header. When you do this, any changes to the values of the parameters will change the value of the arguments as well.  An example of a function where this is useful is a function that takes two values as input and swaps their order. Consider the following program fragment of a function called swap_values(...) that swaps its two inputs and the main() function that calls swap_values(...) .    #include <iostream> using namespace std; \/\/ swap_values() function definition \/\/ Interchanges the values located by variable1 and variable2. \/\/ Notice that this function does not return anything! void swap_values(int &variable1, int &variable2) { int temp; \/\/ temporary storage for swap temp = variable1; variable1 = variable2; variable2 = temp; } int main( ) { int first_num, second_num; first_num = 7; second_num = 8; cout << \"Two numbers before swap function: 1) \" << first_num << \" 2) \" << second_num << endl; swap_values(first_num, second_num); cout << \"The numbers after swap function: 1) \" << first_num << \" 2) \" << second_num; return 0; }   For the program in to reverse the order of the integers the users types in, the function swap_values(...) must be able to change the values of the arguments. Try removing one or both of the & ‘s in this code to see what happens.     Arrays as Parameters in Functions  array parameters Functions can be used with array parameters to maintain a structured design. However, a formal parameter for an array is neither a call-by-value nor a call-by-reference, but a new type of parameter pass called an array parameter. In a function definition, an array parameter looks like a pass-by-value parameter because there is no ampersand symbol (&), but the variable name is instead followed by a set of square brackets ([ and ]).  The following example function returns the average hours worked over the array of integers (note that we need to also pass in the number of elements in that array because the array parameter list[] does not include that information):  double average( int list[], int length ) { \/\/ It is correct syntax to omit the array length on the array itself. double total = 0; \/\/return type double which indicates that a decimal is being returned int count; for( count = 0; count < length; count++ ) { total += double(list[count]); }; return (total \/ length); }  Array parameters look like pass by value, but they are effectively similar to pass by reference parameters. When they execute, the functions with these parameters do not make private copies of the arrays. Instead, the reference is passed to reduce the impact on memory. Arrays can therefore always be permanently changed when passed as arguments to functions.  After a call to the following function, each element in the third array argument is equal to the sum of the corresponding two elements in the first and second arguments:  void add_lists( int first[], int second[], int total[], int length ) { \/\/return type void which indicates that nothing is returned int count; for( count = 0; count < length; count++ ) { total[count] = first[count] + second[count]; };}  Upon further examination, we can see that the first two arrays do not change values. To prevent ourselves from accidentally modifying any of these arrays, we can add the modifier const in the function head:  void add_lists( const int first[], const int second[], int total[], int length ) { \/\/return type void which indicates that nothing is returned int count; for( count = 0; count < length; count++ ) { total[count] = first[count] + second[count]; };}  These changes would ensure that the compiler will then not accept any statements within the function's definition that potentially modify the elements of the arrays first or second .    Function Overloading  function overloading Function overloading is the ability to create multiple functions with identical names but different implementations. Not all languages support function overloading. Python does not, for example, but an optional parameter can often be used to accomplish the same task.  In C++ programming, two or more functions can have the same name when they can be distinguished by the parameters. Hence, C++ allows function overloading when either the data types of the parameters differ or the number of parameters differ.  Overloading is a nice feature of the C++ language.    \/\/showcases function overloading in C++ #include <iostream> using namespace std; void myfunct(int n) { cout << \"1 parameter: \" << n <<endl; } void myfunct(int n, int m) { cout << \"2 parameters: \" << n; cout << \" and \" << m <<endl; } int main() { myfunct(4); myfunct(5, 6); myfunct(100); return 0; }     #showcases function overloading in Python def myfunct(n, m=None): if m is None: print(\"1 parameter: \" + str(n)) else: print(\"2 parameters: \" + str(n), end=\"\") print(\" and \", str(m)) def main(): myfunct(4); myfunct(5, 6); myfunct(100); main()     Reading Questions  Take a look at the code below:  #include <iostream> using namespace std; void dogWalk(int steps){ for (int step = 0; step < steps; step++){ cout << \"dog walked \"<< step << \" steps!\"<< endl; } } int main() { dogWalk(11); return 0; }   What is the correct return type of the function above int main() ?     void    Correct, nothing is returned!      int    Not quite, check the value preceding the name of the function!      dog    Not quite, dog is not even a data type!      dogWalk    Not quite, that is the name of the function itself!      What are benefits of function overloading?     Helps keep consintency in the way your functions are named across your program.    Take a look at the other answers as well...      Functions that do similar tasks differ based on parameters rather than by name.    Take a look at the other answers as well...      A function in essence can fulfill multiple tasks depending on the parameters.    Take a look at the other answers as well...      Removes the limit on how many parameters can be written or passed.    Wrong! function overloading has nothing to do with removing the limit of parameters.      Self Check  Here's a self check that really covers everything so far. You may have heard of the infinite monkey theorem? The theorem states that a monkey hitting keys at random on a typewriter keyboard for an infinite amount of time will almost surely type a given text, such as the complete works of William Shakespeare. Well, suppose we replace a monkey with a C++ function. How long do you think it would take for a C++ function to generate just one sentence of Shakespeare? The sentence we'll shoot for is: methinks it is like a weasel  You're not going to want to run this one in the browser, so fire up your favorite C++ IDE. The way we'll simulate this is to write a function that generates a string that is 28 characters long by choosing random letters from the 26 letters in the alphabet plus the space. We'll write another function that will score each generated string by comparing the randomly generated string to the goal. Hint: You will need to import the <random> library for this.  A third function will repeatedly call generate and score, then if 100% of the letters are correct we are done. If the letters are not correct then we will generate a whole new string. To make it easier to follow your program's progress this third function should print out the best string generated so far and its score every 1000 tries.    Self Check Challenge  See if you can improve upon the program in the self check by keeping letters that are correct and only modifying one character in the best string so far. This is a type of algorithm in the class of ‘hill climbing' algorithms, that is we only keep the result if it is better than the previous one.        "
},
{
  "id": "introduction_lst-root",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_lst-root",
  "type": "Listing",
  "number": "1.11.1",
  "title": "",
  "body": "  #include <iostream> using namespace std; double squareroot(double n) { \/*return type int which indicates that a decimal is being returned*\/ double root = n \/ 2; for (int i = 0; i < 20; i++) { root = (.5) * (root + (n \/ root)); } return root; } int main() { cout << squareroot(9) << endl; cout << squareroot(4563) << endl; return 0; }  "
},
{
  "id": "introduction_parameter-passing-by-value-versus-by-reference-2",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_parameter-passing-by-value-versus-by-reference-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pass-by-value "
},
{
  "id": "introduction_parameter-passing-by-value-versus-by-reference-7",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_parameter-passing-by-value-versus-by-reference-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "still the same "
},
{
  "id": "introduction_parameter-passing-by-value-versus-by-reference-12",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_parameter-passing-by-value-versus-by-reference-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "more pass-by-reference "
},
{
  "id": "activepassrefcpp",
  "level": "2",
  "url": "introduction_defining-c-functions.html#activepassrefcpp",
  "type": "Listing",
  "number": "1.11.2",
  "title": "",
  "body": "  #include <iostream> using namespace std; \/\/ swap_values() function definition \/\/ Interchanges the values located by variable1 and variable2. \/\/ Notice that this function does not return anything! void swap_values(int &variable1, int &variable2) { int temp; \/\/ temporary storage for swap temp = variable1; variable1 = variable2; variable2 = temp; } int main( ) { int first_num, second_num; first_num = 7; second_num = 8; cout << \"Two numbers before swap function: 1) \" << first_num << \" 2) \" << second_num << endl; swap_values(first_num, second_num); cout << \"The numbers after swap function: 1) \" << first_num << \" 2) \" << second_num; return 0; }  "
},
{
  "id": "introduction_arrays-as-parameters-in-functions-2",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_arrays-as-parameters-in-functions-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "array parameters "
},
{
  "id": "introduction_function-overloading-2",
  "level": "2",
  "url": "introduction_defining-c-functions.html#introduction_function-overloading-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Function overloading "
},
{
  "id": "dog_walker",
  "level": "2",
  "url": "introduction_defining-c-functions.html#dog_walker",
  "type": "Reading Question",
  "number": "1.11.3.1",
  "title": "",
  "body": " What is the correct return type of the function above int main() ?     void    Correct, nothing is returned!      int    Not quite, check the value preceding the name of the function!      dog    Not quite, dog is not even a data type!      dogWalk    Not quite, that is the name of the function itself!    "
},
{
  "id": "foverloading",
  "level": "2",
  "url": "introduction_defining-c-functions.html#foverloading",
  "type": "Reading Question",
  "number": "1.11.3.2",
  "title": "",
  "body": " What are benefits of function overloading?     Helps keep consintency in the way your functions are named across your program.    Take a look at the other answers as well...      Functions that do similar tasks differ based on parameters rather than by name.    Take a look at the other answers as well...      A function in essence can fulfill multiple tasks depending on the parameters.    Take a look at the other answers as well...      Removes the limit on how many parameters can be written or passed.    Wrong! function overloading has nothing to do with removing the limit of parameters.    "
},
{
  "id": "rq-defining-function-6",
  "level": "2",
  "url": "introduction_defining-c-functions.html#rq-defining-function-6",
  "type": "Note",
  "number": "1.11.3",
  "title": "Self Check.",
  "body": " Self Check  Here's a self check that really covers everything so far. You may have heard of the infinite monkey theorem? The theorem states that a monkey hitting keys at random on a typewriter keyboard for an infinite amount of time will almost surely type a given text, such as the complete works of William Shakespeare. Well, suppose we replace a monkey with a C++ function. How long do you think it would take for a C++ function to generate just one sentence of Shakespeare? The sentence we'll shoot for is: methinks it is like a weasel  You're not going to want to run this one in the browser, so fire up your favorite C++ IDE. The way we'll simulate this is to write a function that generates a string that is 28 characters long by choosing random letters from the 26 letters in the alphabet plus the space. We'll write another function that will score each generated string by comparing the randomly generated string to the goal. Hint: You will need to import the <random> library for this.  A third function will repeatedly call generate and score, then if 100% of the letters are correct we are done. If the letters are not correct then we will generate a whole new string. To make it easier to follow your program's progress this third function should print out the best string generated so far and its score every 1000 tries.  "
},
{
  "id": "rq-defining-function-7",
  "level": "2",
  "url": "introduction_defining-c-functions.html#rq-defining-function-7",
  "type": "Note",
  "number": "1.11.4",
  "title": "Self Check Challenge.",
  "body": " Self Check Challenge  See if you can improve upon the program in the self check by keeping letters that are correct and only modifying one character in the best string so far. This is a type of algorithm in the class of ‘hill climbing' algorithms, that is we only keep the result if it is better than the previous one.  "
},
{
  "id": "introduction_object-oriented-programming-in-c-defining-classes",
  "level": "1",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html",
  "type": "Section",
  "number": "1.12",
  "title": "Object-Oriented Programming in C++: Defining Classes",
  "body": " Object-Oriented Programming in C++: Defining Classes   object-oriented programming We stated earlier that C++ is an object-oriented programming language . Object-oriented programming is a programming technique based on real world things such as turtles, airplanes, customers, etc. Each object has its own characteristics or attributes as well as its own set of behaviors.  object instance So far, we have used a number of built-in classes to show examples of data and control structures. One of the most powerful features in an object-oriented programming language is the ability to allow a programmer (problem solver) to create new classes that model data that is needed to solve the problem. Each object created with the class data type is called an instance of the class.  object attributes class methods class Remember that we use abstract data types to provide the logical description or blueprint for what a data object looks like (its state given by object attributes ) and what it can do (its behaviors given by class methods ). Defining a class creates the blueprint which defines the behaviors and attributes of objects of that new data type. By building a class that implements an abstract data type, a programmer can take advantage of the abstraction process and at the same time provide the details necessary to actually use the abstraction in a program. Hence, whenever we want to implement an abstract data type, we will do so with a new class which will provide the blueprint or template for all of the objects of that type.  Four key principles are associated with object-oriented programming:     abstraction    encapsulation    inheritance    polymorphism     We will highlight each principle via examples.    A Fraction Class  A very common example to show the details of implementing a user-defined class is to construct a class to implement the abstract data type Fraction . We have already seen that C++ provides a number of numeric data types for our use. There are times, however, that it would be most appropriate to be able to create data objects that both look and act like fractions.  A fraction such as consists of two parts. The top value, known as the numerator, can be any integer. The bottom value, called the denominator, can be any integer greater than 0 (negative fractions have a negative numerator). Although it is possible to create a floating point approximation for any fraction, we would like to represent the fraction using exact values to avoid problems inherent in approximations.  Since defining a class makes a new data type, the operations for the Fraction type will allow a Fraction data object to behave like any other numeric type. We need to be able to add, subtract, multiply, and divide fractions. We also want to be able to print fractions using the standard slash form, for example 3\/5. In addition, all fraction methods should return results in their lowest terms so that no matter what computation is performed, we always end up with the most common form.  In C++, we define a new class by providing a name and a set of method definitions that are syntactically similar to function definitions. For example:   class Fraction { \/\/ The class methods and class variables go here }; \/\/ The \";\" is required by C++ to end a class definition  Creating a class in C++   class Fraction: #the methods go here  Creating a class in Python   constructor provides the framework for us to define the methods. The first method that all classes should provide is the constructor . The constructor defines the way in which data objects are created. It's considered good practice to have a constructor completely setup a class object, so that it's impossible to create an object in an invalid state. To create a Fraction object, we will need to initialize two pieces of data, the numerator and the denominator. In C++, the constructor method is always named with the same name as the class it creates and is shown in .   Constructor for Fraction class  C++ class Fraction { public: Fraction(int top, int bottom) { \/** Fraction constructor method *\/ num = top; \/\/ setting num's value den = bottom; \/\/ setting den's value } private: int num; \/\/ num attribute int den; \/\/ den attribute };  Python class Fraction: def __init__(self,top,bottom): self.num = top self.den = bottom  As described earlier, fractions require two pieces of state data, the numerator and the denominator. The notation int num outside the constructor defines the fraction object to have an internal data object called num as part of its state. Likewise, int den creates the denominator. The values of the two formal parameters are initially assigned to the state, allowing the new fraction object to know its starting values.  To create an object or instance of the Fraction class, we must invoke the constructor. This happens by using the name of the class and passing actual values for the necessary state after the variable name. For example,   Fraction myfraction(3, 5);  Invoking constructor in C++   myfraction = Fraction(3, 5)  Invoking constructor in Python   creates an object called myfraction representing the fraction (three-fifths). shows this object as it is now implemented.   An instance of the Fraction Class   Diagram showing an instance of the Fraction class. The instance is named 'myfraction' and is depicted as a set of concentric circles. The innermost circle is labeled 'State' and contains two segments: 'num' with the number 3 above 'den' with the number 5, representing the numerator and denominator of a fraction. The middle circle is labeled 'Methods', indicating the functionality associated with the fraction instance.      Abstraction and Encapsulation  Another way to think about fractions is as parts of a whole as shown in the following figure:     abstraction Because we are using classes to create abstract data types, we should probably define the term abstract in this context. In object-oriented programming, abstraction requires you to focus solely on the desired properties and behaviors of the objects, discarding everything else that is unimportant or irrelevant. As a result, if we don't need to consider the parts of a whole visual metaphor of a fraction, we won't include it in the Fraction class. If a given metaphor is important, we will include it. For our purposes, we want to think of fractions as numbers, so we will avoid using the parts of a whole visual metaphor.  access keywords encapsulation The object-oriented principle of encapsulation refers to the practice of grouping or encapsulating related data and the methods that operate on that data into a single unit, typically a class. Encapsulation also requires we hide most of the internal contents of that class, except what is absolutely necessary to expose. Hence, we will restrict the access to our class as much as we can, so that a user can change the class properties and behaviors only from methods provided by the class. C++ allows us to control access with the access keywords  public and private . It is typical in C++ to make all data attributes private and most methods public . All attribute variables under the private keyword will only be able to be accessed by the object's class methods, not by the user. Only C++'s ‘ public methods can be accessed and used by the user. Because we want our user to be able to call every constructor directly, we always place the constructor under public . A third access keyword, protected will be discussed later.    Polymorphism  polymorphism Polymorphism means the ability to appear in many forms. In object-oriented programming, polymorphism refers to the ability to handle objects or methods differently depending on their data type, class, number of arguments, etc. For example, we can overload a constructor with different numbers and types of arguments to give us multiple ways to instantiate an object of a class as shown in the next listing for the Fraction class.  Fraction(int top, int bottom){ num = top; den = bottom; } Fraction (int top){ num = top; den = 1; } Fraction (){ num = 0; den = 1; }  Calling the constructor with two arguments will invoke the first method, calling it with a single argument will invoke the second method, and calling it with no arguments will invoke the third method.  Using optional parameters will accomplish the same task in this case. Since the class will behave the same no matter which implementation you use and the user will have no idea which implementation was chosen, this is an example of encapsulation.  Fraction(int top = 0, int bottom = 1){ num = top; den = bottom; }  The next thing we need to do is implement some behaviors that the abstract data type requires. To begin, let's consider what happens when we try to print a Fraction object.  int main() { Fraction myfraction(3, 5); \/\/ Throws an error cout << myfraction << endl; return 0; }  The fraction object, myfraction , does not know how to respond to this request to print to the console. The cout function requires that the object knows how to interact with the << operator so that the string can be sent to the output stream. Without this, our class will throw an error, which is obviously not what we want.  There are two ways we can solve this problem. One is to define a method called something like show that will allow the Fraction object to print itself as a string. We can implement this method as shown in . If we create a Fraction object as before, we can ask it to show itself, in other words, print itself in the proper format by invoking the show method on our fractions.   Implementing a show method  C++ \/\/using functions to print fractions to the command line. #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1){ num = top; den = bottom; } void show(){ cout << num << \"\/\" << den << endl; } private: int num, den; }; int main() { Fraction fraca(3, 5); Fraction fracb(3); Fraction fracc; \/\/notice there are no parentheses here. \/\/ cout << fraca << endl; \/\/uncomment to see error fraca.show(); fracb.show(); fracc.show(); return 0; }  Python def show(self): print(self.num,\"\/\",self.den)   The downside of this approach is that it is not how we expect to print to the console. In C++, there are many operators that are provided for atomic and STL data types that may not work as expected with a user defined class until you overload them. One of these, << , is the operator to send data to the output stream. It would be nicer to provide a better implementation for this method via operator overloading.  operator overloading Like function overloading, operator overloading allows us to make operators work for user defined classes by defining a special meaning for that operator when applied to objects of the class as operands. This is a form of polymorphism because it enables the same operator to have different behaviors depending on the class of the objects involved, demonstrating how the same operation can be adapted to various types.  friend In C++ this new operator needs to be implemented as a friend of the class in order to define the operator's behavior on objects of the class from a non-class method << . Operator overloading is yet another example of polymorphism in object-oriented programming.  friend function A friend function of a class is a function defined outside that class' scope but with the right to access all private and protected members of the class. In C++, we overload an operator by declaring it a friend function in the class definition and giving it a new implementation. Listing 4 shows an example of the << operator being overloaded in the Fraction class. Note that stream operators need to return the address of the stream because of the fact that the stream is changed by the stream operator.  Listing 4    \/*overloading functions to take in different inputs and output the correct results*\/ #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1){ num = top; den = bottom; } \/\/the following tells the compiler to look for this friend's definition outside the class friend ostream &operator << (ostream &stream, const Fraction &frac); private: int num, den; }; ostream &operator << (ostream &stream, const Fraction &frac) { \/** this is the definition. *\/ stream << frac.num << \"\/\" << frac.den; return stream; } int main() { Fraction myfraction(3, 5); cout << myfraction << \" is my fraction\" << endl; return 0; }    def __str__(self): return str(self.num)+\"\/\"+str(self.den) myf = Fraction(3,5) print(myf) print(\"I ate\", myf, \"of the pizza\")   We can overload many other operators for our new Fraction class. Some of the most important of these are the basic arithmetic operations. We would like to be able to create two Fraction objects and then be able to add them together using the standard + notation. At this point, if we try to add two fractions using + , we get the following:   Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; \/\/ >> error: no match for ‘operator+' (operand types are ‘Fraction' and ‘Fraction'))  An error received before overloading   f1 = Fraction(1,4) f2 = Fraction(1,2) f1+f2 Traceback (most recent call last): File \"<pyshell#173>\", line 1, in -toplevel- f1+f2 TypeError: unsupported operand type(s) for +: 'instance' and 'instance'  An error received before overloading   If you look closely at the error, you see that the problem is that the + operator does not understand the Fraction operands.  We can, of course create something like:   f1.add(f2)   f1.__add__(f2)   which would ask the Fraction object f1 to add the Fraction object f2 to itself. It would be much better to be written in the standard notation, f1 + f2 . We can fix this by providing the Fraction class with a friend that overloads the + operator.  As you know, two fractions must have the same denominator to be added. The easiest way to make sure they have the same denominator is to simply use the product of the two denominators as a common denominator so that The implementation is shown in . The addition function returns a new Fraction object with the numerator and denominator of the sum. We can use this method by writing a standard arithmetic expression involving fractions, assigning the result of the addition, and then printing our result.   Adding an addition method  C++ Implementation Fraction operator +(const Fraction &otherFrac){ \/\/Note the return type is a Fraction int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; return Fraction(newnum, newden); }  Python Implementation def __add__(self, otherfraction): newnum = self.num*otherfraction.den + self.den*otherfraction.num newden = self.den * otherfraction.den return Fraction(newnum,newden)  C++ Usage Example \/\/using functions to abstract the idea of a fraction #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1) { num = top; den = bottom; } Fraction operator +(const Fraction &otherFrac) { int newnum = otherFrac.num*den + otherFrac.den*num; int newden = den*otherFrac.den; return Fraction(newnum, newden); } friend ostream &operator << (ostream &stream, const Fraction &frac); private: int num, den; }; ostream &operator << (ostream &stream, const Fraction &frac) { stream << frac.num << \"\/\" << frac.den; return stream; } int main(){ Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; cout << f3 << \" is \"<< f1 << \" + \" << f2 << endl; return 0; }  Python Usage Example f1=Fraction(1,4) f2=Fraction(1,2) f3=f1+f2 print(f3)   The addition method works as we desire, but a couple of things can be improved. When we use a binary operator like + , we like more symmetry. Binary operators can either be members of their left-hand argument's class or friend functions. Since the stream operators' left-hand argument is a stream, stream operators (such as << and >>) must be either member functions of the stream class or friend functions of the class they are used with. However, that is not true for the + operator. Let's rewrite the addition operator as a friend function.  Listing 6   Fraction operator +(const Fraction &otherFrac){ \/\/Note the return type is a Fraction int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; return Fraction(newnum, newden); }  Rewriting addition operator as a friend function   def __add__(self,otherfraction): newnum = self.num*otherfraction.den + self.den*otherfraction.num newden = self.den * otherfraction.den return Fraction(newnum,newden)    \/\/overloading the addition operator to create clearer syntax #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1) { num = top; den = bottom; } friend ostream &operator << (ostream &stream, const Fraction &frac); friend Fraction operator +(const Fraction &frac1, const Fraction &frac2); private: int num, den; }; ostream &operator << (ostream &stream, const Fraction &frac) { stream << frac.num << \"\/\" << frac.den; return stream; } Fraction operator +(const Fraction &frac1, const Fraction &frac2) { int newnum = frac1.num * frac2.den + frac1.den * frac2.num; int newden = frac1.den * frac2.den; return Fraction(newnum, newden); } int main(){ Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; cout << f3 << \" is \"<< f1 << \" + \" << f2 << endl; return 0; }   How you choose to overload operators like + is a design choice since both methods will work perfectly well. This is another example of encapsulation; your user does not need to know which you choose to use!  There is one more thing we can improve in our addition function. Note that is the correct result ( ) but that it is not in the lowest terms representation. The best representation would be . In order to be sure that our results are always in the lowest terms, we need a helper function that knows how to reduce fractions. This function will need to look for the greatest common divisor, or GCD. We can then divide the numerator and the denominator by the GCD and the result will be reduced to lowest terms.  The best-known algorithm for finding a greatest common divisor is Euclid's Algorithm, which will be discussed in detail in Chapter 8. Euclid's Algorithm states that the greatest common divisor of two integers and is if divides evenly. However, if does not divide evenly, then the answer is the greatest common divisor of and the remainder of divided by . We will simply provide an iterative implementation here (see ActiveCode 1 ). Note that this implementation of the GCD algorithm only works when the denominator is positive. This is acceptable for our fraction class because we have said that a negative fraction will be represented by a negative numerator.    #include <iostream> using namespace std; int gcd(int m, int n) { while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } int main() { cout << gcd(20, 10) << endl; return 0; }     def gcd(m,n): while m%n != 0: oldm = m oldn = n m = oldn n = oldm%oldn return n print(gcd(20,10))    Now we can use this function to help reduce any fraction. To put a fraction in lowest terms, we will divide the numerator and the denominator by their greatest common divisor. So, for the fraction , the greatest common divisor is 2. Dividing the top and the bottom by 2 creates a new fraction, (see ).   New addition implementation using gcd  #include <iostream> using namespace std; int gcd(int m, int n){ \/** gcd is a helper function, used by but not part of the Fraction class *\/ while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } class Fraction { public: Fraction(int top, int bottom) { num = top; den = bottom; } Fraction(int top){ num = top; den = 1; } Fraction(){ num = 1; den = 1; } Fraction operator +(const Fraction &otherFrac) { int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; int common = gcd(newnum, newden); return Fraction(newnum\/common, newden\/common); } friend ostream& operator << (ostream& stream, const Fraction& fraction); private: int num, den; }; ostream & operator << (ostream& stream, const Fraction& fraction) { stream<<fraction.num<<\"\/\"<<fraction.den; return stream; } int main(){ Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; cout << f3 << \" is \"<< f1 << \" + \" << f2 << endl; return 0; }    An Instance of the Fraction Class with Two Methods   Visual representation of a Fraction class instance called 'myfraction'. It features concentric circles with the innermost labeled 'State' showcasing 'num' with a value of 3 above 'den' with a value of 5, indicating the fraction's numerator and denominator. The outer circle is labeled 'Methods', suggesting the object's functionality. Two symbols, '<<' and '+', are shown outside the Methods circle, implying additional methods.    Our Fraction object now has two very useful methods and looks like . An additional group of methods that we need to include in our example Fraction class will allow two fractions to compare themselves to one another using == .  We want the == operator to compare Fraction objects and to return true if they are equivalent in value, false otherwise. This is a design choice because we want to be considered equal to as well as , etc. Hence, in the Fraction class, we can implement the == method by cross-multiplying (see ) rather than by just comparing numerators and denominators.  Of course there are other relational operators that can be overridden. For example, the <= operator could be overridden to provide the less than or equal functionality.   Overloading the comparison operator  C++ bool operator ==(const Fraction &otherFrac) { int firstnum = num*otherFrac.den; int secondnum = otherFrac.num*den; return firstnum==secondnum; }  Python def __eq__(self, other): firstnum = self.num * other.den secondnum = other.num * self.den return firstnum == secondnum   The complete Fraction class, up to this point, is shown in . We leave the remaining arithmetic and relational methods as exercises.   Complete Fraction class  C++ #include <iostream> using namespace std; int gcd(int m, int n) { while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } class Fraction { public: Fraction(int top, int bottom) { num = top; den = bottom; } Fraction(int top){ num = top; den = 1; } Fraction(){ num = 1; den = 1; } Fraction operator +(const Fraction &otherFrac) { int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; int common = gcd(newnum, newden); return Fraction(newnum\/common,newden\/common); } bool operator ==(const Fraction &otherFrac) { int firstnum = num*otherFrac.den; int secondnum = otherFrac.num*den; return firstnum==secondnum; } friend ostream& operator<<(ostream& stream, const Fraction& fraction); private: int num, den; }; ostream& operator << (ostream& stream, const Fraction& fraction) { stream << fraction.num << \"\/\" << fraction.den; return stream; } int main(){ Fraction x(1, 2); Fraction y(2, 4); cout << x << \" + \" << y << \" = \" << x+y << endl; if (x==y){ cout << \"x is equal y\" << endl; } else{ cout << \"x is not equal y\" << endl; } return 0; }  Python def gcd(m,n): while m%n != 0: oldm = m oldn = n m = oldn n = oldm%oldn return n class Fraction: def __init__(self,top,bottom): self.num = top self.den = bottom def __str__(self): return str(self.num)+\"\/\"+str(self.den) def show(self): print(self.num,\"\/\",self.den) def __add__(self,otherfraction): newnum = self.num*otherfraction.den + \\ self.den*otherfraction.num newden = self.den * otherfraction.den common = gcd(newnum,newden) return Fraction(newnum\/\/common,newden\/\/common) def __eq__(self, other): firstnum = self.num * other.den secondnum = other.num * self.den return firstnum == secondnum x = Fraction(1,2) y = Fraction(2,3) print(x + y) print(x == y)  >    Question example  #include<iostream> using namespace std; class Vehicle { protected: int wheels; int windows; int engine; }; class Airplane: public Vehicle { protected: \/\/ wheels \/\/ windows \/\/ engine int wings; };  To make sure you understand how operators are implemented in C++ classes, and how to properly write methods, write some methods to implement * , \/ , and - . Also implement comparison operators > and < .   #include <iostream> using namespace std; int gcd(int m, int n) { while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } class Fraction { public: Fraction(int top, int bottom) { num = top; den = bottom; } Fraction(int top){ num = top; den = 1; } Fraction(){ num = 1; den = 1; } Fraction operator +(const Fraction &otherFrac) { int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; int common = gcd(newnum, newden); return Fraction(newnum\/common,newden\/common); } bool operator ==(const Fraction &otherFrac) { int firstnum = num*otherFrac.den; int secondnum = otherFrac.num*den; return firstnum==secondnum; } friend ostream& operator<<(ostream& stream, const Fraction& fraction); private: int num, den; }; ostream& operator << (ostream& stream, const Fraction& fraction) { stream << fraction.num << \"\/\" << fraction.den; return stream; } int main(){ Fraction x(1, 2); Fraction y(2, 4); cout << x << \" + \" << y << \" = \" << x+y << endl; if (x==y){ cout << \"x is equal y\" << endl; } else{ cout << \"x is not equal y\" << endl; } return 0; }   Our the next section will introduce another important aspect of object-oriented programming, namely inheritance .   Reading Questions  Match the corresponding key word to the appropriate scenario. Review the definitions of the key words. Encapsulation A situation where bank software programmers want to protect users' personal information. Abstraction A situation where software programmers want to develop similar objects without having to redefine the most similar properties.  Click on the line where there is a syntax error when defining the following class C++ class definitions end with a certain symbol  class Fraction { :   public: :   Fraction(int top, int bottom) { :   \/** Fraction contructor method *\/ :   num = top; \/\/ setting num's value :   den = bottom; \/\/ setting den's value :   } :   private: :   int num; \/\/ num atribute :   int den; \/\/ den attribute :  } :    Which OOP principle is the above code an example of?     Inheritance    Correct! Airplane inherits many things from Vehicle      Encapsulation    Encapsulation is the principle of hiding the contents of a class except when absolutely necessary. Wings is not hidden from Vehicle, it simply does not exist in the Vehicle class.      Polymorphism    Polymorphism is the ability to process objects or methods differently depending on their data type, class, number of arguments, etc. A subclass using parts of a pre-existing class is not an example of polymorphism because they are used in the same way.      Abstraction    Abstraction is the principle of focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant. Take another look at what the two classes have in common.     Drag the word on the left to its corresponding definition Review the elements of object oriented programming Encapsulation hiding the contents of a class except when absolutely necessary Abstraction focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant Polymorphism processing objects or methods differently depending on their data type, class, number of arguments, etc.  Drag the word on the left to its corresponding definition Review classes and their properties instance an object of a class constructor an special function to initialize access keywords private and public class a template for creating objects       "
},
{
  "id": "introduction_object-oriented-programming-in-c-defining-classes-2-1",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_object-oriented-programming-in-c-defining-classes-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "object-oriented programming language "
},
{
  "id": "introduction_object-oriented-programming-in-c-defining-classes-2-2",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_object-oriented-programming-in-c-defining-classes-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "object instance "
},
{
  "id": "introduction_object-oriented-programming-in-c-defining-classes-2-3",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_object-oriented-programming-in-c-defining-classes-2-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "object attributes class methods class "
},
{
  "id": "introduction_a-fraction-class-8",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_a-fraction-class-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "constructor "
},
{
  "id": "introduction_lst-constructor",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_lst-constructor",
  "type": "Exploration",
  "number": "1.12.1",
  "title": "Constructor for <code class=\"code-inline tex2jax_ignore\">Fraction<\/code> class.",
  "body": " Constructor for Fraction class  C++ class Fraction { public: Fraction(int top, int bottom) { \/** Fraction constructor method *\/ num = top; \/\/ setting num's value den = bottom; \/\/ setting den's value } private: int num; \/\/ num attribute int den; \/\/ den attribute };  Python class Fraction: def __init__(self,top,bottom): self.num = top self.den = bottom "
},
{
  "id": "fig-fraction1cpp",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#fig-fraction1cpp",
  "type": "Figure",
  "number": "1.12.1",
  "title": "",
  "body": " An instance of the Fraction Class   Diagram showing an instance of the Fraction class. The instance is named 'myfraction' and is depicted as a set of concentric circles. The innermost circle is labeled 'State' and contains two segments: 'num' with the number 3 above 'den' with the number 5, representing the numerator and denominator of a fraction. The middle circle is labeled 'Methods', indicating the functionality associated with the fraction instance.   "
},
{
  "id": "introduction_abstraction-and-encapsulation-4",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_abstraction-and-encapsulation-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "abstraction "
},
{
  "id": "introduction_abstraction-and-encapsulation-5",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_abstraction-and-encapsulation-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "encapsulation access keywords "
},
{
  "id": "introduction_polymorphism-2",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Polymorphism polymorphism "
},
{
  "id": "introduction_polymorphism-11",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-11",
  "type": "Exploration",
  "number": "1.12.2",
  "title": "Implementing a <code class=\"code-inline tex2jax_ignore\">show<\/code> method.",
  "body": " Implementing a show method  C++ \/\/using functions to print fractions to the command line. #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1){ num = top; den = bottom; } void show(){ cout << num << \"\/\" << den << endl; } private: int num, den; }; int main() { Fraction fraca(3, 5); Fraction fracb(3); Fraction fracc; \/\/notice there are no parentheses here. \/\/ cout << fraca << endl; \/\/uncomment to see error fraca.show(); fracb.show(); fracc.show(); return 0; }  Python def show(self): print(self.num,\"\/\",self.den)  "
},
{
  "id": "introduction_polymorphism-12",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "overload "
},
{
  "id": "introduction_polymorphism-13",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "operator overloading "
},
{
  "id": "introduction_polymorphism-14",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "friend "
},
{
  "id": "introduction_polymorphism-15",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "friend function friend "
},
{
  "id": "introduction_polymorphism-16",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-16",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 4 "
},
{
  "id": "expl-lst-addmethod",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#expl-lst-addmethod",
  "type": "Exploration",
  "number": "1.12.3",
  "title": "Adding an addition method.",
  "body": " Adding an addition method  C++ Implementation Fraction operator +(const Fraction &otherFrac){ \/\/Note the return type is a Fraction int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; return Fraction(newnum, newden); }  Python Implementation def __add__(self, otherfraction): newnum = self.num*otherfraction.den + self.den*otherfraction.num newden = self.den * otherfraction.den return Fraction(newnum,newden)  C++ Usage Example \/\/using functions to abstract the idea of a fraction #include <iostream> using namespace std; class Fraction { public: Fraction(int top = 0, int bottom = 1) { num = top; den = bottom; } Fraction operator +(const Fraction &otherFrac) { int newnum = otherFrac.num*den + otherFrac.den*num; int newden = den*otherFrac.den; return Fraction(newnum, newden); } friend ostream &operator << (ostream &stream, const Fraction &frac); private: int num, den; }; ostream &operator << (ostream &stream, const Fraction &frac) { stream << frac.num << \"\/\" << frac.den; return stream; } int main(){ Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; cout << f3 << \" is \"<< f1 << \" + \" << f2 << endl; return 0; }  Python Usage Example f1=Fraction(1,4) f2=Fraction(1,2) f3=f1+f2 print(f3)  "
},
{
  "id": "introduction_polymorphism-30",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_polymorphism-30",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 6 "
},
{
  "id": "introduction_lst-newaddmethod",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_lst-newaddmethod",
  "type": "Listing",
  "number": "1.12.2",
  "title": "New addition implementation using <code class=\"code-inline tex2jax_ignore\">gcd<\/code>",
  "body": " New addition implementation using gcd  #include <iostream> using namespace std; int gcd(int m, int n){ \/** gcd is a helper function, used by but not part of the Fraction class *\/ while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } class Fraction { public: Fraction(int top, int bottom) { num = top; den = bottom; } Fraction(int top){ num = top; den = 1; } Fraction(){ num = 1; den = 1; } Fraction operator +(const Fraction &otherFrac) { int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; int common = gcd(newnum, newden); return Fraction(newnum\/common, newden\/common); } friend ostream& operator << (ostream& stream, const Fraction& fraction); private: int num, den; }; ostream & operator << (ostream& stream, const Fraction& fraction) { stream<<fraction.num<<\"\/\"<<fraction.den; return stream; } int main(){ Fraction f1(1, 4); Fraction f2(1, 2); Fraction f3 = f1 + f2; cout << f3 << \" is \"<< f1 << \" + \" << f2 << endl; return 0; }  "
},
{
  "id": "fig-fraction2cpp",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#fig-fraction2cpp",
  "type": "Figure",
  "number": "1.12.3",
  "title": "",
  "body": " An Instance of the Fraction Class with Two Methods   Visual representation of a Fraction class instance called 'myfraction'. It features concentric circles with the innermost labeled 'State' showcasing 'num' with a value of 3 above 'den' with a value of 5, indicating the fraction's numerator and denominator. The outer circle is labeled 'Methods', suggesting the object's functionality. Two symbols, '<<' and '+', are shown outside the Methods circle, implying additional methods.   "
},
{
  "id": "introduction_lst-cmpmethod",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_lst-cmpmethod",
  "type": "Exploration",
  "number": "1.12.4",
  "title": "Overloading the comparison operator.",
  "body": " Overloading the comparison operator  C++ bool operator ==(const Fraction &otherFrac) { int firstnum = num*otherFrac.den; int secondnum = otherFrac.num*den; return firstnum==secondnum; }  Python def __eq__(self, other): firstnum = self.num * other.den secondnum = other.num * self.den return firstnum == secondnum  "
},
{
  "id": "fraction_class",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#fraction_class",
  "type": "Exploration",
  "number": "1.12.5",
  "title": "Complete <code class=\"code-inline tex2jax_ignore\">Fraction<\/code> class.",
  "body": " Complete Fraction class  C++ #include <iostream> using namespace std; int gcd(int m, int n) { while (m%n != 0) { int oldm = m; int oldn = n; m = oldn; n = oldm%oldn; } return n; } class Fraction { public: Fraction(int top, int bottom) { num = top; den = bottom; } Fraction(int top){ num = top; den = 1; } Fraction(){ num = 1; den = 1; } Fraction operator +(const Fraction &otherFrac) { int newnum = num*otherFrac.den + den*otherFrac.num; int newden = den*otherFrac.den; int common = gcd(newnum, newden); return Fraction(newnum\/common,newden\/common); } bool operator ==(const Fraction &otherFrac) { int firstnum = num*otherFrac.den; int secondnum = otherFrac.num*den; return firstnum==secondnum; } friend ostream& operator<<(ostream& stream, const Fraction& fraction); private: int num, den; }; ostream& operator << (ostream& stream, const Fraction& fraction) { stream << fraction.num << \"\/\" << fraction.den; return stream; } int main(){ Fraction x(1, 2); Fraction y(2, 4); cout << x << \" + \" << y << \" = \" << x+y << endl; if (x==y){ cout << \"x is equal y\" << endl; } else{ cout << \"x is not equal y\" << endl; } return 0; }  Python def gcd(m,n): while m%n != 0: oldm = m oldn = n m = oldn n = oldm%oldn return n class Fraction: def __init__(self,top,bottom): self.num = top self.den = bottom def __str__(self): return str(self.num)+\"\/\"+str(self.den) def show(self): print(self.num,\"\/\",self.den) def __add__(self,otherfraction): newnum = self.num*otherfraction.den + \\ self.den*otherfraction.num newden = self.den * otherfraction.den common = gcd(newnum,newden) return Fraction(newnum\/\/common,newden\/\/common) def __eq__(self, other): firstnum = self.num * other.den secondnum = other.num * self.den return firstnum == secondnum x = Fraction(1,2) y = Fraction(2,3) print(x + y) print(x == y)  "
},
{
  "id": "introduction_self-check-1",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_self-check-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Question example "
},
{
  "id": "introduction_self-check-5",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#introduction_self-check-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "inheritance "
},
{
  "id": "aande",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#aande",
  "type": "Reading Question",
  "number": "1.12.4.1",
  "title": "",
  "body": "Match the corresponding key word to the appropriate scenario. Review the definitions of the key words. Encapsulation A situation where bank software programmers want to protect users' personal information. Abstraction A situation where software programmers want to develop similar objects without having to redefine the most similar properties. "
},
{
  "id": "class_syntax",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#class_syntax",
  "type": "Reading Question",
  "number": "1.12.4.2",
  "title": "",
  "body": "Click on the line where there is a syntax error when defining the following class C++ class definitions end with a certain symbol  class Fraction { :   public: :   Fraction(int top, int bottom) { :   \/** Fraction contructor method *\/ :   num = top; \/\/ setting num's value :   den = bottom; \/\/ setting den's value :   } :   private: :   int num; \/\/ num atribute :   int den; \/\/ den attribute :  } :  "
},
{
  "id": "OOPclassquestion",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#OOPclassquestion",
  "type": "Reading Question",
  "number": "1.12.4.3",
  "title": "",
  "body": " Which OOP principle is the above code an example of?     Inheritance    Correct! Airplane inherits many things from Vehicle      Encapsulation    Encapsulation is the principle of hiding the contents of a class except when absolutely necessary. Wings is not hidden from Vehicle, it simply does not exist in the Vehicle class.      Polymorphism    Polymorphism is the ability to process objects or methods differently depending on their data type, class, number of arguments, etc. A subclass using parts of a pre-existing class is not an example of polymorphism because they are used in the same way.      Abstraction    Abstraction is the principle of focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant. Take another look at what the two classes have in common.    "
},
{
  "id": "elements_of_OOP",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#elements_of_OOP",
  "type": "Reading Question",
  "number": "1.12.4.4",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition Review the elements of object oriented programming Encapsulation hiding the contents of a class except when absolutely necessary Abstraction focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant Polymorphism processing objects or methods differently depending on their data type, class, number of arguments, etc. "
},
{
  "id": "elements_of_classses",
  "level": "2",
  "url": "introduction_object-oriented-programming-in-c-defining-classes.html#elements_of_classses",
  "type": "Reading Question",
  "number": "1.12.4.5",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition Review classes and their properties instance an object of a class constructor an special function to initialize access keywords private and public class a template for creating objects "
},
{
  "id": "introduction_inheritance-in-c",
  "level": "1",
  "url": "introduction_inheritance-in-c.html",
  "type": "Section",
  "number": "1.13",
  "title": "Inheritance in C++",
  "body": " Inheritance in C++  In this section we introduce another important aspect of object-oriented programming. Inheritance is the ability for one class to be related to another class in much the same way that people can be related to one another. Children inherit characteristics from their parents. Similarly, C++ child classes can inherit characteristic data and\/or behaviors from a parent class. The child classes are often referred to as subclasses or derived classes , and the parent class is often called the base class or superclass .  shows the built-in C++ collections and their relationships to one another. We call a relationship structure such as this an inheritance hierarchy . For example, the string is a child of the sequential collection. In this case, we call the string the child and the sequence the parent (or subclass string and superclass sequence). This is often referred to as an IS-A Relationship (the string IS-A sequential collection). This implies that strings inherit important characteristics from sequences, namely the ordering of the underlying data and operations such as concatenation, repetition, and indexing.   An Inheritance Hierarchy for C++ Collections   Hierarchy chart showing the classification of C++ containers. The top of the hierarchy is labeled 'C++ Containers', branching into 'Sequence Containers' on the left and 'Associative Containers' on the right. Under 'Sequence Containers', there are three sub-categories: 'Arrays', 'Vectors', and 'Strings'. 'Associative Containers' has a single sub-category labeled 'Unordered Maps'. The layout suggests an inheritance structure where sequence and associative containers are types of C++ containers.    Vectors, arrays, and strings are all types of sequential collections. They all inherit common data organization and operations. However, each of them is distinct as well. The children all gain from their parents but distinguish themselves by adding additional characteristics.  By organizing classes in this hierarchical fashion, object-oriented programming languages allow previously written code to be extended to meet the needs of a new situation. In addition, by organizing data in this hierarchical manner, we can better understand the relationships that exist. We can be more efficient in building our abstract representations.  A child class inherits both behaviors and properties from the parent subject to some access restrictions. These variables and functions become members of the derived class. virtual function virtual method A virtual function (also known as a virtual method ) is a member function that is declared within a base class and is designed to be overridden by a derived class. For this in C++, the keyword virtual is used. A simple example of using a virtual function in C++ is shown in . In this example, the two derived subclasses inherit the printType method from the Base class.  #include <iostream> using namespace std; class Base { public: virtual void printType() { \/\/ Creates function called printType subfunction(); cout << \"I'm inherited!\" << endl << endl; } virtual void subfunction(){ \/\/ empty } }; class SubFirst : public Base { virtual void subfunction() { cout << \"I'm one type of sub-class!\" << endl; } }; class SubSecond : public Base { virtual void subfunction() { cout << \"I'm another type of sub class!\" << endl; } }; int main() { SubFirst first; \/\/ runs subfirst class using printType virtual function first.printType(); \/\/ calls Subfirst class, and runs virtual function on it's own SubSecond second; \/\/ runs subsecond class using printType virtual function second.printType(); \/\/ calls Subsecond class, and runs virtual function on it's own return 0; }    Logic Gates and Circuits  To explore this idea further, we will construct a simulation , an application to simulate digital circuits. The basic building block for this simulation will be the logic gate. These electronic switches represent Boolean algebra relationships between their input and their output. In general, gates have a single output line. The value of the output is dependent on the values given on the input lines.  AND gates have two input lines, each of which can be either 0 or 1, representing false or true , respectively. If both of the input lines have the value 1, the resulting output is 1. However, if either or both of the input lines is 0, the result is 0. OR gates also have two input lines and produce a 1 if one or both of the input values is a 1. In the case where both input lines are 0, the result is 0.  NOT gates differ from the other two gates in that they only have a single input line. The output value is simply the opposite of the input value. If 0 appears on the input, 1 is produced on the output. Similarly, 1 produces 0. shows how each of these gates is typically represented. Each gate also has a truth table of values showing the input-to-output mapping that is performed by the gate.   Three Types of Logic Gates   Image depicting three types of logic gates and their corresponding truth tables. On the left is the 'AND' gate symbol with a two-input truth table below it, showing outputs of '0' for all inputs except '1' and '1'. The center shows the 'OR' gate symbol with a truth table, displaying '1' when at least one input is '1'. On the right, the 'NOT' gate symbol is presented with a single-input truth table, showing an output inverse to the input.    By combining these gates in various patterns and then applying a set of input values, we can build circuits that have logical functions. shows a circuit consisting of two AND gates, one OR gate, and a NOT gate. The output lines from the two AND gates feed directly into the OR gate, and the resulting output from the OR gate is given to the NOT gate. If we apply a set of input values to the four input lines (two inputs for each AND gate), the values are processed and a result appears at the output of the NOT gate. also shows an example with values.   Circuit   Diagram of a logic circuit with labeled gates and sample inputs\/outputs. The top part shows two 'AND' gates labeled 'g1' and 'g2' feeding into an 'OR' gate labeled 'g3', which in turn feeds into a 'NOT' gate labeled 'g4'. Below, the same circuit is shown with binary inputs and the resulting outputs: 'AND' gates receiving '0, 1' and '1, 1' inputs with '0' and '1' outputs respectively; the 'OR' gate then combines the two to output '1', which is inverted to '0' by the 'NOT' gate.    In order to implement a circuit such as , we will first build a representation for logic gates. Logic gates are easily organized into a class inheritance hierarchy as shown in . At the top of the hierarchy, the LogicGate class represents the most general characteristics of logic gates: namely, a label for the gate and an output line. The next level of subclasses breaks the logic gates into two families, those that have one input line and those that have two. Below that, the specific logic functions of each appear.   Example Logic Circuit   Circuit diagram showing a two-input AND gate and a two-input OR gate. The output of these two gates are the inputs to another two-input AND gate     An Inheritance Hierarchy for Logic Gates   Flowchart representing an inheritance hierarchy for logic gates. The topmost block is labeled 'Logic Gate', which branches down into two categories: 'Binary Gate' and 'Unary Gate'. Under 'Binary Gate', two further blocks represent 'AND' and 'OR' gates, each accompanied by their respective symbols. To the right, under 'Unary Gate', there's a block for the 'NOT' gate with its symbol. The structure implies that 'AND' and 'OR' gates inherit from 'Binary Gate', which along with 'Unary Gate' inherits from 'Logic Gate'.    We can now start to implement the classes by starting with the most general, LogicGate . As noted earlier, each gate has a label for identification and a single output line. In addition, we need methods to allow a user of a gate to ask the gate for its label.  The other behavior that every logic gate needs is the ability to know its output value. This will require that the gate perform the appropriate logic based on the current input. In order to produce output, the gate needs to know specifically what that logic is. This means calling a method to perform the logic computation. The complete class is shown in .   Complete LogicGate class  C++ implementation class LogicGate { public: LogicGate(string n) { label = n; } string getLabel() { return label; } bool getOutput() { output = performGateLogic(); return output; } protected: string label; bool output; };  Python implementation class LogicGate: def __init__(self,n): self.label = n self.output = None def getLabel(self): return self.label def getOutput(self): self.output = self.performGateLogic() return self.output   A protected member variable or function is similar to a private member but it has the additional benefit that they can be accessed by derived classes. The access keyword protected is used for this.  At this point, we will not implement the performGateLogic function. The reason for this is that we do not know how each gate will perform its own logic operation. Those details will be included by each individual gate that is added to the hierarchy. This is a very powerful idea in object-oriented programming. We are writing a method that will use code that does not exist yet. The parameter virtual is a reference to the actual gate object invoking the method. Any new logic gate that gets added to the hierarchy will simply need to implement the performGateLogic function and it will be used at the appropriate time. Once done, the gate can provide its output value. This ability to extend a hierarchy that currently exists and provide the specific functions that the hierarchy needs to use the new class is extremely important for reusing existing code.  We categorized the logic gates based on the number of input lines. The AND gate has two input lines. The OR gate also has two input lines. NOT gates have one input line. The BinaryGate class will be a subclass of LogicGate and will add two input lines. The UnaryGate class will also subclass LogicGate but will have only a single input line. In computer circuit design, these lines are sometimes called pins so we will use that terminology in our implementation.   Implementation of BinaryGate  C++ implementation class BinaryGate : public LogicGate { public: BinaryGate(string n) : LogicGate(n) { \/\/ When we create an instance of \/\/ BinaryGate, data inherited from LogicGate are initialized with n; pinATaken = false; pinBTaken = false; } bool getPinA() { if (pinATaken==false) { cout << \"Enter Pin input for gate \" << getLabel() << \" : \"; cin >> pinA; pinATaken = true; } return pinA; } bool getPinB() { if (pinBTaken==false ) { cout << \"Enter Pin input for gate \" << getLabel() << \" : \"; cin >> pinB; pinBTaken = true; } return pinB; } protected: bool pinA; bool pinATaken; bool pinB; bool pinBTaken; };  Python implementation class BinaryGate(LogicGate): def __init__(self,n): LogicGate.__init__(self,n) self.pinA = None self.pinB = None def getPinA(self): return int(input(\"Enter Pin A input for gate \"+ self.getLabel()+\"->\")) def getPinB(self): return int(input(\"Enter Pin B input for gate \"+ self.getLabel()+\"->\"))    Implementation of UnaryGate  C++ implementation class UnaryGate : public LogicGate { public: UnaryGate(string n) : LogicGate(n) { pinTaken = false; } bool getPin() { if (pinTaken==false) { cout << \"Enter Pin input for gate \" << getLabel() << \": \"; cin >> pin; pinTaken = true; } return pin; } protected: bool pin; bool pinTaken; };  Python implementation class UnaryGate(LogicGate): def __init__(self,n): LogicGate.__init__(self,n) self.pin = None def getPin(self): return int(input(\"Enter Pin input for gate \"+ self.getLabel()+\"->\"))  and implement these two classes. The constructors in both of these classes start with an explicit call to the constructor of the parent class using the parent's name method. When creating an instance of the BinaryGate class, we first want to initialize any data items that are inherited from LogicGate . In this case, that means the label for the gate. The constructor then goes on to add the two input lines ( pinA and pinB ). This is a very common pattern that you should always use when building class hierarchies. Child class constructors need to call parent class constructors and then move on to their own distinguishing data.  The only behavior that the BinaryGate class adds is the ability to get the values from the two input lines. Since these values come from some external place, we will simply ask the user via an input statement to provide them. The same implementation occurs for the UnaryGate class except that there is only one input line.  Now that we have a general class for gates depending on the number of input lines, we can build specific gates that have unique behavior. For example, the AndGate class will be a subclass of BinaryGate since AND gates have two input lines. As before, the first line of the constructor calls upon the parent class constructor ( BinaryGate ), which in turn calls its parent class constructor ( LogicGate ). Note that the AndGate class does not provide any new data since it inherits two input lines, one output line, and a label.   Implementation of AndGate  C++ implementation class AndGate : public BinaryGate { public: AndGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic() { bool a = getPinA(); bool b = getPinB(); if (a == 1 && b == 1) { return true; } else { return false; } } };  Python implementation class AndGate(BinaryGate): def __init__(self,n): super(AndGate,self).__init__(n) def performGateLogic(self): a = self.getPinA() b = self.getPinB() if a==1 and b==1: return 1 else: return 0  The only thing AndGate needs to add is the specific behavior that performs the Boolean operation that was described earlier. This is the place where we can provide the performGateLogic method. For an AND gate, this method first must get the two input values and then only return 1 if both input values are 1. The complete class is shown in .  We can show the AndGate class in action by creating an instance and asking it to compute its output. The following session shows an AndGate object, gand1 , that has an internal label \"gand1\" . When we invoke the getOutput method, the object must first call its performGateLogic method which in turn queries the two input lines. Once the values are provided, the correct output is shown.  >>> AndGate gand2(\"gand2\") >>> gand2.getOutput() Enter Pin A input for gate gand2: 1 Enter Pin B input for gate gand2: 1 1 >>> gand2.getOutput() Enter Pin A input for gate gand2: 0 Enter Pin B input for gate gand2: 0 0 . The same development can be done for OR gates and NOT gates. The OrGate class will also be a subclass of BinaryGate and the NotGate class will extend the UnaryGate class. Both of these classes will need to provide their own performGateLogic functions, as this is their specific behavior.  We can use a single gate by first constructing an instance of one of the gate classes and then asking the gate for its output (which will in turn need inputs to be provided). For example:  >>> g2 = OrGate(\"G2\") >>> g2.getOutput() Enter Pin A input for gate G2->1 Enter Pin B input for gate G2->1 1 >>> g2.getOutput() Enter Pin A input for gate G2->0 Enter Pin B input for gate G2->0 0 >>> g3 = NotGate(\"G3\") >>> g3.getOutput() Enter Pin input for gate G3->0 1    Building Circuits  Now that we have the basic gates working, we can turn our attention to building circuits. In order to create a circuit, we need to connect gates together, the output of one flowing into the input of another. To do this, we will implement a new class called Connector .  The Connector class will not reside in the gate hierarchy. It will, however, use the gate hierarchy in that each connector will have two gates, one on either end (see ). This relationship is very important in object-oriented programming. It is called the HAS-A Relationship . Recall earlier that we used the phrase IS-A Relationship to say that a child class is related to a parent class, for example UnaryGate IS-A LogicGate .   A Connector Connects the Output of One Gate to the Input of Another   Diagram showing two logic gate symbols, 'AND' and 'OR', connected by a line labeled 'connector'. The 'AND' gate is on the left with an arrow pointing from its output to the 'connector'. Another arrow extends from the 'connector' to the input of the 'OR' gate on the right. This illustrates how the output of one gate serves as the input to another.    Now, with the Connector class, we say that a Connector HAS-A LogicGate meaning that connectors will have instances of the LogicGate class within them but are not part of the hierarchy. When designing classes, it is very important to distinguish between those that have the IS-A relationship (which requires inheritance) and those that have HAS-A relationships (with no inheritance).  shows the Connector class. The two gate instances within each connector object will be referred to as the fromgate and the togate , recognizing that data values will flow from the output of one gate into an input line of the next. The call to setNextPin is very important for making connections (see ). We need to add this method to our gate classes so that each togate can choose the proper input line for the connection.   Circit of NOT(AND(ganda,gnadb)OR AND(gandc,gandd))   Circuit diagram illustrating a logical expression with labeled components. Two 'AND' gates, labeled 'gand1' and 'gand2', are connected to an 'OR' gate labeled 'gor3' via lines labeled 'connector'. The output of 'gor3' is then fed into a 'NOT' gate labeled 'gnot4'. The connections suggest the logical operation NOT(AND(a,b)) OR AND(c,d).    #include <iostream> #include <string> using namespace std; \/\/ creates a class with a logic gate that returns the label, and boolean value class LogicGate { public: LogicGate(string n){ label = n; } string getLabel(){ return label; } bool getOutput(){ output = performGateLogic(); return output; } virtual bool performGateLogic(){ cout << \"ERROR! performGateLogic BASE\" << endl; return false; } virtual void setNextPin(bool source) { cout << \"ERROR! setNextPin BASE\" << endl; } private: string label; bool output; }; \/\/class that allows for the gates to have two inputs class BinaryGate : public LogicGate { public: BinaryGate(string n) : LogicGate(n) { pinATaken = false; pinBTaken = false; } bool getPinA() { if (pinATaken == false) { cout << \"Enter Pin A input for gate \" << getLabel() << \": \"; cin >> pinA; pinATaken = true; } return pinA; } bool getPinB() { if (pinBTaken == false) { cout << \"Enter Pin B input for gate \" << getLabel() << \": \"; cin >> pinB; pinBTaken = true; } return pinB; } virtual void setNextPin(bool source) { if (pinATaken == false) { pinA = source; this->pinATaken = true; } else if (pinBTaken == false) { pinB = source; this->pinBTaken = true; } } private: bool pinA, pinATaken, pinB, pinBTaken; }; \/\/allows for the creation of a logic gate with one input class UnaryGate : public LogicGate { public: UnaryGate(string n) : LogicGate(n) { pinTaken = false; } bool getPin() { if (pinTaken == false) { cout << \"Enter Pin input for gate \" << getLabel() << \": \"; cin >> pin; pinTaken = true; } return pin; } virtual void setNextPin(bool source) { if (pinTaken == false) { pin = source; pinTaken = true; } else { return; } } private: bool pin, pinTaken; }; \/\/Class that sets up the logic for an \"and\" gate class AndGate : public BinaryGate{ public: AndGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic(){ bool a = getPinA(); bool b = getPinB(); if (a == 1 && b == 1) { return true; } else { return false; } } }; \/\/class that sets up the logic for an \"or\" gate class OrGate : public BinaryGate { public: OrGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic() { bool a = getPinA(); bool b = getPinB(); if (a == 1 || b == 1) { return true; } else { return false; } } }; \/\/class that sets up the logic for a \"not\" gate class NotGate : public UnaryGate { public: NotGate(string n) : UnaryGate(n) {}; virtual bool performGateLogic() { if (getPin()) { return false; } else { return true; } } }; \/\/ class that sets up logic for the connection of one gate to another class Connector{ public: Connector(LogicGate *fgate, LogicGate *tgate) { fromgate = fgate; togate = tgate; tgate->setNextPin(fromgate->getOutput()); } LogicGate *getFrom() { return fromgate; } LogicGate *getTo() { return togate; } private: LogicGate *fromgate, *togate; }; int main() { char stopme; \/\/Setting labels AndGate gand1(\" AND1 \"); AndGate gand2(\" AND2 \"); OrGate gor3(\" OR \"); NotGate gnot4(\" NOT \"); \/\/ The inputs can be changed here! gand1.setNextPin(0); gand1.setNextPin(0); gand2.setNextPin(0); gand2.setNextPin(0); \/\/making comnnections Connector c1(&gand1, &gor3); Connector c2(&gand2, &gor3); Connector c3(&gor3, &gnot4); \/\/ The output shows order of operators cout << gnot4.getLabel() << \"(\"; cout << \"(\" << gand1.getPinA() << gand1.getLabel() << gand1.getPinB() << \")\"; cout << gor3.getLabel(); cout << \"(\" << gand2.getPinA() << gand2.getLabel() << gand2.getPinB() << \")\"; cout << \") results in \" << gnot4.getOutput() << endl; cin >> stopme; \/\/holds open window under some conditions. return 0; }   Reading Questions   What will the logic gate yield (1 \/ 0)?  Correct! Take a closer look at the logic gates.   What is the difference between HAS-A and IS-A relationships? Select all that apply.     An IS-A class object is an instance of an inherited class.    Correct!      A HAS-A class object has all of the methods of another class.    No. HAS-A relationships do not mean that one class is copying another class.      An IS-A class object contains instances of another class.    No. IS-A relationships do not mean that an object contains different class instances.      A HAS-A class object is an instance of an inherited class.    No, HAS-A reltionships do not use inheritance.      A HAS-A class object contains instances of another class.    Correct!      Self Check Challenge  One of the fundamental building blocks of a computer is something called a flip flop. It's not something that computer science professors wear on their feet, but rather a kind of circuit that is stable and stores the last piece of data that was put on it. A simple flip-flop can be made from two NOR gates (a combination OR and NOT ) that are tied together as in the following diagram. Create a new gate class, called NorGate. NorGates work like OrGates that have a Not attached to the output. See if you can use your new class to implement this.   Note if the initial inputs to Reset and Set are both 0 then the output of the flip-flop is 0. But if the Set input is toggled to 1 then the output becomes 1. The great thing is that when the set input goes to 0 the output stays 1, until the reset input is toggled to 1 which resets the output of the circuit back to zero.        "
},
{
  "id": "introduction_inheritance-in-c-2-1",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_inheritance-in-c-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Inheritance subclasses derived classes base class superclass "
},
{
  "id": "introduction_inheritance-in-c-2-2",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_inheritance-in-c-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "inheritance hierarchy IS-A "
},
{
  "id": "fig-inherit1",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#fig-inherit1",
  "type": "Figure",
  "number": "1.13.1",
  "title": "",
  "body": " An Inheritance Hierarchy for C++ Collections   Hierarchy chart showing the classification of C++ containers. The top of the hierarchy is labeled 'C++ Containers', branching into 'Sequence Containers' on the left and 'Associative Containers' on the right. Under 'Sequence Containers', there are three sub-categories: 'Arrays', 'Vectors', and 'Strings'. 'Associative Containers' has a single sub-category labeled 'Unordered Maps'. The layout suggests an inheritance structure where sequence and associative containers are types of C++ containers.   "
},
{
  "id": "introduction_inheritance-in-c-2-6",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_inheritance-in-c-2-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "virtual function virtual method "
},
{
  "id": "virtualfunction",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#virtualfunction",
  "type": "Listing",
  "number": "1.13.2",
  "title": "",
  "body": "#include <iostream> using namespace std; class Base { public: virtual void printType() { \/\/ Creates function called printType subfunction(); cout << \"I'm inherited!\" << endl << endl; } virtual void subfunction(){ \/\/ empty } }; class SubFirst : public Base { virtual void subfunction() { cout << \"I'm one type of sub-class!\" << endl; } }; class SubSecond : public Base { virtual void subfunction() { cout << \"I'm another type of sub class!\" << endl; } }; int main() { SubFirst first; \/\/ runs subfirst class using printType virtual function first.printType(); \/\/ calls Subfirst class, and runs virtual function on it's own SubSecond second; \/\/ runs subsecond class using printType virtual function second.printType(); \/\/ calls Subsecond class, and runs virtual function on it's own return 0; } "
},
{
  "id": "introduction_logic-gates-and-circuits-2",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "simulation "
},
{
  "id": "introduction_logic-gates-and-circuits-3",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "AND OR "
},
{
  "id": "introduction_logic-gates-and-circuits-4",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "NOT truth table "
},
{
  "id": "ooderive_fig-truthtable",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-truthtable",
  "type": "Figure",
  "number": "1.13.3",
  "title": "",
  "body": " Three Types of Logic Gates   Image depicting three types of logic gates and their corresponding truth tables. On the left is the 'AND' gate symbol with a two-input truth table below it, showing outputs of '0' for all inputs except '1' and '1'. The center shows the 'OR' gate symbol with a truth table, displaying '1' when at least one input is '1'. On the right, the 'NOT' gate symbol is presented with a single-input truth table, showing an output inverse to the input.   "
},
{
  "id": "introduction_logic-gates-and-circuits-6",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "AND OR NOT AND OR OR NOT AND NOT "
},
{
  "id": "ooderive_fig-circuit1",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-circuit1",
  "type": "Figure",
  "number": "1.13.4",
  "title": "",
  "body": " Circuit   Diagram of a logic circuit with labeled gates and sample inputs\/outputs. The top part shows two 'AND' gates labeled 'g1' and 'g2' feeding into an 'OR' gate labeled 'g3', which in turn feeds into a 'NOT' gate labeled 'g4'. Below, the same circuit is shown with binary inputs and the resulting outputs: 'AND' gates receiving '0, 1' and '1, 1' inputs with '0' and '1' outputs respectively; the 'OR' gate then combines the two to output '1', which is inverted to '0' by the 'NOT' gate.   "
},
{
  "id": "ooderive_fig-circuit0",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-circuit0",
  "type": "Figure",
  "number": "1.13.5",
  "title": "",
  "body": " Example Logic Circuit   Circuit diagram showing a two-input AND gate and a two-input OR gate. The output of these two gates are the inputs to another two-input AND gate   "
},
{
  "id": "ooderive_fig-gates",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-gates",
  "type": "Figure",
  "number": "1.13.6",
  "title": "",
  "body": " An Inheritance Hierarchy for Logic Gates   Flowchart representing an inheritance hierarchy for logic gates. The topmost block is labeled 'Logic Gate', which branches down into two categories: 'Binary Gate' and 'Unary Gate'. Under 'Binary Gate', two further blocks represent 'AND' and 'OR' gates, each accompanied by their respective symbols. To the right, under 'Unary Gate', there's a block for the 'NOT' gate with its symbol. The structure implies that 'AND' and 'OR' gates inherit from 'Binary Gate', which along with 'Unary Gate' inherits from 'Logic Gate'.   "
},
{
  "id": "introduction_expl-logicgateclass",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_expl-logicgateclass",
  "type": "Exploration",
  "number": "1.13.1",
  "title": "Complete <code class=\"code-inline tex2jax_ignore\">LogicGate<\/code> class.",
  "body": " Complete LogicGate class  C++ implementation class LogicGate { public: LogicGate(string n) { label = n; } string getLabel() { return label; } bool getOutput() { output = performGateLogic(); return output; } protected: string label; bool output; };  Python implementation class LogicGate: def __init__(self,n): self.label = n self.output = None def getLabel(self): return self.label def getOutput(self): self.output = self.performGateLogic() return self.output  "
},
{
  "id": "introduction_expl-binarygateclass",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_expl-binarygateclass",
  "type": "Exploration",
  "number": "1.13.2",
  "title": "Implementation of <code class=\"code-inline tex2jax_ignore\">BinaryGate<\/code>.",
  "body": " Implementation of BinaryGate  C++ implementation class BinaryGate : public LogicGate { public: BinaryGate(string n) : LogicGate(n) { \/\/ When we create an instance of \/\/ BinaryGate, data inherited from LogicGate are initialized with n; pinATaken = false; pinBTaken = false; } bool getPinA() { if (pinATaken==false) { cout << \"Enter Pin input for gate \" << getLabel() << \" : \"; cin >> pinA; pinATaken = true; } return pinA; } bool getPinB() { if (pinBTaken==false ) { cout << \"Enter Pin input for gate \" << getLabel() << \" : \"; cin >> pinB; pinBTaken = true; } return pinB; } protected: bool pinA; bool pinATaken; bool pinB; bool pinBTaken; };  Python implementation class BinaryGate(LogicGate): def __init__(self,n): LogicGate.__init__(self,n) self.pinA = None self.pinB = None def getPinA(self): return int(input(\"Enter Pin A input for gate \"+ self.getLabel()+\"->\")) def getPinB(self): return int(input(\"Enter Pin B input for gate \"+ self.getLabel()+\"->\"))  "
},
{
  "id": "introduction_expl-unarygateclass",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_expl-unarygateclass",
  "type": "Exploration",
  "number": "1.13.3",
  "title": "Implementation of <code class=\"code-inline tex2jax_ignore\">UnaryGate<\/code>.",
  "body": " Implementation of UnaryGate  C++ implementation class UnaryGate : public LogicGate { public: UnaryGate(string n) : LogicGate(n) { pinTaken = false; } bool getPin() { if (pinTaken==false) { cout << \"Enter Pin input for gate \" << getLabel() << \": \"; cin >> pin; pinTaken = true; } return pin; } protected: bool pin; bool pinTaken; };  Python implementation class UnaryGate(LogicGate): def __init__(self,n): LogicGate.__init__(self,n) self.pin = None def getPin(self): return int(input(\"Enter Pin input for gate \"+ self.getLabel()+\"->\")) "
},
{
  "id": "introduction_expl-andgateclass",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_expl-andgateclass",
  "type": "Exploration",
  "number": "1.13.4",
  "title": "Implementation of <code class=\"code-inline tex2jax_ignore\">AndGate<\/code>.",
  "body": " Implementation of AndGate  C++ implementation class AndGate : public BinaryGate { public: AndGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic() { bool a = getPinA(); bool b = getPinB(); if (a == 1 && b == 1) { return true; } else { return false; } } };  Python implementation class AndGate(BinaryGate): def __init__(self,n): super(AndGate,self).__init__(n) def performGateLogic(self): a = self.getPinA() b = self.getPinB() if a==1 and b==1: return 1 else: return 0 "
},
{
  "id": "introduction_logic-gates-and-circuits-23",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-23",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "AND "
},
{
  "id": "introduction_fig-andusage",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_fig-andusage",
  "type": "Listing",
  "number": "1.13.7",
  "title": "",
  "body": ">>> AndGate gand2(\"gand2\") >>> gand2.getOutput() Enter Pin A input for gate gand2: 1 Enter Pin B input for gate gand2: 1 1 >>> gand2.getOutput() Enter Pin A input for gate gand2: 0 Enter Pin B input for gate gand2: 0 0 "
},
{
  "id": "introduction_logic-gates-and-circuits-26",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_logic-gates-and-circuits-26",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "OR NOT "
},
{
  "id": "introduction_fig-ornotusage",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_fig-ornotusage",
  "type": "Listing",
  "number": "1.13.8",
  "title": "",
  "body": ">>> g2 = OrGate(\"G2\") >>> g2.getOutput() Enter Pin A input for gate G2->1 Enter Pin B input for gate G2->1 1 >>> g2.getOutput() Enter Pin A input for gate G2->0 Enter Pin B input for gate G2->0 0 >>> g3 = NotGate(\"G3\") >>> g3.getOutput() Enter Pin input for gate G3->0 1 "
},
{
  "id": "introduction_building-circuits-3",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#introduction_building-circuits-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "HAS-A Relationship "
},
{
  "id": "ooderive_fig-connector",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-connector",
  "type": "Figure",
  "number": "1.13.9",
  "title": "",
  "body": " A Connector Connects the Output of One Gate to the Input of Another   Diagram showing two logic gate symbols, 'AND' and 'OR', connected by a line labeled 'connector'. The 'AND' gate is on the left with an arrow pointing from its output to the 'connector'. Another arrow extends from the 'connector' to the input of the 'OR' gate on the right. This illustrates how the output of one gate serves as the input to another.   "
},
{
  "id": "ooderive_fig-desired-circuit",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_fig-desired-circuit",
  "type": "Figure",
  "number": "1.13.10",
  "title": "",
  "body": " Circit of NOT(AND(ganda,gnadb)OR AND(gandc,gandd))   Circuit diagram illustrating a logical expression with labeled components. Two 'AND' gates, labeled 'gand1' and 'gand2', are connected to an 'OR' gate labeled 'gor3' via lines labeled 'connector'. The output of 'gor3' is then fed into a 'NOT' gate labeled 'gnot4'. The connections suggest the logical operation NOT(AND(a,b)) OR AND(c,d).   "
},
{
  "id": "ooderive_program",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#ooderive_program",
  "type": "Listing",
  "number": "1.13.11",
  "title": "",
  "body": "#include <iostream> #include <string> using namespace std; \/\/ creates a class with a logic gate that returns the label, and boolean value class LogicGate { public: LogicGate(string n){ label = n; } string getLabel(){ return label; } bool getOutput(){ output = performGateLogic(); return output; } virtual bool performGateLogic(){ cout << \"ERROR! performGateLogic BASE\" << endl; return false; } virtual void setNextPin(bool source) { cout << \"ERROR! setNextPin BASE\" << endl; } private: string label; bool output; }; \/\/class that allows for the gates to have two inputs class BinaryGate : public LogicGate { public: BinaryGate(string n) : LogicGate(n) { pinATaken = false; pinBTaken = false; } bool getPinA() { if (pinATaken == false) { cout << \"Enter Pin A input for gate \" << getLabel() << \": \"; cin >> pinA; pinATaken = true; } return pinA; } bool getPinB() { if (pinBTaken == false) { cout << \"Enter Pin B input for gate \" << getLabel() << \": \"; cin >> pinB; pinBTaken = true; } return pinB; } virtual void setNextPin(bool source) { if (pinATaken == false) { pinA = source; this->pinATaken = true; } else if (pinBTaken == false) { pinB = source; this->pinBTaken = true; } } private: bool pinA, pinATaken, pinB, pinBTaken; }; \/\/allows for the creation of a logic gate with one input class UnaryGate : public LogicGate { public: UnaryGate(string n) : LogicGate(n) { pinTaken = false; } bool getPin() { if (pinTaken == false) { cout << \"Enter Pin input for gate \" << getLabel() << \": \"; cin >> pin; pinTaken = true; } return pin; } virtual void setNextPin(bool source) { if (pinTaken == false) { pin = source; pinTaken = true; } else { return; } } private: bool pin, pinTaken; }; \/\/Class that sets up the logic for an \"and\" gate class AndGate : public BinaryGate{ public: AndGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic(){ bool a = getPinA(); bool b = getPinB(); if (a == 1 && b == 1) { return true; } else { return false; } } }; \/\/class that sets up the logic for an \"or\" gate class OrGate : public BinaryGate { public: OrGate(string n) : BinaryGate(n) {}; virtual bool performGateLogic() { bool a = getPinA(); bool b = getPinB(); if (a == 1 || b == 1) { return true; } else { return false; } } }; \/\/class that sets up the logic for a \"not\" gate class NotGate : public UnaryGate { public: NotGate(string n) : UnaryGate(n) {}; virtual bool performGateLogic() { if (getPin()) { return false; } else { return true; } } }; \/\/ class that sets up logic for the connection of one gate to another class Connector{ public: Connector(LogicGate *fgate, LogicGate *tgate) { fromgate = fgate; togate = tgate; tgate->setNextPin(fromgate->getOutput()); } LogicGate *getFrom() { return fromgate; } LogicGate *getTo() { return togate; } private: LogicGate *fromgate, *togate; }; int main() { char stopme; \/\/Setting labels AndGate gand1(\" AND1 \"); AndGate gand2(\" AND2 \"); OrGate gor3(\" OR \"); NotGate gnot4(\" NOT \"); \/\/ The inputs can be changed here! gand1.setNextPin(0); gand1.setNextPin(0); gand2.setNextPin(0); gand2.setNextPin(0); \/\/making comnnections Connector c1(&gand1, &gor3); Connector c2(&gand2, &gor3); Connector c3(&gor3, &gnot4); \/\/ The output shows order of operators cout << gnot4.getLabel() << \"(\"; cout << \"(\" << gand1.getPinA() << gand1.getLabel() << gand1.getPinB() << \")\"; cout << gor3.getLabel(); cout << \"(\" << gand2.getPinA() << gand2.getLabel() << gand2.getPinB() << \")\"; cout << \") results in \" << gnot4.getOutput() << endl; cin >> stopme; \/\/holds open window under some conditions. return 0; } "
},
{
  "id": "logic-gate-1",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#logic-gate-1",
  "type": "Reading Question",
  "number": "1.13.2.1",
  "title": "",
  "body": " What will the logic gate yield (1 \/ 0)?  Correct! Take a closer look at the logic gates. "
},
{
  "id": "mc_IS-A_HAS-A",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#mc_IS-A_HAS-A",
  "type": "Reading Question",
  "number": "1.13.2.2",
  "title": "",
  "body": " What is the difference between HAS-A and IS-A relationships? Select all that apply.     An IS-A class object is an instance of an inherited class.    Correct!      A HAS-A class object has all of the methods of another class.    No. HAS-A relationships do not mean that one class is copying another class.      An IS-A class object contains instances of another class.    No. IS-A relationships do not mean that an object contains different class instances.      A HAS-A class object is an instance of an inherited class.    No, HAS-A reltionships do not use inheritance.      A HAS-A class object contains instances of another class.    Correct!    "
},
{
  "id": "rq-oop-derived-classes-4",
  "level": "2",
  "url": "introduction_inheritance-in-c.html#rq-oop-derived-classes-4",
  "type": "Note",
  "number": "1.13.12",
  "title": "Self  Check Challenge.",
  "body": " Self Check Challenge  One of the fundamental building blocks of a computer is something called a flip flop. It's not something that computer science professors wear on their feet, but rather a kind of circuit that is stable and stores the last piece of data that was put on it. A simple flip-flop can be made from two NOR gates (a combination OR and NOT ) that are tied together as in the following diagram. Create a new gate class, called NorGate. NorGates work like OrGates that have a Not attached to the output. See if you can use your new class to implement this.   Note if the initial inputs to Reset and Set are both 0 then the output of the flip-flop is 0. But if the Set input is toggled to 1 then the output becomes 1. The great thing is that when the set input goes to 0 the output stays 1, until the reset input is toggled to 1 which resets the output of the circuit back to zero.  "
},
{
  "id": "introduction_optional-graphics-in-c",
  "level": "1",
  "url": "introduction_optional-graphics-in-c.html",
  "type": "Section",
  "number": "1.14",
  "title": "<dfn class=\"terminology\">Optional<\/dfn>: Graphics in C++",
  "body": " Optional : Graphics in C++   C++ is designed with the principal that speed is more important than safety and error-checking. This differs from the majority of other programming languages, which tend to be considerably more restrictive in regards to aspects such as memory allocations and resource management. C++ is translated to machine language when it is compiled, which is a step skipped by other languages.  This difference is what allows C++ to be as fast as it is, which also makes it particularly good for graphically-intensive applications. Graphical applications heavily leverage memory management to display every pixel you see on your screen. Many languages do not allow for the creation of arrays like in C++, which are just chunks of memory of a fixed size. Furthermore, running directly on the hardware allows C++ to communicate better with other components of your computer, such as your graphics processing unit, or GPU . This is one of many reasons C++ is considered an industry standard for high-performance graphics applications, such as video games or software used for visual effects in movies.  Turtle graphics are a popular and simple way for introducing programming to beginners. It was part of the original Logo programming language developed by Wally Feurzeig, Seymour Papert and Cynthia Solomon in 1967.  Imagine Turtles as being a digital marker used for drawing various shapes, images, and designs. Drawing with Turtles can be as basic as a simple triangle and as complex as a highly detailed fractal image. Nearly all commands used when drawing with Turtles are as simple as telling your Turtle to move forward, backward, left, and right in as few or many steps as desired.    Introduction to Turtles  Visual representations afford students an opportunity to observe a facet of computer science from an alternative point of view: rather than waiting anxiously for the print statement to come around after your program churns, you get a visual representation of the concept itself. This is particularly useful for abstract concepts such as recursion and iteration.  For C++, a library titled C-Turtle is used to provide an equivalent of Python's Turtles. It acts as a close replacement to provide easy to use graphics to C++, while maintaining the objects and commands present in Python. It was developed by Jesse Walker-Schadler at Berea College during the summer of 2019 and can be found on GitHub here: https:\/\/github.com\/walkerje\/C-Turtle\/  Below is a comparison of two versions, C++ and Python, which should do the same thing. Try running both and comparing how the code looks between the two versions.    #include <CTurtle.hpp> namespace ct = cturtle; int main() { ct::TurtleScreen scr; ct::Turtle turtle(scr); turtle.speed(ct::TS_SLOWEST); turtle.fillcolor({\"purple\"}); turtle.begin_fill(); for (int i = 0; i < 4; i++) { turtle.forward(50); turtle.right(90); } turtle.end_fill(); scr.bye(); return 0; }     import turtle turt = turtle.Turtle() turt.fillcolor(\"purple\") turt.speed(\"slowest\") turt.begin_fill() for i in range(4): turt.forward(50) turt.right(90) turt.end_fill() turt.bye()      Turtle & TurtleScreen  Turtles must exist on a TurtleScreen to be used. The TurtleScreen object must be created before you can create a Turtle object for this reason.  ct::TurtleScreen screen; ct::Turtle turtle(screen); \/\/Notice how the Screen is given to our Turtle when we create it.  Closing a TurtleScreen when you're done with it is fairly simple to do. For this chapter, only the method bye is used. Calling it is not completely necessary, as it is also called automatically if it, or an equivalent method, hasn't been called. When working outside of the textbook, the exitonclick method is also available.  screen.bye();  Turtles are based on the following premise: There is a turtle on a canvas with a colored pen attached to their tail. In this case, the canvas is a TurtleScreen . This Turtle will follow any command you give it, which consist of telling it to go certain directions, what color of pen to use, when to raise or lower its pen, and others. Below is an outline of commonly used methods when working with turtles.    Method Name  Description    turtle.left  turns the turtle a certain number of units to the left.    turtle.right  turns the turtle a certain number of units to the right.    turtle.penup  raises the paint pen on the end of the turtle's tail.    turtle.pendown  lowers the paint pen on the end of the turtle's tail.    turtle.fillcolor  tells the turtle what color the inside of the shape will be.    turtle.beginfill  tells the turtle to begin filling a shape as it moves.    turtle.endfill  tells the turtle to finish filling the shape it has created as it moved.    turtle.pencolor  tells the turtle what color it will draw with.    turtle.width  tells the turtle how large of a paint pen to use.    turtle.speed  tells the turtle how fast it should go, faster or slower than the hare.    turtle.back  moves the turtle back a number of units.    turtle.forward  moves the turtle forward a number of units.    turtle.goto  tells the turtle to move to a specific coordinate.    turtle.write  tells the turtle to write some kind of text.    Many of these methods are used alongside one-another to create different images. All speeds are measured on a range of 1 to 10, the latter being the fastest and the former being the slowest. The exception is the fastest speed, TS_FASTEST , which is set to 0. The TS prefix represents Turtle Speed .    CTurtle Name  Speed    TS_FASTEST  0    TS_FAST  10    TS_NORMAL  6    TS_SLOW  3    TS_SLOWEST  1    Consider the following annotated example.   #include <CTurtle.hpp> namespace ct = cturtle; int main() { \/\/Create a turtle screen, and add our turtle to it. ct::TurtleScreen screen; ct::Turtle turtle(screen); \/\/Set the turtle speed to the slowest available option. turtle.speed(ct::TS_SLOWEST); \/\/Any number from 0 to 10 would work as well. \/\/turtle.speed(7); \/\/Sets the turtle's fill color to purple. turtle.fillcolor({\"purple\"}); \/\/Tells the turtle to begin filling a shape as it moves. turtle.begin_fill(); \/\/Tells the turtle to make a square. \/\/Iterates once for every corner of the square. for (int i = 0; i < 4; i++) { \/\/Tells the turtle to move forward 50 units. turtle.forward(50); \/\/Tells the turtle to turn 90 degrees to the right. turtle.right(90); } \/\/Tells the turtle to finish filling the shape it has outlined. turtle.end_fill(); \/\/Closes the turtle screen. screen.bye(); return 0; }   The order of operations given to a turtle is important, as some actions must be completed one after another. A good example of this is the begin_fill and end_fill pattern, which must be called in that specified order to actually fill a shape.    Geometry, Shapes, and Stamps  Every basic shape in CTurtle is a set of coordinates. Within the CTurtle library we have the choice of a select few shapes that we can me our Turtles inhabit. To change the appearance of your Turtle, you can use shape to set your Turtle to one of four default shapes, or a custom shape. CTurtle features four default shapes, triangle , indented_triangle , square , and arrow .  The following code example shows how to set the shape of a turtle by giving it the name of a shape.  turtle.shape(\"square\");  Given that all primitive shapes are defined as a collection of points, all of the default shapes are also defined this way. Polygons, for custom and default shapes, must have their points defined in counter-clockwise order to appear correctly. This is due to the mathematics behind filling arbitrary shapes, and is a limitation almost all computer graphics need to abide by. Consider the order of their points in the following table, and how they could be considered counter-clockwise . They are in order from top to bottom, and one edge exists between the first last points for each of these shapes. Please note that positive Y coordinates are lower on the screen, while negative Y coordinates are higher on the screen. Coordinates at the origin– that is, coordinate 0x, 0y– is at the point or tip of the turtle. This is why most of the default shapes have their first coordinate there.    triangle  indented_triangle  square  arrow    (0, 0)  (0, 0)  (-5, -5)  (0, 0)    (-5, 5)  (-5, 10)  (-5, 5)  (-5, 5)    (5, 5)  (0, 8)  (5, 5)  (-3, 5)    .  (5, 10)  (5, 10)  (-3, 10)    .  .  .  (3, 10)    .  .  .  (3, 5)    .  .  .  (5, 5)    Using the default indented_triangle shape as an example, Figure 1 shows the nature of the counter-clockwise order.   Indented Triangle Definition   Graphic illustrating an indented triangle with coordinate points. At the top vertex, the point is labeled '0, 0'. The bottom left vertex is labeled '-5, 10', and the bottom right vertex is labeled '5, 10'. An arrow curves above the triangle, indicating rotation or flipping. Each vertex is marked with a green circle. The image defines the shape and position of an indented triangle in a coordinate system    The example code below illustrates how to create your own shape. We use the Polygon class to represent our shape. For this example, we take the triangle default shape and make every Y coordinate negative to make it appear upside-down.  ct::Polygon upside_down_triangle = { {0, 0}, \/\/First point {-5, -5}, \/\/Second point {5, -5} \/\/and so on. };  The following code is a full example for setting your turtle to a custom shape. Feel free to mess around with the coordinates of the polygon, you might surprise yourself with what shape you end up with!   #include <CTurtle.hpp> namespace ct = cturtle; int main(){ ct::TurtleScreen screen; ct::Turtle turtle(screen); ct::Polygon upside_down_triangle = { {0, 0}, \/\/First point {-5, -5}, \/\/Second point {5, -5} \/\/and so on. }; turtle.shape(upside_down_triangle); turtle.forward(50); screen.bye(); return 0; }   Stamps provide a way to make several copies of the shape of the turtle across the screen without having to trace each shape individually with the turtle. This can be used for a variety of visual effects, however it is often used as a time-saving utility. Stamps can be placed with the stamp method of Turtle objects, which returns an integer that acts as the ID of the stamp that has been placed. The clearstamp method of the Turtle object can be used to delete a single stamp from the screen, while the clearstamps method is used to delete multiple stamps at once.  The following code is a full example showing how to combine custom shapes with stamp placement.   #include <CTurtle.hpp> namespace ct = cturtle; int main(){ ct::TurtleScreen screen; ct::Turtle turtle(screen); ct::Polygon upside_down_triangle = { {0, 0}, \/\/First point {-5, -5}, \/\/Second point {5, -5} \/\/and so on. }; turtle.shape(upside_down_triangle); \/\/Draw a square where each edge is 50 units long. for(int i = 0; i < 4; i++){ \/\/Stamp at the corner of the square. int corner_stamp = turtle.stamp(); turtle.forward(25); turtle.stamp(); \/\/Stamp half-way across the edge of the square. turtle.forward(25); turtle.right(90); \/\/Clear the corner stamp. turtle.clearstamp(corner_stamp); } turtle.clearstamps(); screen.bye(); return 0; }     Advanced Features  Turtles are a large tool, and thus have a lot of options dictating how they function. Some features and functionality are more complicated than others, relating to the inner workings of turtles themselves. A few of these include the tracer and undo methods, and also screen modes.  Screen modes dictate the direction of angle measurements. This means that, depending on which mode a TurtleScreen object is in, positive angles could represent clockwise rotations or counterclockwise rotations. The mode method for TurtleScreen allows you to set which mode a screen is in.    Mode  Default Rotation  Positive Angles    SM_STANDARD  East  Counterclockwise    SM_LOGO  North  Clockwise    Regarding angles, Turtles can use both degrees and radians for their rotations. You can choose between the two using the radians and degrees methods for the Turtle object. By default, all angles are measured in degrees . This option only effects methods regarding rotation, such as left and right .  turtle.degrees(); turtle.right(90);\/\/90-degree turn to the right turtle.radians(); turtle.left(1.5708f);\/\/Equivalent rotation in radians to the left.  The tracer(N) method is used to control how many times the Turtle is actually drawn on the screen. This method belongs to the TurtleScreen object, and effects all turtles that are on the screen. The N in the method represents the input, only allowing the TurtleScreen to display one frame out every N .  screen.tracer(12); \/\/Show one out of every 12 frames of animation.  This can be combined with the speed method available to turtles to achieve very quickly drawn images. The maximum speed a Turtle can have, TS_FASTEST , completely disables animation for Turtles between movements and rotations. This allows the tracer setting to directly relate to the total number of actions the turtle makes. The actions the turtle takes happen regardless of whether or not they are actually shown on the screen.  screen.tracer(3); \/\/Show one out of every 3 frames of animation. turtle.speed(ct::TS_FASTEST); \/\/Disables Turtle animation turtle.forward(50);\/\/This is not shown on-screen... turtle.right(90);\/\/Neither is this... turtle.forward(50);\/\/But this action is, because it is third out of three.  A frame of animation is added for almost every action a turtle takes, regardless of whether or not the turtle is moving or adding something to the screen. This includes methods like begin_fill and end_fill , which don't do anything visually but do tell the turtle to start or stop tracking its own movements.  Consider the following example and related questions.  #include <CTurtle.hpp> namespace ct = cturtle; int main(){ ct::TurtleScreen screen; ct::Turtle turtle(screen); turtle.speed(ct::TS_FASTEST); screen.tracer(6); for(int i = 0; i < 3; i++){ turtle.right(60); turtle.forward(50); } screen.bye(); return 0; }  Similarly to tracer settings, every action a turtle takes is also added to the undo queue . This allows it to keep track of actions it is performing over a period of time. The queue is only allowed to grow to a certain size, starting at 100 actions total. This is modifiable through the setundobuffer method that belongs to turtles. Every action is added, even if the action doesn't change anything visually. This feature is comparable to the undo tool available in most text editors. Turtles can undo their progress with the undo method.   Reading Questions   How might students benefit from having a visual representation such as C-Turtle? Check all that apply.     Students receive instant feedback and gratification for their work.    Correct!      Students will pay less attention to how their code works, and more attention to its end result.    Incorrect, because equal thought must be put into the usage of Turtles as well as the outcome.      Students get more acquainted with RGB values common in web development.    Incorrect, because RGB values are not the focus or reason behind using Turtles.      Students will be more comfortable working with concepts they are used to, such as Turtles.    Correct!      Construct a program that fills a green triangle using begin_fill and end_fill using the example code above as a guide.   #include <CTurtle.hpp>  namespace ct = cturtle;   int main(){   ct::TurtleScreen scr;  ct::Turtle turtle(scr);   turtle.fillcolor({\"green\"});   turtle.begin_fill();   for(int i = 0; i < 3; i++){  turtle.forward(50);  turtle.right(60);  }   turtle.end_fill();   scr.bye();   return 0;   }   There are 14 commonly used methods for Turtles. Many of them have names that indicate what they do. See if you can match each method description with their names!  Match the turtle method descriptions to the methods they belong to. Feedback shows incorrect matches.  turn to the left. turtle.left  turn to the right. turtle.right  pick pen up. turtle.penup  put pen down. turtle.pendown  what color to fill drawing with. turtle.fillcolor  start filling the shape. turtle.beginfill  write some text to the canvas. turtle.write   Match the turtle method descriptions to the methods they belong to. Feedback shows incorrect matches.  stops filling the shape. turtle.endfill  change the pen color. turtle.pencolor  change the pen size. turtle.width  change the speed. turtle.speed  move backward. turtle.back  move forward. turtle.forward  move to a specific coordinate. turtle.goto    How many frames of animation does the above code create?     3    Incorrect! Consider how many actions the turtle takes in the for loop.      6    Incorrect! Consider the tracer setting for the screen.      1    Correct!      12    Incorrect! Consider how many actions the turtle takes in the for loop.      How many actions will be in the turtle's undo queue for the code above?     3    Incorrect! Consider how many actions the turtle takes in the for loop.      6    Correct!      1    Incorrect! Consider how many actions the turtle takes in the for loop.      12    Incorrect! Consider how many actions the turtle takes in the for loop.          "
},
{
  "id": "introduction_turtle-turtlescreen-7",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_turtle-turtlescreen-7",
  "type": "Table",
  "number": "1.14.1",
  "title": "",
  "body": "  Method Name  Description    turtle.left  turns the turtle a certain number of units to the left.    turtle.right  turns the turtle a certain number of units to the right.    turtle.penup  raises the paint pen on the end of the turtle's tail.    turtle.pendown  lowers the paint pen on the end of the turtle's tail.    turtle.fillcolor  tells the turtle what color the inside of the shape will be.    turtle.beginfill  tells the turtle to begin filling a shape as it moves.    turtle.endfill  tells the turtle to finish filling the shape it has created as it moved.    turtle.pencolor  tells the turtle what color it will draw with.    turtle.width  tells the turtle how large of a paint pen to use.    turtle.speed  tells the turtle how fast it should go, faster or slower than the hare.    turtle.back  moves the turtle back a number of units.    turtle.forward  moves the turtle forward a number of units.    turtle.goto  tells the turtle to move to a specific coordinate.    turtle.write  tells the turtle to write some kind of text.   "
},
{
  "id": "introduction_turtle-turtlescreen-9",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_turtle-turtlescreen-9",
  "type": "Table",
  "number": "1.14.2",
  "title": "",
  "body": "  CTurtle Name  Speed    TS_FASTEST  0    TS_FAST  10    TS_NORMAL  6    TS_SLOW  3    TS_SLOWEST  1   "
},
{
  "id": "introduction_geometry-shapes-and-stamps-6",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_geometry-shapes-and-stamps-6",
  "type": "Table",
  "number": "1.14.3",
  "title": "",
  "body": "  triangle  indented_triangle  square  arrow    (0, 0)  (0, 0)  (-5, -5)  (0, 0)    (-5, 5)  (-5, 10)  (-5, 5)  (-5, 5)    (5, 5)  (0, 8)  (5, 5)  (-3, 5)    .  (5, 10)  (5, 10)  (-3, 10)    .  .  .  (3, 10)    .  .  .  (3, 5)    .  .  .  (5, 5)   "
},
{
  "id": "ccpolygon",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#ccpolygon",
  "type": "Figure",
  "number": "1.14.4",
  "title": "",
  "body": " Indented Triangle Definition   Graphic illustrating an indented triangle with coordinate points. At the top vertex, the point is labeled '0, 0'. The bottom left vertex is labeled '-5, 10', and the bottom right vertex is labeled '5, 10'. An arrow curves above the triangle, indicating rotation or flipping. Each vertex is marked with a green circle. The image defines the shape and position of an indented triangle in a coordinate system   "
},
{
  "id": "introduction_geometry-shapes-and-stamps-13",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_geometry-shapes-and-stamps-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "ID "
},
{
  "id": "introduction_advanced-features-4",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_advanced-features-4",
  "type": "Table",
  "number": "1.14.5",
  "title": "",
  "body": "  Mode  Default Rotation  Positive Angles    SM_STANDARD  East  Counterclockwise    SM_LOGO  North  Clockwise   "
},
{
  "id": "introduction_advanced-features-9",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#introduction_advanced-features-9",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "very "
},
{
  "id": "cturtle_question_1",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_question_1",
  "type": "Reading Question",
  "number": "1.14.4.1",
  "title": "",
  "body": " How might students benefit from having a visual representation such as C-Turtle? Check all that apply.     Students receive instant feedback and gratification for their work.    Correct!      Students will pay less attention to how their code works, and more attention to its end result.    Incorrect, because equal thought must be put into the usage of Turtles as well as the outcome.      Students get more acquainted with RGB values common in web development.    Incorrect, because RGB values are not the focus or reason behind using Turtles.      Students will be more comfortable working with concepts they are used to, such as Turtles.    Correct!    "
},
{
  "id": "cturtle_question_3",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_question_3",
  "type": "Reading Question",
  "number": "1.14.4.2",
  "title": "",
  "body": " Construct a program that fills a green triangle using begin_fill and end_fill using the example code above as a guide.   #include <CTurtle.hpp>  namespace ct = cturtle;   int main(){   ct::TurtleScreen scr;  ct::Turtle turtle(scr);   turtle.fillcolor({\"green\"});   turtle.begin_fill();   for(int i = 0; i < 3; i++){  turtle.forward(50);  turtle.right(60);  }   turtle.end_fill();   scr.bye();   return 0;   }  "
},
{
  "id": "cturtle_dnd_1",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_dnd_1",
  "type": "Reading Question",
  "number": "1.14.4.3",
  "title": "",
  "body": "Match the turtle method descriptions to the methods they belong to. Feedback shows incorrect matches.  turn to the left. turtle.left  turn to the right. turtle.right  pick pen up. turtle.penup  put pen down. turtle.pendown  what color to fill drawing with. turtle.fillcolor  start filling the shape. turtle.beginfill  write some text to the canvas. turtle.write  "
},
{
  "id": "cturtle_dnd_2",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_dnd_2",
  "type": "Reading Question",
  "number": "1.14.4.4",
  "title": "",
  "body": "Match the turtle method descriptions to the methods they belong to. Feedback shows incorrect matches.  stops filling the shape. turtle.endfill  change the pen color. turtle.pencolor  change the pen size. turtle.width  change the speed. turtle.speed  move backward. turtle.back  move forward. turtle.forward  move to a specific coordinate. turtle.goto  "
},
{
  "id": "cturtle_advanced_mchoice_1",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_advanced_mchoice_1",
  "type": "Reading Question",
  "number": "1.14.4.5",
  "title": "",
  "body": " How many frames of animation does the above code create?     3    Incorrect! Consider how many actions the turtle takes in the for loop.      6    Incorrect! Consider the tracer setting for the screen.      1    Correct!      12    Incorrect! Consider how many actions the turtle takes in the for loop.    "
},
{
  "id": "cturtle_advanced_mchoice_2",
  "level": "2",
  "url": "introduction_optional-graphics-in-c.html#cturtle_advanced_mchoice_2",
  "type": "Reading Question",
  "number": "1.14.4.6",
  "title": "",
  "body": " How many actions will be in the turtle's undo queue for the code above?     3    Incorrect! Consider how many actions the turtle takes in the for loop.      6    Correct!      1    Incorrect! Consider how many actions the turtle takes in the for loop.      12    Incorrect! Consider how many actions the turtle takes in the for loop.    "
},
{
  "id": "introduction_summary",
  "level": "1",
  "url": "introduction_summary.html",
  "type": "Section",
  "number": "1.15",
  "title": "Summary",
  "body": " Summary    Computer science is the study of problem solving.    Computer science uses abstraction as a tool for representing both processes and data.    Abstract data types allow programmers to manage the complexity of a problem domain by hiding the details of the data.    C++ is a powerful object-oriented language.    All variables must be declared before use in C++.    C++ has typical built-in numeric types: int is for integers and float and double are used for floating point depending on the number of digits desired.    C++ has the Boolean type bool that holds true or false .    The character data type char holds a single character which is encased in single quotes.    Pointers are a type of variable that stores a memory address. To declare a pointer, an * is used before the variable name that is supposed to store the location.    A statically allocated C++ array is an ordered collection of one or more C++ data values of identical type stored in contiguous memory.    A vector is a dynamically allocated array with many useful methods.    C++ strings are a sequential collection of zero or more characters.    A hash table is used to store keys-value pairs. It applies a related hash function to the key in order to compute the location of the associated value. Look-up is typically very fast.    A set is an unordered collection of unique values.    Arrays, vectors, and strings are C++ sequential collections.    Hash tables and sets are nonsequential collections of data.    In C++, a function definition requires a name, a group of parameters, a return type, and a body.    Non-fruitful functions in C++ must contain the keyword void in its function definition.    You can pass variables by value as well as by reference in C++ functions. Passing by reference utilizes the use of pointers.    Pass by reference is useful when you require a function to return multiple variables.    To pass an array to a function you need to use an array parameter. The array parameter is denoted by the array variable name followed by set of square brackets ([ and ]).    Defining a new meaning for an already existing operator (such as the arithmetic operators plus + or times * ) is called overloading the operator. The operators ::, #, ., and ? are reserved and cannot be overloaded.    Some operators such as =, [], () and -> can only be overloaded as member functions of a class and not as global functions.    Classes allow programmers to implement abstract data types.    Programmers can override standard methods as well as create new methods.    Classes can be organized into hierarchies.    A class constructor should always invoke the constructor of its parent before continuing on with its own data and behavior.       "
},
{
  "id": "introduction_discussion-questions",
  "level": "1",
  "url": "introduction_discussion-questions.html",
  "type": "Section",
  "number": "1.16",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Construct a class hierarchy for people on a college campus. Include faculty, staff, and students. What do they have in common? What distinguishes them from one another?    Construct a class hierarchy for bank accounts.    Construct a class hierarchy for different types of computers.    Using the classes provided in the chapter, interactively construct a circuit and test it.       "
},
{
  "id": "introduction_programming-exercises",
  "level": "1",
  "url": "introduction_programming-exercises.html",
  "type": "Section",
  "number": "1.17",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Implement the simple methods getNum and getDen that will return the numerator and denominator of a fraction.    In many ways it would be better if all fractions were maintained in lowest terms right from the start. Modify the constructor for the Fraction class so that GCD is used to reduce fractions immediately. Notice that this means the + function no longer needs to reduce. Make the necessary modifications.    Implement the remaining simple arithmetic operators ( - , * , and \/ ).    Implement the remaining relational operators ( > , >= , < , <= , and != ).    Modify the constructor for the fraction class so that it checks to make sure that the numerator and denominator are both integers. If either is not an integer the constructor should raise an exception.    In the definition of fractions we assumed that negative fractions have a negative numerator and a positive denominator. Using a negative denominator would cause some of the relational operators to give incorrect results. In general, this is an unnecessary constraint. Modify the constructor to allow the user to pass a negative denominator so that all of the operators continue to work properly.    Repeat the last question but this time consider the += method.    Research other types of gates that exist (such as NAND, NOR, and XOR). Add them to the circuit hierarchy. How much additional coding did you need to do?    The most simple arithmetic circuit is known as the half-adder. Research the simple half-adder circuit. Implement this circuit.    Now extend that circuit and implement an 8 bit full-adder.    The circuit simulation shown in this chapter works in a backward direction. In other words, given a circuit, the output is produced by working back through the input values, which in turn cause other outputs to be queried. This continues until external input lines are found, at which point the user is asked for values. Modify the implementation so that the action is in the forward direction; upon receiving inputs the circuit produces an output.    Design a class to represent a playing card. Now design a class to represent a deck of cards. Using these two classes, implement a favorite card game.    Find a Sudoku puzzle in the local newspaper. Write a program to solve the puzzle.       "
},
{
  "id": "introduction_glossary",
  "level": "1",
  "url": "introduction_glossary.html",
  "type": "Section",
  "number": "1.18",
  "title": "Glossary",
  "body": " Glossary    abstract data type\/ADT  A mathematical model for data.    abstraction  Focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant.    access keywords  Keywords such as ‘'public'', private'', and ‘'protected'' that indicates what class properties\/behaviors a user can change.    address-of  The address-of operator ( & ) is used to access the address of a C++ variable.    algorithm  A set of instructions or rules given to complete a task.    AND  A primitive logic gate. In this gate, both A AND B must be true in order to be true.    argument  Data passed to a parameter.    array  A data structure consisting of an ordered collection of data elements of identical type in which each element can be identified by an array index.    array parameters  Used to pass an array of arguments.    atomic data type  Basic data type that cannot be broken down into any simpler data elements.    base class  A class from which other classes are derived.    bool  Keyword for Boolean data type.    char  Keyword for character data type that stores a single character.    child class  inherit characteristic data and\/or behaviors from a parent class.    class  A template for creating (instantiating) objects, for providing initial values for state via member variables, and for implementations of behavior via member functions or methods.    class methods  The functions and methods that belong to a class that describe what the class can do.    collection  A grouping of a number of data items (possibly only zero or one) that have some shared significance or need to be operated upon together.    compiler  A program that converts high-level language into machine language.    computable  The capability of being copmuted or solved.    const  Keyword that makes a variable or value immutable. i.e. constant and unchanging.    constructor  A class' special function that initializes an object of that class.    data abstraction  The act of only providing essential information within your work. Representing your data without reavling the details.    data structure  The organization of data that allows for improved search, storage, and sorting capability.    data types  A classification of various types of data, such as floating-point, integer, or Boolean, the possible values for that type, operations that can be done on that type, and how the values of that type are stored.    dereference  Follow a pointer to its referenced memory location and read the data there.    derived class  A derived class is a class created or derived from another existing class.    double  Keyword for double-precision floating point data type.    encapsulation  Hiding the contents of a class except when absolutely necessary.    float  Keyword for floating point data type.    friend function  A function defined outside that class' scope but has access to private and protected members of the class.    function  A section of code that performs a procedure and is usually named.    function overloading  Function overloading is the ability to create multiple functions of the same name with different implementations.    HAS-A Relationship  A relationship where one object belongs to another object, and behaves according to rules of ownership.    hash table  A collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.    immutable  Unable to be modified.    information hiding  Hiding information so that it is invisible from the outside of an object.    inheritance  Sharing\/gaining the same behavior as another class.    inheritance hierarchy  A singly rooted tree structure.    instance  An occurrence of an object.    int  Keyword for integer data type.    int main()  The main function used to call all other functions.    interface  A shared boundary in which two or more components of a computer system exchange information.    machine code  Instructions and data understandable by a computer's CPU.    mutability  Able to be modified.    NOT  An inverter, used to negate input.    object  A variable, data structure, function, or a method, that can be referenced by an identifier.    object attribute  A property of an object that describes what it looks like .    object-oriented programming language  Programming language that uses objects to represent data and methods such as C++ and Java.    operator overloading  Same as function overloading.    OR  A basic gate. If either input is true, the output is also. If inputs are false, so is the output.    overloading  Specifying more than one definition for the same function name or the same operator within the same scope.    parameter  A variable in a function or method definition that accepts data passed from an argument.    parent class  A class that has been extended by another existing class.    pass by reference  To pass an object to a function by referencing its location in memory.    pass by value  To pass an object to a function by copying its value.    programming  The use of logic to create specified computing operations.    pointer  A variable that stores and manipulates memory addresses.    polymorphism  The ability to process objects or methods differently depending on their data type, class, number of arguments, etc.    reference  A value that indicates a place in a computer's memory.    set  An unordered data structure consisting of unique, immutable data values.    string  A sequential data structure consisting of zero or more characters.    subclasses  A division of an existing class.    superclass  A class that has been extended by another existing class.    truth table  A mathematical table used to visually represent boolean logic and functions.    unordered set  A container that is not sorted or ordered in any secific way.    vector  Sequence container storing data of a single type that is stored in a dynamically allocated array which can change in size.    virtual function  Member function which is declared within a base class and is overridden by a derived class.    void  Keyword indicating a function has no return value.    word  Unit of data used by a particular processor design.       "
},
{
  "id": "introduction_introduction_matching",
  "level": "1",
  "url": "introduction_introduction_matching.html",
  "type": "Section",
  "number": "1.19",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition (not all the words from the glossary appear below.)   Try again!    abstraction  focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant    class methods  the functions that belong to a particular class    collection  a grouping of data items that have some shared significance or need to be operated upon together.    object-oriented programming language  uses objects to represent data and methods such as C++ and Java    constructor  an class' special function that initializes an object of that class    dereference  follow a pointer to its referenced memory location and read the data there.    object attribute  a property of an object that describes what it \"looks like\"    encapsulation  hiding the contents of a class except when absolutely necessary    parameter  a variable in a function or method definition that accepts data passed from an argument.    friend  an operator or function that can access the private data members of a class    friend function  a function defined outside that class' scope but has access to private and protected members of the class    mutability  able to be modified.    function  A section of code that performs a procedure and is usually named    address-of  &    argument  data passed to a parameter.    array  a data structure consisting of an ordered collection of data elements of identical type    atomic data type  basic data type that cannot be broken down into any simpler data elements.    inheritance  sharing\/gaining the same behavior as another class    polymorphism  the ability to process objects or methods differently depending on their data type, class, number of arguments, etc.    class  a template for creating (instantiating) objects, for providing initial values for state via member variables       "
},
{
  "id": "chapter1glos",
  "level": "2",
  "url": "introduction_introduction_matching.html#chapter1glos",
  "type": "Checkpoint",
  "number": "1.19.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition (not all the words from the glossary appear below.)   Try again!    abstraction  focusing on desired behaviors and properties while disregarding what is irrelevant\/unimportant    class methods  the functions that belong to a particular class    collection  a grouping of data items that have some shared significance or need to be operated upon together.    object-oriented programming language  uses objects to represent data and methods such as C++ and Java    constructor  an class' special function that initializes an object of that class    dereference  follow a pointer to its referenced memory location and read the data there.    object attribute  a property of an object that describes what it \"looks like\"    encapsulation  hiding the contents of a class except when absolutely necessary    parameter  a variable in a function or method definition that accepts data passed from an argument.    friend  an operator or function that can access the private data members of a class    friend function  a function defined outside that class' scope but has access to private and protected members of the class    mutability  able to be modified.    function  A section of code that performs a procedure and is usually named    address-of  &    argument  data passed to a parameter.    array  a data structure consisting of an ordered collection of data elements of identical type    atomic data type  basic data type that cannot be broken down into any simpler data elements.    inheritance  sharing\/gaining the same behavior as another class    polymorphism  the ability to process objects or methods differently depending on their data type, class, number of arguments, etc.    class  a template for creating (instantiating) objects, for providing initial values for state via member variables   "
},
{
  "id": "algorithm-analysis_objectives",
  "level": "1",
  "url": "algorithm-analysis_objectives.html",
  "type": "Section",
  "number": "2.1",
  "title": "Objectives",
  "body": " Objectives    To understand why algorithm analysis is important.    To be able to use Big-O to describe execution time.    To understand the Big-O execution time of common operations on C++ arrays and dictionaries.    To understand how the implementation of C++ data impacts algorithm analysis.    To understand how to benchmark simple C++ programs.       "
},
{
  "id": "algorithm-analysis_what-is-algorithm-analysis",
  "level": "1",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html",
  "type": "Section",
  "number": "2.2",
  "title": "What Is Algorithm Analysis?",
  "body": " What Is Algorithm Analysis?   It is very common for beginning computer science students to compare their programs with one another. You may also have noticed that it is common for computer programs to look very similar, especially the simple ones. An interesting question often arises. When two programs solve the same problem but look different, is one program better than the other?  In order to answer this question, we need to remember that there is an important difference between a program and the underlying algorithm that the program is representing. As we stated in , an algorithm is a generic, step-by-step list of instructions for solving a problem. It is a method for solving any instance of the problem such that given a particular input, the algorithm produces the desired result. A program  program , on the other hand, is an algorithm that has been encoded into some programming language. There may be many programs for the same algorithm, depending on the programmer and the programming language being used.  To explore this difference further, consider the function shown in . This function solves a familiar problem, computing the sum of the first n integers. The algorithm uses the idea of an accumulator variable that is initialized to 0. The solution then iterates through the n integers, adding each to the accumulator.   Sum of First n Integers  #include <iostream> using namespace std; \/\/adds the sum of (n + n-1 + n-2 ...) int sumOfN(int n){ int theSum = 0; for (int i = 0; i < n+1; i++){ theSum = theSum + i; } return theSum; } int main(){ \/\/ n is 10 (10 + 9 + 8 ...) cout << sumOfN(10); return 0; }  # adds the sum of (n + n-1 + n-2 ...) def sumOfN(n): theSum = 0 for i in range(1,n+1): theSum = theSum + i return theSum def main(): print(sumOfN(10)) # n is 10 (10 + 9 + 8 ...) main()   Now look at the function in . At first glance it may look strange, but upon further inspection you can see that this function is essentially doing the same thing as the previous one. The reason this is not obvious is poor coding. We did not use good identifier names to assist with readability, and we used an extra assignment statement during the accumulation step that was not really necessary.   Sum of First n Integers  #include <iostream> using namespace std; \/\/Performs same function as listing 1, but is less descriptive \/\/This is not good practice int foo(int tom){ int fred = 0; for (int bill = 0; bill < tom+1; bill++){ int barney = bill; fred = fred + barney; } return fred; } int main(){ cout << foo(10); return 0; }  #Performs same function as listing 1, but is less descriptive #This is not good practice def foo(tom): fred = 0 for bill in range(1,tom+1): barney = bill fred = fred + barney return fred def main(): print(foo(10)) main()   The question we raised earlier asked whether one function is better than another. The answer depends on your criteria. The function sumOfN is certainly better than the function foo if you are concerned with readability. In fact, you have probably seen many examples of this in your introductory programming course since one of the goals there is to help you write programs that are easy to read and easy to understand. In this course, however, we are also interested in characterizing the algorithm itself. (We certainly hope that you will continue to strive to write readable, understandable code.)  Algorithm analysis is concerned with comparing algorithms based upon the amount of computing resources that each algorithm uses. We want to be able to consider two algorithms and say that one is better than the other because it is more efficient in its use of those resources or perhaps because it simply uses fewer. From this perspective, the two functions above seem very similar. They both use essentially the same algorithm to solve the summation problem.  At this point, it is important to think more about what we really mean by computing resources. There are two different ways to look at this. One way is to consider the amount of space or memory an algorithm requires to solve the problem. The amount of space required by a problem solution is typically dictated by the problem instance itself. Every so often, however, there are algorithms that have very specific space requirements, and in those cases we will be very careful to explain the variations.  As an alternative to space requirements, we can analyze and compare algorithms based on the amount of time they require to execute. This measure is sometimes referred to as the execution time or running time of the algorithm. One way we can measure the execution time for the function sumOfN is to do a benchmark analysis. This means that we will track the actual time required for the program to compute its result. In C++, we can benchmark a function by noting the starting time and ending time with respect to the system we are using. In the ctime library there is a function called clock that will return the current system clock time in seconds since some arbitrary starting point. By calling this function twice, at the beginning and at the end, and then computing the difference, we can get an exact number of seconds (fractions in most cases) for execution.   Sum of First n Integers (With Timing)  #include <iostream> #include <ctime> using namespace std; \/\/Performs same function as listing one, and also list the time it takes to perform \/\/the function int sumofN2(int n) { clock_t begin = clock(); int theSum = 0; for(int i = 0; i < n+1; i++){ theSum = theSum + i; } clock_t end = clock(); double elapsed_secs = double(end - begin) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"Sum is \" << theSum << \" required \"<<elapsed_secs << \" seconds\" << endl; return theSum; } int main(){ for (int i = 0; i < 6; i++){ sumofN2(10000); } return 0; }  import time \"\"\" Performs same function as listing one, and also list the time it takes to perform the function \"\"\" def sumOfN2(n): start = time.time() theSum = 0 for i in range(1,n+1): theSum = theSum + i end = time.time() elapsed = end-start print(\"Sum is\", theSum, \"required\", elapsed, \"seconds\") return elapsed def main(): for i in range(5): sumOfN2(10000) main()   shows the original sumOfN function with the timing calls embedded before and after the summation. The function returns the amount of time (in seconds) required for the calculation.  Consider the following code block:   How many times?  int n = 1000; int theSum = 0; for (int i=0; i<n+1; i++){ theSum = theSum + 1; \/\/how many times? }     Some Needed Math Notation  This is the sigma symbol: . It tells us that we are summing up something much like a mathematical loop typically with a counter.  If we have the bottom index i=1 tells us that the index i begins at 1 and that i will terminate at 5 .  What ever comes immediately afterwards is what we are summing. So, tells us to add the integers because just like in a for loop, we plug a value for each i value. Similarly, means .    Applying the Math Notation  There is often more than one way to solve a problem. Let's consider the blue area in the following .rectangle.   Sum of n = 8 integers   This figure illustrates the sum of eight integers (Figure 1). Examining the blue area within the rectangle highlights various problem-solving approaches. The visual representation provides clarity, showcasing the intricacies involved in calculating the sum and emphasizing the value of diverse perspectives in mathematical problem-solving.    To find the blue area, we can count the number of blue squares , which we just learned can be written as However, we also know how to find the area of a rectangle, by multiplying height by width, and the blue squares represent half of the rectangle. So, the area with blue squares is also just .  Hence, when we have a variable n , we have learned that we can just use the closed equation to compute the sum of the first n integers without iterating.  Consider the function in .   sumOfN3  int sumOfN3(int n){ int sum_n = (n*(n+1))\/2; \/\/ how many times? return sum_n; }   We see this in , which shows sumOfN3 taking advantage of the formula we just developed.   Algorithm to analyze  C++ implementation \/\/Performs same function as listing one, and also list the time it takes to perform \/\/the function, and it performs better with larger inputs or (n) #include <iostream> using namespace std; #include <ctime> int sumOfN3(int n){ int sum_n = (n*(n+1))\/2; return sum_n; } int main(){ cout << sumOfN3(10); return 0; }  Python implementation \"\"\" Performs same function as listing one, and also list the time it takes to perform the function, and it performs better with larger inputs or (n) \"\"\" def sumOfN3(n): return (n*(n+1))\/\/2 def main(): print(sumOfN3(10)) main()  If we do the same benchmark measurement for sumOfN3 for different values of n , we get the following results:  When the value of n is 10:  Sum is 55 required 0.000000 seconds Sum is 55 required 0.000000 seconds Sum is 55 required 0.000000 seconds Sum is 55 required 0.000001 seconds Sum is 55 required 0.000000 seconds  When the value of n is 1000:  Sum is 500500 required 0.000000 seconds Sum is 500500 required 0.000000 seconds Sum is 500500 required 0.000001 seconds Sum is 500500 required 0.000000 seconds Sum is 500500 required 0.000001 seconds  When the value of n is 10,000:  Sum is 50005000 required 0.000000 seconds Sum is 50005000 required 0.000000 seconds Sum is 50005000 required 0.000001 seconds Sum is 50005000 required 0.000001 seconds Sum is 50005000 required 0.000000 seconds  There are two important things to notice about this output. First, the times recorded above are shorter than any of the previous examples. Second, they are very consistent no matter what the value of n . It appears that sumOfN3 is hardly impacted by the number of integers being added.  But what does this benchmark really tell us? Intuitively, we can see that the iterative solutions seem to be doing more work since some program steps are being repeated. This is likely the reason it is taking longer. Also, the time required for the iterative solution seems to increase as we increase the value of n . However, there is a problem. If we run the same function on a different computer or used a different programming language, we would likely get different results. It could take even longer to perform sumOfN3 if the computer were older.  We need a better way to characterize these algorithms with respect to execution time. The benchmark technique computes the actual time to execute. It does not really provide us with a useful measurement, because it is dependent on a particular machine, program, time of day, compiler, and programming language. Instead, we would like to have a characterization that is independent of the program or computer being used. This measure would then be useful for judging the algorithm alone and could be used to compare algorithms across implementations.   Reading Questions   How many times is the theSum = theSum + i line executed in ?  Right! Good job! No. Look carefully at the loop condition i<n+1. Incorrect. Please try again.   Compute the result of     6    No. Use i = 1, i = 2, and i = 3, plugging into .      14    No. Use i = 1, i = 2, and i = 3, plugging into .      25    No. Use i = 1, i = 2, and i = 3, plugging into .      36    Right! It is .      None of the above    One of the above is correct!      If SumOfN3 ( ) is called once with a parameter of n=10 , how many times is the int sum_n = (n*(n+1))\/2; line executed?    Right! Good job!  No, consider that the function is called only once, and n is the parameter.  Incorrect. Please try again.        "
},
{
  "id": "algorithm-analysis_what-is-algorithm-analysis-2-2",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#algorithm-analysis_what-is-algorithm-analysis-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "algorithm program "
},
{
  "id": "expl-lst-sum0",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#expl-lst-sum0",
  "type": "Exploration",
  "number": "2.2.1",
  "title": "Sum of First <em class=\"emphasis\">n<\/em> Integers.",
  "body": " Sum of First n Integers  #include <iostream> using namespace std; \/\/adds the sum of (n + n-1 + n-2 ...) int sumOfN(int n){ int theSum = 0; for (int i = 0; i < n+1; i++){ theSum = theSum + i; } return theSum; } int main(){ \/\/ n is 10 (10 + 9 + 8 ...) cout << sumOfN(10); return 0; }  # adds the sum of (n + n-1 + n-2 ...) def sumOfN(n): theSum = 0 for i in range(1,n+1): theSum = theSum + i return theSum def main(): print(sumOfN(10)) # n is 10 (10 + 9 + 8 ...) main()  "
},
{
  "id": "expl-lst-sum2",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#expl-lst-sum2",
  "type": "Exploration",
  "number": "2.2.2",
  "title": "Sum of First <em class=\"emphasis\">n<\/em> Integers.",
  "body": " Sum of First n Integers  #include <iostream> using namespace std; \/\/Performs same function as listing 1, but is less descriptive \/\/This is not good practice int foo(int tom){ int fred = 0; for (int bill = 0; bill < tom+1; bill++){ int barney = bill; fred = fred + barney; } return fred; } int main(){ cout << foo(10); return 0; }  #Performs same function as listing 1, but is less descriptive #This is not good practice def foo(tom): fred = 0 for bill in range(1,tom+1): barney = bill fred = fred + barney return fred def main(): print(foo(10)) main()  "
},
{
  "id": "expl-lst-sum1",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#expl-lst-sum1",
  "type": "Exploration",
  "number": "2.2.3",
  "title": "Sum of First <em class=\"emphasis\">n<\/em> Integers (With Timing).",
  "body": " Sum of First n Integers (With Timing)  #include <iostream> #include <ctime> using namespace std; \/\/Performs same function as listing one, and also list the time it takes to perform \/\/the function int sumofN2(int n) { clock_t begin = clock(); int theSum = 0; for(int i = 0; i < n+1; i++){ theSum = theSum + i; } clock_t end = clock(); double elapsed_secs = double(end - begin) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"Sum is \" << theSum << \" required \"<<elapsed_secs << \" seconds\" << endl; return theSum; } int main(){ for (int i = 0; i < 6; i++){ sumofN2(10000); } return 0; }  import time \"\"\" Performs same function as listing one, and also list the time it takes to perform the function \"\"\" def sumOfN2(n): start = time.time() theSum = 0 for i in range(1,n+1): theSum = theSum + i end = time.time() elapsed = end-start print(\"Sum is\", theSum, \"required\", elapsed, \"seconds\") return elapsed def main(): for i in range(5): sumOfN2(10000) main()  "
},
{
  "id": "n1000-how-many",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#n1000-how-many",
  "type": "Listing",
  "number": "2.2.1",
  "title": "",
  "body": " How many times?  int n = 1000; int theSum = 0; for (int i=0; i<n+1; i++){ theSum = theSum + 1; \/\/how many times? }  "
},
{
  "id": "fig-sumof-n-integers",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#fig-sumof-n-integers",
  "type": "Figure",
  "number": "2.2.2",
  "title": "",
  "body": " Sum of n = 8 integers   This figure illustrates the sum of eight integers (Figure 1). Examining the blue area within the rectangle highlights various problem-solving approaches. The visual representation provides clarity, showcasing the intricacies involved in calculating the sum and emphasizing the value of diverse perspectives in mathematical problem-solving.   "
},
{
  "id": "sum-of-n3",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#sum-of-n3",
  "type": "Listing",
  "number": "2.2.3",
  "title": "",
  "body": " sumOfN3  int sumOfN3(int n){ int sum_n = (n*(n+1))\/2; \/\/ how many times? return sum_n; }  "
},
{
  "id": "algorithm-analysis_active3cpp-expl",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#algorithm-analysis_active3cpp-expl",
  "type": "Exploration",
  "number": "2.2.4",
  "title": "Algorithm to analyze.",
  "body": " Algorithm to analyze  C++ implementation \/\/Performs same function as listing one, and also list the time it takes to perform \/\/the function, and it performs better with larger inputs or (n) #include <iostream> using namespace std; #include <ctime> int sumOfN3(int n){ int sum_n = (n*(n+1))\/2; return sum_n; } int main(){ cout << sumOfN3(10); return 0; }  Python implementation \"\"\" Performs same function as listing one, and also list the time it takes to perform the function, and it performs better with larger inputs or (n) \"\"\" def sumOfN3(n): return (n*(n+1))\/\/2 def main(): print(sumOfN3(10)) main() "
},
{
  "id": "howmany1",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#howmany1",
  "type": "Reading Question",
  "number": "2.2.2.1",
  "title": "",
  "body": " How many times is the theSum = theSum + i line executed in ?  Right! Good job! No. Look carefully at the loop condition i<n+1. Incorrect. Please try again. "
},
{
  "id": "somemath1",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#somemath1",
  "type": "Reading Question",
  "number": "2.2.2.2",
  "title": "",
  "body": " Compute the result of     6    No. Use i = 1, i = 2, and i = 3, plugging into .      14    No. Use i = 1, i = 2, and i = 3, plugging into .      25    No. Use i = 1, i = 2, and i = 3, plugging into .      36    Right! It is .      None of the above    One of the above is correct!    "
},
{
  "id": "bigo2",
  "level": "2",
  "url": "algorithm-analysis_what-is-algorithm-analysis.html#bigo2",
  "type": "Reading Question",
  "number": "2.2.2.3",
  "title": "",
  "body": " If SumOfN3 ( ) is called once with a parameter of n=10 , how many times is the int sum_n = (n*(n+1))\/2; line executed?    Right! Good job!  No, consider that the function is called only once, and n is the parameter.  Incorrect. Please try again.  "
},
{
  "id": "algorithm-analysis_big-o-notation",
  "level": "1",
  "url": "algorithm-analysis_big-o-notation.html",
  "type": "Section",
  "number": "2.3",
  "title": "Big-O Notation",
  "body": " Big-O Notation  When trying to characterize an algorithm's efficiency in terms of execution time, independent of any particular program or computer, it is important to quantify the number of operations or steps that the algorithm will require. If each of these steps is considered to be a basic unit of computation, then the execution time for an algorithm can be expressed as the number of steps required to solve the problem. Deciding on an appropriate basic unit of computation can be a complicated problem and will depend on how the algorithm is implemented.  A good basic unit of computation for comparing the summation algorithms shown earlier might be to count the number of assignment statements performed to compute the sum. In the function sumOfN , the number of assignment statements is 1 ( ) plus the value of n (the number of times we perform ). We can denote this by a function, call it T, where . The parameter n is often referred to as the size of the problem, and we can read this as T(n) is the time it takes to solve a problem of size n, namely 1+n steps.  In the summation functions given above, it makes sense to use the number of terms in the summation to denote the size of the problem. We can then say that the sum of the first 100,000 integers is a bigger instance of the summation problem than the sum of the first 1,000. Because of this, it might seem reasonable that the time required to solve the larger case would be greater than for the smaller case. Our goal then is to show how the algorithm's execution time changes with respect to the size of the problem.  Computer scientists prefer to take this analysis technique one step further. It turns out that the exact number of operations is not as important as determining the most dominant part of the function. In other words, as the problem gets larger, some portion of the function tends to overpower the rest. This dominant term is what, in the end, is used for comparison. order of magnitude The order of magnitude function describes the part of that increases the fastest as the value of n increases. big-O notation Order of magnitude is often called Big-O notation (for order ) and written as . It provides a useful approximation to the actual number of steps in the computation. The function provides a simple representation of the dominant part of the original .  In the above example, . As n gets large, the constant 1 will become less and less significant to the final result. If we are looking for an approximation for , then we can drop the 1 and simply say that the running time is . It is important to note that the 1 is certainly significant for . However, as n gets large, our approximation will be just as accurate without it.  As another example, suppose that for some algorithm, the exact number of steps is . When n is small, say 1 or 2, the constant 1005 seems to be the dominant part of the function. However, as n gets larger, the term becomes the most important. In fact, when n is really large, the other two terms become insignificant in the role that they play in determining the final result. Again, to approximate as n gets large, we can ignore the other terms and focus on . In addition, the coefficient becomes insignificant as n gets large. We would say then that the function has an order of magnitude , or simply that it is .  Although we do not see this in the summation example, sometimes the performance of an algorithm depends on the exact values of the data rather than simply the size of the problem. For these kinds of algorithms we need to characterize their performance in terms of best case best case , worst case worst case , or average case average case performance. The worst-case performance refers to a particular data set where the algorithm performs extremely poorly. At the same time, a different data set for the exact same algorithm might have outstanding performance. However, in most cases the algorithm performs somewhere in between these two extremes (average case). It is important for a computer scientist to understand these distinctions so they are not misled by one particular case.  A number of very common order of magnitude functions will come up over and over as you study algorithms. These are shown in . In order to decide which of these functions is the dominant part of any function, we must see how they compare with one another as n gets large.   Table 1: Common Big-O Functions    f(n)    Name        Constant       Logarithmic       Linear       Log Linear       Quadratic       Cubic       Exponential    shows graphs of the common functions from . Notice that when n is small, the functions are not very well defined with respect to one another. It is hard to tell which is dominant. However, as n grows, there is a definite relationship and it is easy to see how they compare with one another.   Common Big-O Functions   Figure 1 shows graphs of the common functions from Table 1. Notice that when n is small, the functions are not very well defined with respect to one another. It is hard to tell which is dominant. However, as n grows, there is a definite relationship and it is easy to see how they compare with one another.    As a final example, suppose that we have the fragment of C++ code shown in . Although this program does not really do anything, it is instructive to see how we can take actual code and analyze performance.   C++ Implementation  #include <iostream> using namespace std; int main(){ int a=5; int b=6; int c=10; for (int i=0; i<n; i++){ for (int j=0; j<n; j++){ int x = i * i; int y = j * j; int z = i * j; } } for (int k = 0; k < n; k++){ int w = a*k + 45; int v = b*b; } int d = 33; return 0; }  Python Implementation  def main(): a=5 b=6 c=10 for i in range(n): for j in range(n): x = i * i y = j * j z = i * j for k in range(n): w = a*k + 45 v = b*b d = 33 main()   The number of assignment operations is the sum of four terms. The first term is the constant 3, representing the three assignment statements at the start of the fragment. The second term is , since there are three statements that are performed times due to the nested iteration. The third term is , two statements iterated n times. Finally, the fourth term is the constant 1, representing the final assignment statement. This gives us . By looking at the exponents, we can easily see that the term will be dominant and therefore this fragment of code is . Note that all of the other terms as well as the coefficient on the dominant term can be ignored as n grows larger.   Comparing with Big-O Functions   This figure shows a few of the common Big-O functions as they compare with the T(n) function discussed above. Note that T(n) is initially larger than the cubic function. However, as n grows, the cubic function quickly overtakes T(n). It is easy to see that T(n) then follows the quadratic function as n continues to grow.    shows a few of the common Big-O functions as they compare with the function discussed above. Note that is initially larger than the cubic function. However, as n grows, the cubic function quickly overtakes . It is easy to see that then follows the quadratic function as continues to grow.   Reading Questions   If the exact number of steps is what is the Big O?     O(2n)    No, 3n 2 dominates 2n. Try again.      O(n)    No, n 2 dominates n. Try again.      O(3n 2 )    No, the 3 should be omitted because n 2 dominates.      O(n 2 )    Right!      More than one of the above    No, only one of them is correct. Try again.      Without looking at the graph above, from top to bottom order the following from most to least efficient.   constant  logarithmic  linear  log linear  quadratic  cubic  exponential    Which of the following statements is true about the two algorithms? Algorithm 1: 100n + 1 Algorithm 2: n^2 + n + 1     Algorithm 1 will require a greater number of steps to complete than Algorithm 2    This could be true depending on the input, but consider the broader picture      Algorithm 2 will require a greater number of steps to complete than Algorithm 1    This could be true depending on the input, but consider the broader picture      Algorithm 1 will require a greater number of steps to complete than Algorithm 2 until they reach the crossover point    Correct!      Algorithm 1 and 2 will always require the same number of steps to complete    No, the efficiency of both will depend on the input      The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 3 million inputs; how long would it take with 4 million inputs?     3.444    Incorrect. Try again.      2.53    Correct!      2    Incorrect. Try again.      4    Incorrect. Try again.      More than one of the above    No, only one of them is correct. Try again.      The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 3 million inputs; how long would it take with 10 million inputs?     3.444    Incorrect. Try again.      2.53    Incorrect. Try again.      2    Incorrect. Try again.      4.2    Right!      More than one of the above    No, only one of them is correct. Try again.      The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 1000 inputs; how long would it take with 2000 inputs?     2000    Incorrect. Try again. Think about what happens to the time as more operations occur.      3000    Incorrect. Try again. Think about what happens to the time as more operations occur.      16    Correct!      1500    Incorrect. Try again. Think about what happens to the time as more operations occur.      More than one of the above    No, only one of them is correct. Try again.      The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 1000 inputs; how long would it take with 10,000 inputs?     2000    Right!      3000    Incorrect. Try again. Think about what happens to the time as more operations occur.      16    Incorrect. Try again. Think about what happens to the time as more operations occur.      1500    Incorrect. Try again. Think about what happens to the time as more operations occur.      More than one of the above    No, only one of them is correct. Try again.         "
},
{
  "id": "algorithm-analysis_big-o-notation-5",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#algorithm-analysis_big-o-notation-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "order of magnitude Big-O notation "
},
{
  "id": "algorithm-analysis_big-o-notation-8",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#algorithm-analysis_big-o-notation-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "best case worst case average case "
},
{
  "id": "algorithm-analysis_algorithm-analysis_tbl-fntablecpp",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#algorithm-analysis_algorithm-analysis_tbl-fntablecpp",
  "type": "Table",
  "number": "2.3.1",
  "title": "",
  "body": " Table 1: Common Big-O Functions    f(n)    Name        Constant       Logarithmic       Linear       Log Linear       Quadratic       Cubic       Exponential   "
},
{
  "id": "fig-graphfigurecpp",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#fig-graphfigurecpp",
  "type": "Figure",
  "number": "2.3.2",
  "title": "",
  "body": " Common Big-O Functions   Figure 1 shows graphs of the common functions from Table 1. Notice that when n is small, the functions are not very well defined with respect to one another. It is hard to tell which is dominant. However, as n grows, there is a definite relationship and it is easy to see how they compare with one another.   "
},
{
  "id": "algo_analysis_dummycode_1",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#algo_analysis_dummycode_1",
  "type": "Listing",
  "number": "2.3.3",
  "title": "",
  "body": " C++ Implementation  #include <iostream> using namespace std; int main(){ int a=5; int b=6; int c=10; for (int i=0; i<n; i++){ for (int j=0; j<n; j++){ int x = i * i; int y = j * j; int z = i * j; } } for (int k = 0; k < n; k++){ int w = a*k + 45; int v = b*b; } int d = 33; return 0; }  Python Implementation  def main(): a=5 b=6 c=10 for i in range(n): for j in range(n): x = i * i y = j * j z = i * j for k in range(n): w = a*k + 45 v = b*b d = 33 main()  "
},
{
  "id": "fig_graphfigure2cpp",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#fig_graphfigure2cpp",
  "type": "Figure",
  "number": "2.3.4",
  "title": "",
  "body": " Comparing with Big-O Functions   This figure shows a few of the common Big-O functions as they compare with the T(n) function discussed above. Note that T(n) is initially larger than the cubic function. However, as n grows, the cubic function quickly overtakes T(n). It is easy to see that T(n) then follows the quadratic function as n continues to grow.   "
},
{
  "id": "bigo3",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#bigo3",
  "type": "Reading Question",
  "number": "2.3.1",
  "title": "",
  "body": " If the exact number of steps is what is the Big O?     O(2n)    No, 3n 2 dominates 2n. Try again.      O(n)    No, n 2 dominates n. Try again.      O(3n 2 )    No, the 3 should be omitted because n 2 dominates.      O(n 2 )    Right!      More than one of the above    No, only one of them is correct. Try again.    "
},
{
  "id": "parsonsBigO",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#parsonsBigO",
  "type": "Reading Question",
  "number": "2.3.2",
  "title": "",
  "body": " Without looking at the graph above, from top to bottom order the following from most to least efficient.   constant  logarithmic  linear  log linear  quadratic  cubic  exponential  "
},
{
  "id": "crossoverefficiency",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#crossoverefficiency",
  "type": "Reading Question",
  "number": "2.3.3",
  "title": "",
  "body": " Which of the following statements is true about the two algorithms? Algorithm 1: 100n + 1 Algorithm 2: n^2 + n + 1     Algorithm 1 will require a greater number of steps to complete than Algorithm 2    This could be true depending on the input, but consider the broader picture      Algorithm 2 will require a greater number of steps to complete than Algorithm 1    This could be true depending on the input, but consider the broader picture      Algorithm 1 will require a greater number of steps to complete than Algorithm 2 until they reach the crossover point    Correct!      Algorithm 1 and 2 will always require the same number of steps to complete    No, the efficiency of both will depend on the input    "
},
{
  "id": "BIGO1",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#BIGO1",
  "type": "Reading Question",
  "number": "2.3.4",
  "title": "",
  "body": " The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 3 million inputs; how long would it take with 4 million inputs?     3.444    Incorrect. Try again.      2.53    Correct!      2    Incorrect. Try again.      4    Incorrect. Try again.      More than one of the above    No, only one of them is correct. Try again.    "
},
{
  "id": "BIGO2",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#BIGO2",
  "type": "Reading Question",
  "number": "2.3.5",
  "title": "",
  "body": " The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 3 million inputs; how long would it take with 10 million inputs?     3.444    Incorrect. Try again.      2.53    Incorrect. Try again.      2    Incorrect. Try again.      4.2    Right!      More than one of the above    No, only one of them is correct. Try again.    "
},
{
  "id": "BIGO3",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#BIGO3",
  "type": "Reading Question",
  "number": "2.3.6",
  "title": "",
  "body": " The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 1000 inputs; how long would it take with 2000 inputs?     2000    Incorrect. Try again. Think about what happens to the time as more operations occur.      3000    Incorrect. Try again. Think about what happens to the time as more operations occur.      16    Correct!      1500    Incorrect. Try again. Think about what happens to the time as more operations occur.      More than one of the above    No, only one of them is correct. Try again.    "
},
{
  "id": "BIGO4",
  "level": "2",
  "url": "algorithm-analysis_big-o-notation.html#BIGO4",
  "type": "Reading Question",
  "number": "2.3.7",
  "title": "",
  "body": " The Big O of a particular algorithm is . Given that it takes 2 seconds to complete the algorithm with 1000 inputs; how long would it take with 10,000 inputs?     2000    Right!      3000    Incorrect. Try again. Think about what happens to the time as more operations occur.      16    Incorrect. Try again. Think about what happens to the time as more operations occur.      1500    Incorrect. Try again. Think about what happens to the time as more operations occur.      More than one of the above    No, only one of them is correct. Try again.    "
},
{
  "id": "algorithm-analysis_an-anagram-detection-example",
  "level": "1",
  "url": "algorithm-analysis_an-anagram-detection-example.html",
  "type": "Section",
  "number": "2.4",
  "title": "An Anagram Detection Example",
  "body": " An Anagram Detection Example   A good example problem for showing algorithms with different orders of magnitude is the classic anagram detection problem for strings. One string is an anagram of another if the second is simply a rearrangement of the first. For example, \"heart\" and \"earth\" are anagrams. The strings \"python\" and \"typhon\" are anagrams as well. For the sake of simplicity, we will assume that the two strings in question are of equal length and that they are made up of symbols from the set of 26 lowercase alphabetic characters. Our goal is to write a Boolean function that will take two strings and return whether they are anagrams.    Solution 1: Checking Off  Our first solution to the anagram problem will check the lengths of the strings and then to see that each character in the first string actually occurs in the second. If it is possible to checkoff each character, then the two strings must be anagrams. Checking off a character will be accomplished by replacing it with the special C++ character \\0 . The first step in the process will be to convert the second string to a local second string for checking off. Each character from the first string can be checked against the characters in the local second string and if found, checked off by replacement. shows this function.     #include <iostream> #include <string> using namespace std; \/\/checks to see if the anagrams have the same number of characters bool anagramsolution1(string s1, string s2){ bool stillOK = true; if (s1.length() != s2.length()) { stillOK = false; return stillOK; } string locals2 = s2; int n = s1.length(); unsigned int pos1 = 0; \/\/ checks to see if all of the letters are the same in both inputs while (pos1 < s1.length() && stillOK){ int pos2 = 0; bool found = false; while (pos2 < n && !found){ if (s1[pos1] == locals2[pos2]){ found = true; } else{ pos2 = pos2 + 1; } } if (found){ locals2[pos2] = '\\0'; } else{ stillOK = false; } pos1 = pos1 + 1; } return stillOK; } int main(){ bool value = anagramsolution1(\"abcd\", \"dcab\"); cout << value << endl; return 0; }     #checks to see if the anagrams have the same number of characters def anagramSolution1(s1,s2): stillOK = True if len(s1) != len(s2): stillOK = False return stillOK lists2 = list(s2) pos1 = 0 # checks to see if all of the letters are the same in both inputs while pos1 < len(s1) and stillOK: pos2 = 0 found = False while pos2 < len(lists2) and not found: if s1[pos1] == lists2[pos2]: found = True else: pos2 = pos2 + 1 if found: lists2[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK def main(): print(anagramSolution1('abcd','dcba')) main()     To analyze this algorithm, we need to note that each of the n characters in s1 will cause an iteration through up to n characters in the array from s2 . Each of the n positions in the array will be visited once to match a character from s1 . The number of visits then becomes the sum of the integers from 1 to n . We stated earlier that this can be written as   As gets large, the term will dominate the term and the can be ignored. Therefore, this solution is .    Solution 2: Sort and Compare  Another solution to the anagram problem will make use of the fact that even though s1 and s2 are different, they are anagrams only if they consist of exactly the same characters. So, if we begin by sorting each string alphabetically, from a to z, we will end up with the same string if the original two strings are anagrams. shows this solution.     #include <iostream> #include <string> #include <algorithm> using namespace std; \/\/ sorts anagrams in order from a-z, and then compares them bool anagramsolution2(string s1, string s2){ sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); unsigned int pos = 0; bool matches = true; while (pos < s1.length() && matches){ if (s1[pos] == s2[pos]){ pos = pos + 1; } else{ matches = false; } } return matches; } int main(){ bool value = anagramsolution2(\"abcde\", \"edcba\"); cout << value << endl; return 0; }     # sorts anagrams in order from a-z, and then compares them def anagramSolution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos < len(s1) and matches: if alist1[pos]==alist2[pos]: pos = pos + 1 else: matches = False return matches def main(): print(anagramSolution2('abcde','edcba')) main()     At first glance you may be tempted to think that this algorithm is , since there are three consecutive simple iterations: the first two to convert strings to char arrays and the last to compare the n characters after the sorting process. However, the two calls to the C++ sort function are not without their own cost. As we will see in a later chapter, sorting is typically either or , so the sorting operations dominate the iteration. In the end, this algorithm will have the same order of magnitude as that of the sorting process.    Solution 3: Brute Force  A brute force brute force technique for solving a problem typically tries to exhaust all possibilities. For the anagram detection problem, we can simply generate an array of all possible strings using the characters from s1 and then see if s2 occurs. However, there is a difficulty with this approach. When generating all possible strings from s1 , there are n possible first characters, possible characters for the second position, for the third, and so on. The total number of candidate strings is , which is . Although some of the strings may be duplicates, the program cannot know this ahead of time and so it will still generate different strings.  It turns out that grows even faster than as n gets large. In fact, if s1 were 20 characters long, there would be possible candidate strings. If we processed one possibility every second, it would take us 77,146,816,596 years to go through the entire array. This is probably not going to be a good solution.    Solution 4: Count and Compare  Our final solution to the anagram problem takes advantage of the fact that any two anagrams will have the same number of a's, the same number of b's, the same number of c's, and so on. In order to decide whether two strings are anagrams, we will first count the number of times each character occurs. Since there are 26 possible characters, we can use an array of 26 counters, one for each possible character. Each time we see a particular character, we will increment the counter at that position. In the end, if the two arrays of counters are identical, the strings must be anagrams. shows this solution.     #include <iostream> #include <string> using namespace std; \/\/ uses an array to count the number of a ocurrences of the two inputs \/\/ if the number of occurrences is the same then the input is an anagram bool anagramSolution4(string s1, string s2){ int c1[26] = {0}; int c2[26] = {0}; int x; int a = 'a'; for (unsigned int i = 0; i < s1.length(); i++){ x = s1[i] - a; int pos = x; c1[pos] = c1[pos] + 1; } int y; int b = 'a'; for (unsigned int i = 0; i < s2.length(); i++){ y = s2[i] - b; int pos = y; c2[pos] = c2[pos] + 1; } int j = 0; bool stillOK = true; while (j < 26 && stillOK){ if (c1[j] == c2[j]){ j = j + 1; } else{ stillOK = false; } } return stillOK; } int main(){ bool value = anagramSolution4(\"apple\", \"pleap\"); cout << value << endl; return 0; }     \"\"\" uses an array to count the number of a ocurrences of the two inputs if the number of occurrences is the same then the input is an anagram \"\"\" def anagramSolution4(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j<26 and stillOK: if c1[j]==c2[j]: j = j + 1 else: stillOK = False return stillOK def main(): print(anagramSolution4('apple','pleap')) main()     Again, the solution has a number of iterations. However, unlike the first solution, none of them are nested. The first two iterations used to count the characters are both based on n . The third iteration, comparing the two arrays of counts, always takes 26 steps since there are 26 possible characters in the strings. Adding it all up gives us steps. That is . We have found a linear order of magnitude algorithm for solving this problem.  Before leaving this example, we need to say something about space requirements. Although the last solution was able to run in linear time, it could only do so by using additional storage to keep the two arrays of character counts. In other words, this algorithm sacrificed space in order to gain time.  This is a common occurrence. On many occasions you will need to make decisions between time and space trade-offs. In this case, the amount of extra space is not significant. However, if the underlying alphabet had millions of characters, there would be more concern. As a computer scientist, when given a choice of algorithms, it will be up to you to determine the best use of computing resources given a particular problem.   Reading Questions   Given the following code fragment, what is its Big-O running time?  int main(){ int test = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < n; j++){ test = test + i * j; } } return 0; }     O(n)    No. In an example like this you want to count the nested loops, especially the loops that are dependent on the same variable, in this case, n.      O(n 2 )    Right! A nested loop like this is O(n 2 ).      O(log n)    No. log n typically is indicated when the problem is iteratively made smaller      O(n 3 )    No. In an example like this you want to count the nested loops. especially the loops that are dependent on the same variable, in this case, n.      Given the following code fragment what is its Big-O running time?  int main(){ int test = 0; for (int i = 0; i < n; i++){ test = test + 1; } for (int j = 0; j < n; j++){ test = test - 1; } return 0; }     O(n)    Right! Even though there are two loops they are not nested. You might think of this as O(2n) but we can ignore the constant 2.      O(n 2 )    No. Be careful, in counting loops you want to look carefully at whether or not the loops are nested.      O(log n)    No. log n typically is indicated when the problem is iteratively made smaller.      O(n 3 )    No. Be careful, in counting loops you want to look carefully at whether or not the loops are nested.      Given the following code fragment what is its Big-O running time?  int main(){ int i = n; int count = 0; while (i > 0){ count = count + 1; i = i \/\/ 2; } return 0; }     O(n)    No. Look carefully at the loop variable i. Notice that the value of i is cut in half each time through the loop. This is a big hint that the performance is better than O(n)      O(n 2 )    No. Check again, is this a nested loop?      O(log n)    Right! The value of i is cut in half each time through the loop so it will only take log n iterations.      O(n 3 )    No. Check again, is this a nested loop?      If an algorithm performing at has the integer 8 as input, what is the worst case scenario for the algorithm?  Correct! That would be 2n, which would be simplified as n. That would be n. Wrong, Try again!       "
},
{
  "id": "lst-anagramsolution",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#lst-anagramsolution",
  "type": "Listing",
  "number": "2.4.1",
  "title": "",
  "body": "   #include <iostream> #include <string> using namespace std; \/\/checks to see if the anagrams have the same number of characters bool anagramsolution1(string s1, string s2){ bool stillOK = true; if (s1.length() != s2.length()) { stillOK = false; return stillOK; } string locals2 = s2; int n = s1.length(); unsigned int pos1 = 0; \/\/ checks to see if all of the letters are the same in both inputs while (pos1 < s1.length() && stillOK){ int pos2 = 0; bool found = false; while (pos2 < n && !found){ if (s1[pos1] == locals2[pos2]){ found = true; } else{ pos2 = pos2 + 1; } } if (found){ locals2[pos2] = '\\0'; } else{ stillOK = false; } pos1 = pos1 + 1; } return stillOK; } int main(){ bool value = anagramsolution1(\"abcd\", \"dcab\"); cout << value << endl; return 0; }     #checks to see if the anagrams have the same number of characters def anagramSolution1(s1,s2): stillOK = True if len(s1) != len(s2): stillOK = False return stillOK lists2 = list(s2) pos1 = 0 # checks to see if all of the letters are the same in both inputs while pos1 < len(s1) and stillOK: pos2 = 0 found = False while pos2 < len(lists2) and not found: if s1[pos1] == lists2[pos2]: found = True else: pos2 = pos2 + 1 if found: lists2[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK def main(): print(anagramSolution1('abcd','dcba')) main()    "
},
{
  "id": "lst_ana2",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#lst_ana2",
  "type": "Listing",
  "number": "2.4.2",
  "title": "",
  "body": "   #include <iostream> #include <string> #include <algorithm> using namespace std; \/\/ sorts anagrams in order from a-z, and then compares them bool anagramsolution2(string s1, string s2){ sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); unsigned int pos = 0; bool matches = true; while (pos < s1.length() && matches){ if (s1[pos] == s2[pos]){ pos = pos + 1; } else{ matches = false; } } return matches; } int main(){ bool value = anagramsolution2(\"abcde\", \"edcba\"); cout << value << endl; return 0; }     # sorts anagrams in order from a-z, and then compares them def anagramSolution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos < len(s1) and matches: if alist1[pos]==alist2[pos]: pos = pos + 1 else: matches = False return matches def main(): print(anagramSolution2('abcde','edcba')) main()    "
},
{
  "id": "algorithm-analysis_solution-3-brute-force-2",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#algorithm-analysis_solution-3-brute-force-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "brute force "
},
{
  "id": "lst_ana4",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#lst_ana4",
  "type": "Listing",
  "number": "2.4.3",
  "title": "",
  "body": "   #include <iostream> #include <string> using namespace std; \/\/ uses an array to count the number of a ocurrences of the two inputs \/\/ if the number of occurrences is the same then the input is an anagram bool anagramSolution4(string s1, string s2){ int c1[26] = {0}; int c2[26] = {0}; int x; int a = 'a'; for (unsigned int i = 0; i < s1.length(); i++){ x = s1[i] - a; int pos = x; c1[pos] = c1[pos] + 1; } int y; int b = 'a'; for (unsigned int i = 0; i < s2.length(); i++){ y = s2[i] - b; int pos = y; c2[pos] = c2[pos] + 1; } int j = 0; bool stillOK = true; while (j < 26 && stillOK){ if (c1[j] == c2[j]){ j = j + 1; } else{ stillOK = false; } } return stillOK; } int main(){ bool value = anagramSolution4(\"apple\", \"pleap\"); cout << value << endl; return 0; }     \"\"\" uses an array to count the number of a ocurrences of the two inputs if the number of occurrences is the same then the input is an anagram \"\"\" def anagramSolution4(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j<26 and stillOK: if c1[j]==c2[j]: j = j + 1 else: stillOK = False return stillOK def main(): print(anagramSolution4('apple','pleap')) main()    "
},
{
  "id": "analysis_1",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#analysis_1",
  "type": "Reading Question",
  "number": "2.4.4.1",
  "title": "",
  "body": " Given the following code fragment, what is its Big-O running time?  int main(){ int test = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < n; j++){ test = test + i * j; } } return 0; }     O(n)    No. In an example like this you want to count the nested loops, especially the loops that are dependent on the same variable, in this case, n.      O(n 2 )    Right! A nested loop like this is O(n 2 ).      O(log n)    No. log n typically is indicated when the problem is iteratively made smaller      O(n 3 )    No. In an example like this you want to count the nested loops. especially the loops that are dependent on the same variable, in this case, n.    "
},
{
  "id": "analysis_2",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#analysis_2",
  "type": "Reading Question",
  "number": "2.4.4.2",
  "title": "",
  "body": " Given the following code fragment what is its Big-O running time?  int main(){ int test = 0; for (int i = 0; i < n; i++){ test = test + 1; } for (int j = 0; j < n; j++){ test = test - 1; } return 0; }     O(n)    Right! Even though there are two loops they are not nested. You might think of this as O(2n) but we can ignore the constant 2.      O(n 2 )    No. Be careful, in counting loops you want to look carefully at whether or not the loops are nested.      O(log n)    No. log n typically is indicated when the problem is iteratively made smaller.      O(n 3 )    No. Be careful, in counting loops you want to look carefully at whether or not the loops are nested.    "
},
{
  "id": "analysis_3",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#analysis_3",
  "type": "Reading Question",
  "number": "2.4.4.3",
  "title": "",
  "body": " Given the following code fragment what is its Big-O running time?  int main(){ int i = n; int count = 0; while (i > 0){ count = count + 1; i = i \/\/ 2; } return 0; }     O(n)    No. Look carefully at the loop variable i. Notice that the value of i is cut in half each time through the loop. This is a big hint that the performance is better than O(n)      O(n 2 )    No. Check again, is this a nested loop?      O(log n)    Right! The value of i is cut in half each time through the loop so it will only take log n iterations.      O(n 3 )    No. Check again, is this a nested loop?    "
},
{
  "id": "analysis_4",
  "level": "2",
  "url": "algorithm-analysis_an-anagram-detection-example.html#analysis_4",
  "type": "Reading Question",
  "number": "2.4.4.4",
  "title": "",
  "body": " If an algorithm performing at has the integer 8 as input, what is the worst case scenario for the algorithm?  Correct! That would be 2n, which would be simplified as n. That would be n. Wrong, Try again! "
},
{
  "id": "algorithm-analysis_performance-of-c-data-collections",
  "level": "1",
  "url": "algorithm-analysis_performance-of-c-data-collections.html",
  "type": "Section",
  "number": "2.5",
  "title": "Performance of C++ Data Collections",
  "body": " Performance of C++ Data Collections  Now that you have a general idea of Big-O notation and the differences between the different functions, our goal in this section is to tell you about the Big-O performance for the operations on C++ data structures such as vectors, strings, and hash tables. We will also show you some timing experiments that illustrate the costs and benefits of using certain operations on each data structure. It is important for you to understand the efficiency of these C++ data structures because they are the building blocks we will use as we implement other data structures in the remainder of the book. In this section we are not going to explain why the performance is what it is. In later chapters you will see some possible implementations of both arrays and hash tables and how the performance depends on the implementation.     "
},
{
  "id": "algorithm-analysis_analysis-of-array-and-vector-operators",
  "level": "1",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html",
  "type": "Section",
  "number": "2.6",
  "title": "Analysis of Array and Vector Operators",
  "body": " Analysis of Array and Vector Operators  As we know, vectors vectors use contiguous contiguous storage locations in an underlying (typically larger) array. Both array and vector elements can be accessed and traversed with the help of iterators, and they can also be accessed randomly using indexes.  However, unlike basic arrays, vectors have a dynamic size dynamic size meaning that whenever a new element is inserted or deleted, their size changes automatically. A new element can be inserted into or deleted from any part of a vector, and automatic reallocation for other existing items in the vector is applied. Nevertheless, computing time for insertion and deletion might differ depending on the location of the item, and how many items need to be reallocated. For example, the last item in a vector is typically removed at a constant time, because no resizing of the vector is typically needed for this operation, while an item is removed or inserted into the beginning or the middle of a vector at a linear time because all of the remaining items to the right of that element must be shifted.  Two common operations for both arrays and vectors are indexing and assigning to an index position that already exists. Both of these operations take the same amount of time no matter how large the array or vector is. When an operation like this is independent of the size of the array or vector they are .  Although not possible with basic arrays, a common programming technique is growing a vector. As we have seen, one way to create a longer vector is to use the push_back() method. The push_back() method is typically , provided there is adequate capacity in the underlying array.  First we'll use push_back() method. shows the code for making our vector.   Using push_back()  #include <iostream> #include <vector> using namespace std; void test1(int num){ vector <int> vect; vect.reserve(num); for (int i = 0; i < num; i++){ vect.push_back(i); } } int main() { test1(1000); }   To capture the time it takes for each of our functions to execute we will use C++'s ctime module. The ctime module is designed to allow C++ developers to make cross-platform timing measurements by running functions in a consistent environment and using timing mechanisms that are as similar as possible across operating systems.  To use ctime you create two clock objects. The first clock object marks the current start time; the second clock object marks the current time after the function runs a set number of times (the end time). To get the total runtime, you subtract the end time from the start time to get the elapsed time. The following session shows how long it takes to run each of our test functions 10,000 times within a for loop.   Timing push_back()  #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector \"push_back()\" operation void test1(int num){ vector<int> vect; for (int i = 0; i < num; i++){ vect.push_back(i); } } int main(){ int numruns = 10000; clock_t begin_t1 = clock(); for (int i = 0; i < numruns; i++){ test1(numruns); } clock_t end_t1 = clock(); double elapsed_secs = double(end_t1 - begin_t1) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"push_back \" << elapsed_secs << \" milliseconds\" << endl; return 0; }   In the experiment above the statement that we are timing is the function call to test1 . From the experiment, we see the amount of time taken by the push_back operation. Not only is the push_back() function call duration being measured, but the time to allocate space is being measured.  We can improve the runtime a bit further by setting an adequate reserve for the vector in advance. Doing this will keep us from having to move the entire vector to an adequately sized space in memory.   Reserved Versus Unreserved push_back()  #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector push_back() operation \"reserved\" versus \"unreserved\" void test1(int num){ vector<int> vect; \/\/ no reserve set for (int i = 0; i < num; i++){ vect.push_back(i); } } void test2(int num){ vector<int> vect2; vect2.reserve(num); for (int i = 0; i < num; i++){ vect2.push_back(i); } } int main(){ int numruns = 10000; clock_t begin_t1 = clock(); for (int i = 0; i < numruns; i++){ test1(numruns); } clock_t end_t1 = clock(); double elapsed_secs1 = double(end_t1 - begin_t1) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"unreserved push_back \" << elapsed_secs1 << \" milliseconds\" << endl; clock_t begin_t2 = clock(); for (int i = 0; i < numruns; i++){ test2(numruns); } clock_t end_t2 = clock(); double elapsed_secs2 = double(end_t2 - begin_t2) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"reserved push_back \" << elapsed_secs2 << \" milliseconds\" << endl; return 0; }   Now that we have seen how performance can be measured concretely you can look at to see the Big-O efficiency of all the basic vector operations. When pop_back() is called, the element at the end of the vector is removed and it typically takes but when erase() is called on the first element in the vector or anywhere in the middle it is . The reason for this lies in how C++ chooses to implement vectors. When an item is taken from the front of the vector, in C++ implementation, all the other elements in the vector are shifted one position closer to the beginning. This may seem silly to you now, but if you look at you will see that this implementation also allows the index operation to be . This is a tradeoff that the C++ implementers thought was a good one.   Big-O Efficiency of C++ Vector Operators   Operation  Big-O Efficiency    index []  O(1)    index assignment =  O(1)    push_back()  typically O(1)    pop_back()  O(1)    erase(i)  O(n)    insert(i, item)  O(n)    find(srt, stp, item)  O(log n) or O(n)    reserve()  O(n)    begin()  O(1)    end()  O(1)    size()  O(1)    The push_back() operation is unless there is inadequate capacity, in which case the entire vector is moved to a larger contiguous underlying array, which is .  Note that the vector class provides a find operation which can determine whether a given item is in the vector. It is if the vector is sorted and is otherwise. We will explain why this is in .  As a way of demonstrating the difference in performance between push_back and insert , let's do another experiment using the ctime module. Our goal is to be able to verify the performance of the pop_back() operation on a vector of a known size when the program pops from the end of the vector using pop_back() , and again when the program pops from the beginning of the vector using erase() . We will also want to measure this time for vectors of different sizes. What we would expect to see is that the time required to pop from the end of the vector will stay constant even as the vector grows in size, while the time to pop from the beginning of the vector will continue to increase as the vector grows.  shows one attempt to measure the difference between the pop_back() and erase() .  There are a couple of things to notice about . This approach allows us to time just the single pop_back() statement and get the most accurate measure of the time for that single operation. Because the timer repeats 10,000 times it is also important to point out that the vector is decreasing in size by 1 each time through the loop.   Timing of push_back Versus erase   #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector \"pop_back()\" operation versus the vector \"erase\" operation int main(){ int num = 10000; vector<int> vect; vector<int> vect2; vect.reserve(num); vect2.reserve(num); for (int i = 0; i < num; i++){ vect.push_back(i); } for (int i = 0; i < num; i++){ vect2.push_back(i); } clock_t begin = clock(); for (int i = 0; i < num; i++){ vect.erase(vect.begin()+0); } clock_t end = clock(); double elapsed_secs = double(end - begin) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"popzero = \" << elapsed_secs << endl; clock_t begin2 = clock(); for (int i = 0; i < num; i++){ vect2.pop_back(); } clock_t end2 = clock(); double elapsed_secs2 = double(end2 - begin2) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"popend = \" << elapsed_secs2 << endl; cout << \"\\nPopping from the end is \" << elapsed_secs\/elapsed_secs2 <<\" times faster.\" << endl; return 0; }     Reading Question  Drag the operation(s) on the left to their corresponding Big(O) Review operations and thier Big(O) begin(), end(), size(), index [], index assignment = ,push_back(), pop_back() O(1) reserve(), erase(i), insert(i, item),find(srt, stp, item) O(n) find(srt, stp, item) O(log n)      "
},
{
  "id": "algorithm-analysis_analysis-of-array-and-vector-operators-2",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#algorithm-analysis_analysis-of-array-and-vector-operators-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "vectors contiguous "
},
{
  "id": "algorithm-analysis_analysis-of-array-and-vector-operators-3",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#algorithm-analysis_analysis-of-array-and-vector-operators-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "dynamic size "
},
{
  "id": "ls_mkvectcpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#ls_mkvectcpp",
  "type": "Listing",
  "number": "2.6.1",
  "title": "",
  "body": " Using push_back()  #include <iostream> #include <vector> using namespace std; void test1(int num){ vector <int> vect; vect.reserve(num); for (int i = 0; i < num; i++){ vect.push_back(i); } } int main() { test1(1000); }  "
},
{
  "id": "lst-vectcpp2",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#lst-vectcpp2",
  "type": "Listing",
  "number": "2.6.2",
  "title": "",
  "body": " Timing push_back()  #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector \"push_back()\" operation void test1(int num){ vector<int> vect; for (int i = 0; i < num; i++){ vect.push_back(i); } } int main(){ int numruns = 10000; clock_t begin_t1 = clock(); for (int i = 0; i < numruns; i++){ test1(numruns); } clock_t end_t1 = clock(); double elapsed_secs = double(end_t1 - begin_t1) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"push_back \" << elapsed_secs << \" milliseconds\" << endl; return 0; }  "
},
{
  "id": "lst-vectcpp3",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#lst-vectcpp3",
  "type": "Listing",
  "number": "2.6.3",
  "title": "",
  "body": " Reserved Versus Unreserved push_back()  #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector push_back() operation \"reserved\" versus \"unreserved\" void test1(int num){ vector<int> vect; \/\/ no reserve set for (int i = 0; i < num; i++){ vect.push_back(i); } } void test2(int num){ vector<int> vect2; vect2.reserve(num); for (int i = 0; i < num; i++){ vect2.push_back(i); } } int main(){ int numruns = 10000; clock_t begin_t1 = clock(); for (int i = 0; i < numruns; i++){ test1(numruns); } clock_t end_t1 = clock(); double elapsed_secs1 = double(end_t1 - begin_t1) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"unreserved push_back \" << elapsed_secs1 << \" milliseconds\" << endl; clock_t begin_t2 = clock(); for (int i = 0; i < numruns; i++){ test2(numruns); } clock_t end_t2 = clock(); double elapsed_secs2 = double(end_t2 - begin_t2) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"reserved push_back \" << elapsed_secs2 << \" milliseconds\" << endl; return 0; }  "
},
{
  "id": "algorithm_analysis_algorithm_analysis_tbl_vectbigocpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#algorithm_analysis_algorithm_analysis_tbl_vectbigocpp",
  "type": "Table",
  "number": "2.6.4",
  "title": "",
  "body": " Big-O Efficiency of C++ Vector Operators   Operation  Big-O Efficiency    index []  O(1)    index assignment =  O(1)    push_back()  typically O(1)    pop_back()  O(1)    erase(i)  O(n)    insert(i, item)  O(n)    find(srt, stp, item)  O(log n) or O(n)    reserve()  O(n)    begin()  O(1)    end()  O(1)    size()  O(1)   "
},
{
  "id": "lst_popmeascpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#lst_popmeascpp",
  "type": "Listing",
  "number": "2.6.5",
  "title": "",
  "body": " Timing of push_back Versus erase   #include <iostream> #include <vector> using namespace std; \/\/Tests the time of the vector \"pop_back()\" operation versus the vector \"erase\" operation int main(){ int num = 10000; vector<int> vect; vector<int> vect2; vect.reserve(num); vect2.reserve(num); for (int i = 0; i < num; i++){ vect.push_back(i); } for (int i = 0; i < num; i++){ vect2.push_back(i); } clock_t begin = clock(); for (int i = 0; i < num; i++){ vect.erase(vect.begin()+0); } clock_t end = clock(); double elapsed_secs = double(end - begin) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"popzero = \" << elapsed_secs << endl; clock_t begin2 = clock(); for (int i = 0; i < num; i++){ vect2.pop_back(); } clock_t end2 = clock(); double elapsed_secs2 = double(end2 - begin2) \/CLOCKS_PER_SEC; cout << fixed << endl; cout << \"popend = \" << elapsed_secs2 << endl; cout << \"\\nPopping from the end is \" << elapsed_secs\/elapsed_secs2 <<\" times faster.\" << endl; return 0; }   "
},
{
  "id": "matching_VectorBO",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-array-and-vector-operators.html#matching_VectorBO",
  "type": "Reading Question",
  "number": "2.6.1",
  "title": "",
  "body": "Drag the operation(s) on the left to their corresponding Big(O) Review operations and thier Big(O) begin(), end(), size(), index [], index assignment = ,push_back(), pop_back() O(1) reserve(), erase(i), insert(i, item),find(srt, stp, item) O(n) find(srt, stp, item) O(log n) "
},
{
  "id": "algorithm-analysis_analysis-of-string-operators",
  "level": "1",
  "url": "algorithm-analysis_analysis-of-string-operators.html",
  "type": "Section",
  "number": "2.7",
  "title": "Analysis of String Operators",
  "body": " Analysis of String Operators  Prior to C++11 the string class was not required to store its character elements contiguously. Now string acts much like the vector class, except for some string optimizations and other minor differences.  C++11 strings use contiguous storage locations in an underlying (typically larger) array just like vectors do. Due to this, the character elements in strings can be accessed and traversed with the help of iterators, and they can also be accessed randomly using indexes.  Like vectors, strings have a dynamic size meaning that whenever a new character is inserted or deleted, their size changes automatically. Just like vectors, new elements can be inserted into or deleted from any part of a string, and automatic reallocation for other existing items in the string is applied.  Indexing and assigning a new character to an index position that already exists both take , the same amount of time no matter how large the string is.  Now that we have seen how performance can be measured concretely you can look at to see the Big-O efficiency of all the basic string operations and you will see a striking resemblance to vectors because the implementations are so similar.   Big-O Efficiency of C++ String Operations   Operation  Big-O Efficiency    index []  O(1)    index assignment =  O(1)    push_back()  typically O(1)    pop_back()  O(1)    erase(i)  O(n)    insert(i, item)  O(n)    find(srt, stp, item)  O(log n) or O(n)    reserve()  O(n)    begin()  O(1)    end()  O(1)    size() O(1)    Just like vectors, the push_back() operation is unless there is inadequate capacity, in which case the entire string is moved to a larger contiguous underlying array, which is .     "
},
{
  "id": "algorithm-analysis_tbl-strbigocpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-string-operators.html#algorithm-analysis_tbl-strbigocpp",
  "type": "Table",
  "number": "2.7.1",
  "title": "",
  "body": " Big-O Efficiency of C++ String Operations   Operation  Big-O Efficiency    index []  O(1)    index assignment =  O(1)    push_back()  typically O(1)    pop_back()  O(1)    erase(i)  O(n)    insert(i, item)  O(n)    find(srt, stp, item)  O(log n) or O(n)    reserve()  O(n)    begin()  O(1)    end()  O(1)    size() O(1)   "
},
{
  "id": "algorithm-analysis_analysis-of-hash-tables",
  "level": "1",
  "url": "algorithm-analysis_analysis-of-hash-tables.html",
  "type": "Section",
  "number": "2.8",
  "title": "Analysis of Hash Tables",
  "body": " Analysis of Hash Tables  The second major C++ data structure to analyze is the hash table hash table or hash map. As you may recall, hash tables differ from vectors in that you access items in a hash table by a key rather than a position. A hash table (hash map) is a data structure that maps keys to their associated values using a hash function. The underlying structure is a mostly empty array, but unlike the array or vector data structures, the hash table values are not stored contiguously. The hash function computes an index into the array of buckets from which the correct associated value can be located. Ideally, the hash table values are distributed uniformly in the underlying array and, again ideally, the hash function will assign each key to a unique bucket. However, most hash tables are designed to handle hash collisions when the hash function generates the same bucket index for more than one key. More about this when we discuss implementations in more depth.  Later in this book you will see that there are many ways to implement a hash table. The thing that is most important to note now is that the get item and set item operations on a hash table are . Another important hash table operation is the contains operation. Unlike a vector, checking to see whether a value is in the hash table or not is also .  The efficiency of all hash table operations is summarized in . One important side note on hash table performance is that the efficiencies we provide in the table below are for average performance. In some rare cases the contains , get item , and set item operations can degenerate into performance but we will get into that in a later chapter when we talk about the different ways that a hash table could be implemented.   Big-O Efficiency of C++ hash table Operations   operation  Big-O Efficiency    find  O(1)    insert  O(1)    erase  O(1)    contains  O(1)    iteration  O(n)    Note that it is not typical to iterate through a hash table because it is a data structure designed for look-up, not for iteration. The big advantage of the hash table is the constant speed of the contains operation.  For our last performance experiment we will compare the performance of the contains operation between vectors and hash tables. In the process we will confirm that the contains operator for vectors is and the contains operator for hash tables is . The experiment we will use to compare the two is simple. We'll make a vector with a range of numbers in it. Then we will pick numbers at random and check to see if the numbers are in the vector. If our performance tables are correct the bigger the vector the longer it should take to determine if any one number is contained in the vector.  We will repeat the same experiment for a hash table that contains numbers as the keys. In this experiment we should see that determining whether or not a number is in the hash table is not only much faster, but the time it takes to check should remain constant even as the hash table grows larger.  Listing 6 implements this comparison. Notice that we are performing exactly the same operation, number in container . The difference is that on line 7 x is vector, and on line 9 x is a hash table.  Listing 6  #include <iostream> #include <ctime> #include <vector> #include <unordered_map> using namespace std; int main() { for(int a = 10000; a < 1000001; a = a + 20000) { \/\/ vector Part clock_t begin = clock(); vector<int> avector; for( int i = 0; i < a; i++){ avector.push_back(i); } clock_t end = clock(); double elapsed_secs = double(end - begin) \/ CLOCKS_PER_SEC; \/\/ Hash Table Part clock_t begin_ht = clock(); unordered_map<int, int> y; for( int j = 0; j < a; j++ ){ y[j] = NULL; } clock_t end_ht = clock(); double elapsed_secs_ht = double(end_ht - begin_ht) \/ CLOCKS_PER_SEC; \/\/ Printing final output cout << a << \"\\t\" << elapsed_secs << \"\\t\" << elapsed_secs_ht << endl; } return 0; }  import timeit import random for i in range(10000,1000001,20000): t = timeit.Timer(\"random.randrange(%d) in x\"%i, \"from __main__ import random,x\") x = list(range(i)) lst_time = t.timeit(number=1000) x = {j:None for j in range(i)} d_time = t.timeit(number=1000) print(\"%d,%10.3f,%10.3f\" % (i, lst_time, d_time))  summarizes the results of running Listing 6 . You can see that the hash table is consistently faster. For the smallest vector size of 10,000 elements a hash table is 89.4 times faster than a vector. For the largest vector size of 990,000 elements the hash table is 11,603 times faster! You can also see that the time it takes for the contains operator on the vector grows linearly with the size of the vector. This verifies the assertion that the contains operator on a vector is . It can also be seen that the time for the contains operator on a hash table is constant even as the hash table size grows. In fact for a hash table size of 10,000 the contains operation took 0.004 milliseconds and for the hash table size of 990,000 it also took 0.004 milliseconds.   Comparing the in Operator for C++ vectors and Hash Tables   Figure 3 summarizes the results of running Listing 6. You can see that the hash table is consistently faster. For the smallest vector size of 10,000 elements a hash table is 89.4 times faster than a vector. For the largest vector size of 990,000 elements the hash table is 11,603 times faster! You can also see that the time it takes for the contains operator on the vector grows linearly with the size of the vector. This verifies the assertion that the contains operator on a vector is . It can also be seen that the time for the contains operator on a hash table is constant even as the hash table size grows. In fact for a hash table size of 10,000 the contains operation took 0.004 milliseconds and for the hash table size of 990,000 it also took 0.004 milliseconds.    Since C++ is an evolving language, there are always changes going on behind the scenes. The latest information on the performance of C++ data structures can be found on the C++ website.   Reading Questions   Which of the vector operations shown below is not O(1)?     Popping the first index from a vector    When you remove the first element of a vector, all the other elements of the vector must be shifted forward.      Popping an element from the end of a vector    Removing an element from the end of the vector is a constant operation.      Adding a new element to a vector    Adding to the end of a vector is a constant operation      vector[10]    Indexing a vector is a constant operation      all of the above are O(1)    There is one operation that requires all other vector elements to be moved.      Which of the hash table operations shown below is O(1)?     mymap.count('x')    count is a constant operation for a hash table because you do not have to iterate but there is a better answer.      mymap.erase('x')    removing an element from a hash table is a constant operation but there is a better answer.      mymap['x'] = 10;    Assignment to a hash table key is constant but there is a better answer.      mymap['x'] = mymap['x'] + 1;    Re-assignment to a hash table key is constant but there is a better answer.      all of the above are O(1)    The only hash table operations that are not O(1) are those that require iteration.      What is an operator for hash tables with an efficiency other than O(1)?     erase    The efficiency of erase in hash tables is constant.      insert    The efficiency of insert in hash tables is constant.      iteration    Correct!      contains    The efficiency of contains in hash tables is constant.      find    The efficiency of find in hash tables is constant.          "
},
{
  "id": "algorithm-analysis_analysis-of-hash-tables-2",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#algorithm-analysis_analysis-of-hash-tables-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hash table "
},
{
  "id": "algorithm-analysis_analysis-of-hash-tables-3",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#algorithm-analysis_analysis-of-hash-tables-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "contains "
},
{
  "id": "algorithm-analysis_analysis-of-hash-tables-4",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#algorithm-analysis_analysis-of-hash-tables-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "contains get item set item "
},
{
  "id": "algorithm-analysis_tbl-hashbigo-cpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#algorithm-analysis_tbl-hashbigo-cpp",
  "type": "Table",
  "number": "2.8.1",
  "title": "",
  "body": " Big-O Efficiency of C++ hash table Operations   operation  Big-O Efficiency    find  O(1)    insert  O(1)    erase  O(1)    contains  O(1)    iteration  O(n)   "
},
{
  "id": "algorithm-analysis_analysis-of-hash-tables-10",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#algorithm-analysis_analysis-of-hash-tables-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 6 "
},
{
  "id": "fig-vectvshash-cpp",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#fig-vectvshash-cpp",
  "type": "Figure",
  "number": "2.8.2",
  "title": "",
  "body": " Comparing the in Operator for C++ vectors and Hash Tables   Figure 3 summarizes the results of running Listing 6. You can see that the hash table is consistently faster. For the smallest vector size of 10,000 elements a hash table is 89.4 times faster than a vector. For the largest vector size of 990,000 elements the hash table is 11,603 times faster! You can also see that the time it takes for the contains operator on the vector grows linearly with the size of the vector. This verifies the assertion that the contains operator on a vector is . It can also be seen that the time for the contains operator on a hash table is constant even as the hash table size grows. In fact for a hash table size of 10,000 the contains operation took 0.004 milliseconds and for the hash table size of 990,000 it also took 0.004 milliseconds.   "
},
{
  "id": "mccppmapperfcpp3",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#mccppmapperfcpp3",
  "type": "Reading Question",
  "number": "2.8.1",
  "title": "",
  "body": " Which of the vector operations shown below is not O(1)?     Popping the first index from a vector    When you remove the first element of a vector, all the other elements of the vector must be shifted forward.      Popping an element from the end of a vector    Removing an element from the end of the vector is a constant operation.      Adding a new element to a vector    Adding to the end of a vector is a constant operation      vector[10]    Indexing a vector is a constant operation      all of the above are O(1)    There is one operation that requires all other vector elements to be moved.    "
},
{
  "id": "mccppmapperfcpp4",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#mccppmapperfcpp4",
  "type": "Reading Question",
  "number": "2.8.2",
  "title": "",
  "body": " Which of the hash table operations shown below is O(1)?     mymap.count('x')    count is a constant operation for a hash table because you do not have to iterate but there is a better answer.      mymap.erase('x')    removing an element from a hash table is a constant operation but there is a better answer.      mymap['x'] = 10;    Assignment to a hash table key is constant but there is a better answer.      mymap['x'] = mymap['x'] + 1;    Re-assignment to a hash table key is constant but there is a better answer.      all of the above are O(1)    The only hash table operations that are not O(1) are those that require iteration.    "
},
{
  "id": "manswer_shtBO",
  "level": "2",
  "url": "algorithm-analysis_analysis-of-hash-tables.html#manswer_shtBO",
  "type": "Reading Question",
  "number": "2.8.3",
  "title": "",
  "body": " What is an operator for hash tables with an efficiency other than O(1)?     erase    The efficiency of erase in hash tables is constant.      insert    The efficiency of insert in hash tables is constant.      iteration    Correct!      contains    The efficiency of contains in hash tables is constant.      find    The efficiency of find in hash tables is constant.    "
},
{
  "id": "algorithmanalysis_algorithm-analysis_summary",
  "level": "1",
  "url": "algorithmanalysis_algorithm-analysis_summary.html",
  "type": "Section",
  "number": "2.9",
  "title": "Summary",
  "body": " Summary     Algorithm analysis is an implementation-independent way of measuring an algorithm.    Big-O notation allows algorithms to be classified by their dominant process with respect to the size of the problem.        "
},
{
  "id": "algorithmanalysis_algorithm-analysis_self-check",
  "level": "1",
  "url": "algorithmanalysis_algorithm-analysis_self-check.html",
  "type": "Section",
  "number": "2.10",
  "title": "Self Check",
  "body": " Self Check   Q-1: Which of the following algorithms has the least efficient big O complexity?     10000(n 3 + n 2 )    Incorrect, even though n 3 is the most significant part for all of these formulas, the way it interacts with the rest of the equation is also important to note.      45n 3 + 1710n 2 + 16n + 5    Incorrect, even though n 3 is the most significant part for all of these formulas, the way it interacts with the rest of the equation is also important to note.      (n 3 + n) (n 2 + 1)    Correct!      A and B would be equally efficient\/inefficient    Look closer, the efficiencies would be different      Drag the order of growth rates to their rankings from lowest to highest (the slowest i.e. the highest growth rate should be #1)   Compare the functions at different values to see how they compare    2 n  1st    n 2  2nd    nlogn  3rd    logn  4th     Q-3: When considering computer resources, what factors do we have in mind? Select all that apply.     language constraints    No, we do not consider the restraints of a language when thinking about how efficient an algorithm is.      Space    Yes, we consider how much space we need to solve a problem.      Time    Yes, we consider how much time it takes to solve a problem      Energy    No, we do not consider how much energy it takes at this point.      Q-4: When considering the Big O of an algorithm, what do we use to quantify our description of an algorithm.     the space it takes    This can be dependent of the programming language      the time it takes    This can be dependent on the machine, programming language, and other factors      the number of steps    Yes, when quantifying the time it takes to execute an algorithm we base it on the number of steps it takes to solve the problem, not the time it takes      the readability of the code    No, a very efficient algorithm can be programmed efficiently in C++ without any extra spaces making it unreadable, however the solution would still be efficient.        "
},
{
  "id": "bigOefficiency",
  "level": "2",
  "url": "algorithmanalysis_algorithm-analysis_self-check.html#bigOefficiency",
  "type": "Checkpoint",
  "number": "2.10.1",
  "title": "",
  "body": " Q-1: Which of the following algorithms has the least efficient big O complexity?     10000(n 3 + n 2 )    Incorrect, even though n 3 is the most significant part for all of these formulas, the way it interacts with the rest of the equation is also important to note.      45n 3 + 1710n 2 + 16n + 5    Incorrect, even though n 3 is the most significant part for all of these formulas, the way it interacts with the rest of the equation is also important to note.      (n 3 + n) (n 2 + 1)    Correct!      A and B would be equally efficient\/inefficient    Look closer, the efficiencies would be different    "
},
{
  "id": "growth",
  "level": "2",
  "url": "algorithmanalysis_algorithm-analysis_self-check.html#growth",
  "type": "Checkpoint",
  "number": "2.10.2",
  "title": "",
  "body": " Drag the order of growth rates to their rankings from lowest to highest (the slowest i.e. the highest growth rate should be #1)   Compare the functions at different values to see how they compare    2 n  1st    n 2  2nd    nlogn  3rd    logn  4th   "
},
{
  "id": "resources",
  "level": "2",
  "url": "algorithmanalysis_algorithm-analysis_self-check.html#resources",
  "type": "Checkpoint",
  "number": "2.10.3",
  "title": "",
  "body": " Q-3: When considering computer resources, what factors do we have in mind? Select all that apply.     language constraints    No, we do not consider the restraints of a language when thinking about how efficient an algorithm is.      Space    Yes, we consider how much space we need to solve a problem.      Time    Yes, we consider how much time it takes to solve a problem      Energy    No, we do not consider how much energy it takes at this point.    "
},
{
  "id": "bigO",
  "level": "2",
  "url": "algorithmanalysis_algorithm-analysis_self-check.html#bigO",
  "type": "Checkpoint",
  "number": "2.10.4",
  "title": "",
  "body": " Q-4: When considering the Big O of an algorithm, what do we use to quantify our description of an algorithm.     the space it takes    This can be dependent of the programming language      the time it takes    This can be dependent on the machine, programming language, and other factors      the number of steps    Yes, when quantifying the time it takes to execute an algorithm we base it on the number of steps it takes to solve the problem, not the time it takes      the readability of the code    No, a very efficient algorithm can be programmed efficiently in C++ without any extra spaces making it unreadable, however the solution would still be efficient.    "
},
{
  "id": "algorithm-analysis_discussion-questions",
  "level": "1",
  "url": "algorithm-analysis_discussion-questions.html",
  "type": "Section",
  "number": "2.11",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Give the Big-O performance of the following code fragment:    int count = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < n; j++){ count = count +1; } }    Give the Big-O performance of the following code fragment:    int count = 0; for (int i = 0; i < n; i++){ count = count + 1; }    Give the Big-O performance of the following code fragment:    int i = n; int count = 0; while (i > 0){ count = count + 1; i = i \/ 2; \/\/Note: integer division }    Give the Big-O performance of the following code fragment:    int count = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < n; j++){ for (int k = 0; k < n; k++){ count = count +1; } } }    Give the Big-O performance of the following code fragment:    int count = 0; for (int i = 0; i < n; i++){ count = count + 1; } for (int j = 0; j < n; j++){ count = count + 1; } for (int k = 0; k < n; k++){ count = count + 1; }     "
},
{
  "id": "algorithm-analysis_programming-exercises",
  "level": "1",
  "url": "algorithm-analysis_programming-exercises.html",
  "type": "Section",
  "number": "2.12",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Devise an experiment to verify that the vector index operator is .    Devise an experiment to verify that find and insert are for hash tables.    Devise an experiment that compares the performance of the erase() operator on vectors and hash tables.    Given an array of numbers in random order, write an algorithm that works in to find the kth smallest number in the array.    Can you improve the algorithm from the previous problem to be linear? Explain.       "
},
{
  "id": "algorithm-analysis_glossary",
  "level": "1",
  "url": "algorithm-analysis_glossary.html",
  "type": "Section",
  "number": "2.13",
  "title": "Glossary",
  "body": " Glossary    algorithm  a generic, step-by-step list of instructions for solving a problem.    average case  refers to when an algorithm performs between its worst and best case given a certain data set or circumstance.    best case  refers to when an algorithm performs especially good given a certain data set or circumstance.    Big-O notation  another term for order of magnitude; written as    brute force  technique that tries to exhaust all possibilities of a problem.    contains  A hash operation used to check if a table contains a specific element.    contiguous  adjacent or next to.    dynamic size  able to change size automatically.    exponential  function represented as a number being raised to a power that increases like    get_item  A hash operation used to retrieve the information associated with a hash key.    hash table  a collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.    linear  function that grows in a one to one relationship with its input like    logarithmic  functions that are the inverse of exponential functions usually presented as    order of magnitude  function describing the part that increases the fastest as the value of n increases (a function describing an algorithm's steps as the size of the problem increases).    quadratic  function describing a relationship who's highest order is a number squared. For instance:   simplified:  complex:     set_item  A hash operation used to add an item to your table.    vector  sequence container storing data of a single type that is stored in a dynamically allocated array which can change in size.    worst case  refers to when an algorithm performs especially poorly given a certain data set or circumstance.    Drag the word on the left to its corresponding definition. Review classes and their properties.  algorithm Step-by-step list of instructions for solving a problem.  average case When an algorithm performs between its worst and best case given a certain data set or circumstance.  vector Sequence container storing data of a single type in a dynamically allocated array.  worst case When an algorithm performs especially poorly given a certain data set or circumstance.  dynamic size Able to change size automatically.   Drag the word on the left to its corresponding definition. Review classes and their properties.  quadratic Function describing a relationship who's highest order is a number squared.  best case When an algorithm performs especially good given a certain data set or circumstance.  Big-O notation Another term for order of magnitude.  brute force Technique that tries to exhaust all possibilities of a problem.  contiguous Adjacent.   Drag the word on the left to its corresponding definition. Review classes and their properties.  hash table A collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.  linear Function that grows in a one to one relationship with its input.  logarithmic functions that are the inverse of exponential functions.  order of magnitude a function describing an algorithm's steps as the size of the problem increases.  exponential Function represented as a number being raised to a power that increases.      "
},
{
  "id": "matching_algorithmana0",
  "level": "2",
  "url": "algorithm-analysis_glossary.html#matching_algorithmana0",
  "type": "Checkpoint",
  "number": "2.13.1",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition. Review classes and their properties.  algorithm Step-by-step list of instructions for solving a problem.  average case When an algorithm performs between its worst and best case given a certain data set or circumstance.  vector Sequence container storing data of a single type in a dynamically allocated array.  worst case When an algorithm performs especially poorly given a certain data set or circumstance.  dynamic size Able to change size automatically.  "
},
{
  "id": "matching_algorithmana1",
  "level": "2",
  "url": "algorithm-analysis_glossary.html#matching_algorithmana1",
  "type": "Checkpoint",
  "number": "2.13.2",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition. Review classes and their properties.  quadratic Function describing a relationship who's highest order is a number squared.  best case When an algorithm performs especially good given a certain data set or circumstance.  Big-O notation Another term for order of magnitude.  brute force Technique that tries to exhaust all possibilities of a problem.  contiguous Adjacent.  "
},
{
  "id": "matching_algorithmana2",
  "level": "2",
  "url": "algorithm-analysis_glossary.html#matching_algorithmana2",
  "type": "Checkpoint",
  "number": "2.13.3",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition. Review classes and their properties.  hash table A collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.  linear Function that grows in a one to one relationship with its input.  logarithmic functions that are the inverse of exponential functions.  order of magnitude a function describing an algorithm's steps as the size of the problem increases.  exponential Function represented as a number being raised to a power that increases.  "
},
{
  "id": "algorithmanalysis_algorithm-analysis_matching",
  "level": "1",
  "url": "algorithmanalysis_algorithm-analysis_matching.html",
  "type": "Section",
  "number": "2.14",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition   Review classes and their properties    algorithm  Step-by-step list of instructions for solving a problem.    dynamic size  Able to change size automatically    exponential  Function represented as a number being raised to a power that increases.    hash table  A collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.    linear  Function that grows in a one to one relationship with its input.    logarithmic  functions that are the inverse of exponential functions    order of magnitude  a function describing an algorithm's steps as the size of the problem increases.    average case  When an algorithm performs between its worst and best case given a certain data set or circumstance.    vector  Sequence container storing data of a single type in a dynamically allocated array.    worst case  When an algorithm performs especially poorly given a certain data set or circumstance.    quadratic  Function describing a relationship who's highest order is a number squared    best case  When an algorithm performs especially good given a certain data set or circumstance    Big-O notation  another term for order of magnitude    brute force  Technique that tries to exhaust all possibilities of a problem    contiguous  Adjacent       "
},
{
  "id": "matching_algorithmana",
  "level": "2",
  "url": "algorithmanalysis_algorithm-analysis_matching.html#matching_algorithmana",
  "type": "Checkpoint",
  "number": "2.14.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition   Review classes and their properties    algorithm  Step-by-step list of instructions for solving a problem.    dynamic size  Able to change size automatically    exponential  Function represented as a number being raised to a power that increases.    hash table  A collection consisting of key-value pairs with an associated hash function that maps the key to the associated value.    linear  Function that grows in a one to one relationship with its input.    logarithmic  functions that are the inverse of exponential functions    order of magnitude  a function describing an algorithm's steps as the size of the problem increases.    average case  When an algorithm performs between its worst and best case given a certain data set or circumstance.    vector  Sequence container storing data of a single type in a dynamically allocated array.    worst case  When an algorithm performs especially poorly given a certain data set or circumstance.    quadratic  Function describing a relationship who's highest order is a number squared    best case  When an algorithm performs especially good given a certain data set or circumstance    Big-O notation  another term for order of magnitude    brute force  Technique that tries to exhaust all possibilities of a problem    contiguous  Adjacent   "
},
{
  "id": "linear-basic_objectives",
  "level": "1",
  "url": "linear-basic_objectives.html",
  "type": "Section",
  "number": "3.1",
  "title": "Objectives",
  "body": " Objectives    To understand the abstract data types: stack, queue, and deque.    To be able to use the ADTs (stack, queue, and deque) using Standard Template Library of C++.    To understand the performance of the implementations of basic linear data structures.    To understand prefix, infix, and postfix expression formats.    To use stacks to evaluate postfix expressions.    To use stacks to convert expressions from infix to postfix.    To use queues for basic timing simulations.    To be able to recognize problem properties where stacks, queues, and deques are appropriate data structures.       "
},
{
  "id": "linear-basic_what-are-linear-structures",
  "level": "1",
  "url": "linear-basic_what-are-linear-structures.html",
  "type": "Section",
  "number": "3.2",
  "title": "What Are Linear Structures?",
  "body": " What Are Linear Structures?  linear data structures We will begin our study of data structures by considering four simple but very powerful concepts. Vectors, stacks, queues, deques are examples of data collections whose items are ordered depending on how they are added or removed. Once an item is added, it stays in that position relative to the other elements that came before and came after it. Collections such as these are often referred to as linear data structures .  Linear structures can be thought of as having two ends. Sometimes these ends are referred to as the left and the right or in some cases the front and the rear. You could also call them the top and the bottom. The names given to the ends are not significant. What distinguishes one linear structure from another is the way in which items are added and removed, in particular the location where these additions and removals occur. For example, a structure might allow new items to be added at only one end. Some structures might allow items to be removed from either end.  These variations give rise to some of the most useful data structures in computer science. They appear in many algorithms and can be used to solve a variety of important problems.     "
},
{
  "id": "linear-basic_what-are-linear-structures-2",
  "level": "2",
  "url": "linear-basic_what-are-linear-structures.html#linear-basic_what-are-linear-structures-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "linear data structures "
},
{
  "id": "linear-basic_what-is-a-stack",
  "level": "1",
  "url": "linear-basic_what-is-a-stack.html",
  "type": "Section",
  "number": "3.3",
  "title": "What is a Stack?",
  "body": " What is a Stack?   stack A stack (sometimes called a push-down stack ) is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. This end is commonly referred to as the top. The end opposite the top is known as the base.  The base of the stack is significant since items stored in the stack that are closer to the base represent those that have been in the stack the longest. The most recently added item is the one that is in position to be removed first. This ordering principle is sometimes called LIFO last-in first-out  LIFO , last-in first-out . It provides an ordering based on length of time in the collection. Newer items are near the top, while older items are near the base.  Many examples of stacks occur in everyday situations. Almost any cafeteria has a stack of trays or plates where you take the one at the top, uncovering a new tray or plate for the next customer in line. Imagine a stack of books on a desk ( ). The only book whose cover is visible is the one on top. To access others in the stack, we need to remove the ones that are sitting on top of them. shows another stack.  Figure 1: A Stack of Books  Figure 2: A Stack of Primitive Python Objects  One of the most useful ideas related to stacks comes from the simple observation of items as they are added and then removed. Assume you start out with a clean desktop. Now place books one at a time on top of each other. You are constructing a stack. Consider what happens when you begin removing books. The order that they are removed is exactly the reverse of the order that they were placed. Stacks are fundamentally important, as they can be used to reverse the order of items. The order of insertion is the reverse of the order of removal. shows the stack object as it was created and then again as items are removed. Note the order of the objects.  Figure 3: The Reversal Property of Stacks  Considering this reversal property, you can perhaps think of examples of stacks that occur as you use your computer. For example, every web browser has a Back button. As you navigate from web page to web page, those pages are placed on a stack (actually it is the URLs that are going on the stack). The current page that you are viewing is on the top and the first page you looked at is at the base. If you click on the Back button, you begin to move in reverse order through the pages.   Reading Question   Say we create a stack by pushing numbers 1 to 4 from lowest to highest. What would the stack look like afterwards?   4  3  2  1       "
},
{
  "id": "linear-basic_what-is-a-stack-2",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#linear-basic_what-is-a-stack-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "stack "
},
{
  "id": "linear-basic_what-is-a-stack-3",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#linear-basic_what-is-a-stack-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "LIFO last-in first-out "
},
{
  "id": "fig-bookstack",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#fig-bookstack",
  "type": "Figure",
  "number": "3.3.1",
  "title": "",
  "body": "Figure 1: A Stack of Books "
},
{
  "id": "fig-objectstack",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#fig-objectstack",
  "type": "Figure",
  "number": "3.3.2",
  "title": "",
  "body": "Figure 2: A Stack of Primitive Python Objects "
},
{
  "id": "linear-basic-stack-fig-reversal",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#linear-basic-stack-fig-reversal",
  "type": "Figure",
  "number": "3.3.3",
  "title": "",
  "body": "Figure 3: The Reversal Property of Stacks "
},
{
  "id": "stack_prob",
  "level": "2",
  "url": "linear-basic_what-is-a-stack.html#stack_prob",
  "type": "Reading Question",
  "number": "3.3.1",
  "title": "",
  "body": " Say we create a stack by pushing numbers 1 to 4 from lowest to highest. What would the stack look like afterwards?   4  3  2  1  "
},
{
  "id": "linear-basic_the-stack-abstract-data-type",
  "level": "1",
  "url": "linear-basic_the-stack-abstract-data-type.html",
  "type": "Section",
  "number": "3.4",
  "title": "The Stack Abstract Data Type",
  "body": " stack abstract data type  stack ADT  The Stack Abstract Data Type  The stack abstract data type or stack ADT is defined by the following structure and operations. A stack is structured, as described above, as an ordered collection of items where items are added to and removed from the end called the top. Stacks are ordered LIFO. The stack operations are given below.    stack<datatype> creates a new stack that is empty. It needs no parameters and returns an empty stack. It can only contain a certain type of data. e.g. int , string etc.    push(item) adds a new item to the top of the stack. It needs the item and returns nothing.    pop() removes the top item from the stack. It needs no parameters and returns nothing. The stack is modified.    top() returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.    empty() tests to see whether the stack is empty. It needs no parameters and returns a Boolean value.    size() returns the number of items on the stack. It needs no parameters and returns an integer.    For example, if s is a stack that has been created and starts out empty, then shows the results of a sequence of stack operations. Under stack contents, the top item is listed at the far right.   Sample Stack Operations    Stack Operation    Stack Contents    Return Value      s.empty()    []    1      s.push('horse')    ['horse']        s.push('dog')    ['horse','dog']        s.top()    ['horse','dog']    'dog'      s.push('cat')    ['horse','dog','cat']        s.size()    ['horse','dog','cat']    3      s.empty()    ['horse','dog','cat']    0      s.push('turtle')    ['horse','dog','cat','turtle']        s.pop()    ['horse','dog','cat']        s.pop()    ['horse','dog']        s.size()    ['horse','dog']    2      Reading Question   Which group of data would not make a valid Stack?     's', 't', 'a', 'c', 'k', 's'    No, this is valid for a stack. Check the reading for what types of data a stack can have.      \"Stacks\"    No, a stack can have only one item.      115, 116, 97, 99, 107    No, this is valid for a stack similar to A. Check the reading.      \"St\", 'a', \"ck\", 's'    Yes, stacks should have data of the same type.         "
},
{
  "id": "linear-basic_the-stack-abstract-data-type-4",
  "level": "2",
  "url": "linear-basic_the-stack-abstract-data-type.html#linear-basic_the-stack-abstract-data-type-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "stack abstract data type stack ADT "
},
{
  "id": "linear-basic_tbl-stackops",
  "level": "2",
  "url": "linear-basic_the-stack-abstract-data-type.html#linear-basic_tbl-stackops",
  "type": "Table",
  "number": "3.4.1",
  "title": "",
  "body": " Sample Stack Operations    Stack Operation    Stack Contents    Return Value      s.empty()    []    1      s.push('horse')    ['horse']        s.push('dog')    ['horse','dog']        s.top()    ['horse','dog']    'dog'      s.push('cat')    ['horse','dog','cat']        s.size()    ['horse','dog','cat']    3      s.empty()    ['horse','dog','cat']    0      s.push('turtle')    ['horse','dog','cat','turtle']        s.pop()    ['horse','dog','cat']        s.pop()    ['horse','dog']        s.size()    ['horse','dog']    2    "
},
{
  "id": "stack_datatypes",
  "level": "2",
  "url": "linear-basic_the-stack-abstract-data-type.html#stack_datatypes",
  "type": "Reading Question",
  "number": "3.4.1",
  "title": "",
  "body": " Which group of data would not make a valid Stack?     's', 't', 'a', 'c', 'k', 's'    No, this is valid for a stack. Check the reading for what types of data a stack can have.      \"Stacks\"    No, a stack can have only one item.      115, 116, 97, 99, 107    No, this is valid for a stack similar to A. Check the reading.      \"St\", 'a', \"ck\", 's'    Yes, stacks should have data of the same type.    "
},
{
  "id": "linear-basic_using-a-stack-in-c",
  "level": "1",
  "url": "linear-basic_using-a-stack-in-c.html",
  "type": "Section",
  "number": "3.5",
  "title": "Using a Stack in C++",
  "body": " Using a Stack in C++  Now that we have clearly defined the stack as an abstract data type we will turn our attention to using a stack with the help of the Standard Template Library (STL) in C++. Recall that when we give an abstract data type a physical implementation we refer to the implementation as a data structure.  As we described in Chapter 1, in C++, as in any object-oriented programming language, the implementation of choice for an abstract data type such as a stack is the creation of a new class. The stack operations are implemented as methods. However, the STL already has a well written implementation of the Stack class.  The following stack implementation ( ) assumes that the end of the array will hold the top element of the stack. As the stack grows (as push operations occur), new items will be added on the end of the array. pop operations will manipulate that same end.   C++ Implementation  \/\/Tests the push, empty, size, pop, and top methods of the stack library. #include <iostream> #include <stack> \/\/ Calling Stack from the STL using namespace std; int main() { stack<int> newStack; newStack.push(3); \/\/Adds 3 to the stack newStack.push(8); newStack.push(15); \/\/ returns a boolean response depending on if the stack is empty or not cout << \"Stack Empty? \" << newStack.empty() << endl; \/\/ returns the size of the stack itself cout << \"Stack Size: \" << newStack.size() << endl; \/\/ returns the topmost element of the stack cout << \"Top Element of the Stack: \" << newStack.top() << endl; \/\/ removes the topmost element of the stack newStack.pop(); cout << \"Top Element of the Stack: \" << newStack.top() << endl; cout << \"Stack Size: \" << newStack.size() << endl; return 0; }  Python Implementation  #Tests the push, empty, size, pop, and top methods of the stack library. class Stack: def __init__(self): #initializes new stack instance self.items = [] def isEmpty(self): #returns boolean return self.items == [] def push(self, item): #pushes new item onto stack self.items.append(item) def pop(self): #removes topmost item from stack return self.items.pop() def top(self): #returns the topmost item from the stack return self.items[len(self.items)-1] def size(self): #returns the size of the stack return len(self.items) def main(): newStack = Stack() newStack.push(4) newStack.push(8) newStack.push(15) print(\"Stack Empty? \", newStack.isEmpty()) print(\"Stack Size: \", newStack.size()) print(\"Top Element of the Stack: \", newStack.top()) newStack.pop(); print(\"Top Element of the Stack: \", newStack.top()) main()   Reading Questions   Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?  stack<int> m; m.push(5); m.push(12); m.pop(); m.push(27); cout << m.top();     5    Remember that a stack is built from the bottom up.      12    pay attention to the line that says m.pop();.      27    Good job. This is correct because the 12 was poped of from the end and the 27 was pushed.      The stack is empty    This would mean everyting is removed from the stack, when does that happen?      Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?  stack<int> m; m.push(37); m.push(56); m.push(4); while (!m.empty()){ m.pop(); m.pop(); }     37    You may want to check out the docs for      the stack is empty    There is an odd number of things on the stack but each time through the loop 2 things are popped.      an error will occur    Good Job, this is true because the stack can not evenly pop off every item within itself, because there is an odd number of items.      4    You may want to check out the docs for isEmpty         "
},
{
  "id": "stack-code1",
  "level": "2",
  "url": "linear-basic_using-a-stack-in-c.html#stack-code1",
  "type": "Listing",
  "number": "3.5.1",
  "title": "",
  "body": " C++ Implementation  \/\/Tests the push, empty, size, pop, and top methods of the stack library. #include <iostream> #include <stack> \/\/ Calling Stack from the STL using namespace std; int main() { stack<int> newStack; newStack.push(3); \/\/Adds 3 to the stack newStack.push(8); newStack.push(15); \/\/ returns a boolean response depending on if the stack is empty or not cout << \"Stack Empty? \" << newStack.empty() << endl; \/\/ returns the size of the stack itself cout << \"Stack Size: \" << newStack.size() << endl; \/\/ returns the topmost element of the stack cout << \"Top Element of the Stack: \" << newStack.top() << endl; \/\/ removes the topmost element of the stack newStack.pop(); cout << \"Top Element of the Stack: \" << newStack.top() << endl; cout << \"Stack Size: \" << newStack.size() << endl; return 0; }  Python Implementation  #Tests the push, empty, size, pop, and top methods of the stack library. class Stack: def __init__(self): #initializes new stack instance self.items = [] def isEmpty(self): #returns boolean return self.items == [] def push(self, item): #pushes new item onto stack self.items.append(item) def pop(self): #removes topmost item from stack return self.items.pop() def top(self): #returns the topmost item from the stack return self.items[len(self.items)-1] def size(self): #returns the size of the stack return len(self.items) def main(): newStack = Stack() newStack.push(4) newStack.push(8) newStack.push(15) print(\"Stack Empty? \", newStack.isEmpty()) print(\"Stack Size: \", newStack.size()) print(\"Top Element of the Stack: \", newStack.top()) newStack.pop(); print(\"Top Element of the Stack: \", newStack.top()) main() "
},
{
  "id": "stack_1",
  "level": "2",
  "url": "linear-basic_using-a-stack-in-c.html#stack_1",
  "type": "Reading Question",
  "number": "3.5.1",
  "title": "",
  "body": " Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?  stack<int> m; m.push(5); m.push(12); m.pop(); m.push(27); cout << m.top();     5    Remember that a stack is built from the bottom up.      12    pay attention to the line that says m.pop();.      27    Good job. This is correct because the 12 was poped of from the end and the 27 was pushed.      The stack is empty    This would mean everyting is removed from the stack, when does that happen?    "
},
{
  "id": "stack_2",
  "level": "2",
  "url": "linear-basic_using-a-stack-in-c.html#stack_2",
  "type": "Reading Question",
  "number": "3.5.2",
  "title": "",
  "body": " Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?  stack<int> m; m.push(37); m.push(56); m.push(4); while (!m.empty()){ m.pop(); m.pop(); }     37    You may want to check out the docs for      the stack is empty    There is an odd number of things on the stack but each time through the loop 2 things are popped.      an error will occur    Good Job, this is true because the stack can not evenly pop off every item within itself, because there is an odd number of items.      4    You may want to check out the docs for isEmpty    "
},
{
  "id": "linear-basic_simple-balanced-parentheses",
  "level": "1",
  "url": "linear-basic_simple-balanced-parentheses.html",
  "type": "Section",
  "number": "3.6",
  "title": "Simple Balanced Parentheses",
  "body": " Simple Balanced Parentheses  We now turn our attention to using stacks to solve real computer science problems. You have no doubt written arithmetic expressions such as   where parentheses are used to order the performance of operations. You may also have some experience programming in a language such as Lisp or Scheme with constructs like:  (defun square(n) (* n n))  This defines a function called square that will return the square of its argument n . Scheme and Lisp are both notorious for using lots and lots of parentheses.  In both of these examples, parentheses must appear in a balanced fashion. \"Balanced parentheses\" means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. Consider the following correctly balanced strings of parentheses:  (()()()()) (((()))) (()((())()))  Compare those with the following, which are not balanced:  ((((((()) ())) (()()(()  The ability to differentiate between parentheses that are correctly balanced and those that are unbalanced is an important part of recognizing many programming language structures.  The challenge then is to write an algorithm that will read a string of parentheses from left to right and decide whether the symbols are balanced. To solve this problem we need to make an important observation. As you process symbols from left to right, the most recent opening parenthesis must match the next closing symbol (see ). Also, the first opening symbol processed may have to wait until the very last symbol for its match. Closing symbols match opening symbols in the reverse order of their appearance; they match from the inside out. This is a clue that stacks can be used to solve the problem.  Figure 4: Matching Parentheses  Once you agree that a stack is the appropriate data structure for keeping the parentheses, the statement of the algorithm is straightforward. Starting with an empty stack, process the parenthesis strings from left to right. If a symbol is an opening parenthesis, push it on the stack as a signal that a corresponding closing symbol needs to appear later. If, on the other hand, a symbol is a closing parenthesis, pop the stack. As long as it is possible to pop the stack to match every closing symbol, the parentheses remain balanced. If at any time there is no opening symbol on the stack to match a closing symbol, the string is not balanced properly. At the end of the string, when all symbols have been processed, the stack should be empty. The C++ and Python code to implement this algorithm is shown in .   Parenthesis checker  C++ Implementation \/\/simple program that checks for missing parentheses #include <iostream> #include <stack> #include <string> using namespace std; \/\/ returns whether the parentheses in the input are balanced bool parChecker(string symbolString) { stack<string> s; bool balanced = true; int index = 0; int str_len = symbolString.length(); while (index < str_len && balanced) { string symbol; symbol = symbolString[index]; if (symbol == \"(\") { s.push(symbol); \/\/pushes the open parentheses to the stack. } else { if (s.empty()) { \/\/if there is no open parentheses in the stack, \/\/the closing parentheses just found makes the string unbalanced. balanced = false; } else { \/\/if there is an open parentheses in the stack, \/\/the closing parentheses just found has a matching open parentheses. s.pop(); } } index = index + 1; } if (balanced && s.empty()) { \/\/if the string is balanced and there are no \/\/remaining open parentheses. return true; } else { return false; } } int main() { cout << parChecker(\"((()))\") << endl; cout << parChecker(\"(()\") << endl; }  #Program that detects if a set of parentheses is complete. #simple program that checks for missing parentheses from pythonds.basic.stack import Stack #returns whether the parentheses in the input are balanced def parChecker(symbolString): s = Stack() balanced = True index = 0 while index < len(symbolString) and balanced: symbol = symbolString[index] if symbol == \"(\": s.push(symbol) #pushes the open parentheses to the stack. else: if s.isEmpty(): #if there is no open parentheses in the stack, #the closing parentheses just found makes the string unbalanced. balanced = False else: #if there is an open parentheses in the stack, the #closing parentheses just found has a matching open parentheses. s.pop() index = index + 1 if balanced and s.isEmpty(): #if the string is balanced and there are no #remaining open parentheses. return True else: return False def main(): print(parChecker('((()))')) print(parChecker('(()')) main()   This function, parChecker , assumes that a Stack class is available and returns a Boolean result as to whether the string of parentheses is balanced. Note that the Boolean variable balanced is initialized to true as there is no reason to assume otherwise at the start. If the current symbol is ( , then it is pushed on the stack (lines 15-16). Note also in line 22 that pop removes a symbol from the stack. At the end (lines 28-31), as long as the expression is balanced and the stack has been completely emptied, the string represents a correctly balanced sequence of parentheses.     "
},
{
  "id": "fig-parmatch",
  "level": "2",
  "url": "linear-basic_simple-balanced-parentheses.html#fig-parmatch",
  "type": "Figure",
  "number": "3.6.1",
  "title": "",
  "body": "Figure 4: Matching Parentheses "
},
{
  "id": "expl-lst-parcheck1",
  "level": "2",
  "url": "linear-basic_simple-balanced-parentheses.html#expl-lst-parcheck1",
  "type": "Exploration",
  "number": "3.6.1",
  "title": "Parenthesis checker.",
  "body": " Parenthesis checker  C++ Implementation \/\/simple program that checks for missing parentheses #include <iostream> #include <stack> #include <string> using namespace std; \/\/ returns whether the parentheses in the input are balanced bool parChecker(string symbolString) { stack<string> s; bool balanced = true; int index = 0; int str_len = symbolString.length(); while (index < str_len && balanced) { string symbol; symbol = symbolString[index]; if (symbol == \"(\") { s.push(symbol); \/\/pushes the open parentheses to the stack. } else { if (s.empty()) { \/\/if there is no open parentheses in the stack, \/\/the closing parentheses just found makes the string unbalanced. balanced = false; } else { \/\/if there is an open parentheses in the stack, \/\/the closing parentheses just found has a matching open parentheses. s.pop(); } } index = index + 1; } if (balanced && s.empty()) { \/\/if the string is balanced and there are no \/\/remaining open parentheses. return true; } else { return false; } } int main() { cout << parChecker(\"((()))\") << endl; cout << parChecker(\"(()\") << endl; }  #Program that detects if a set of parentheses is complete. #simple program that checks for missing parentheses from pythonds.basic.stack import Stack #returns whether the parentheses in the input are balanced def parChecker(symbolString): s = Stack() balanced = True index = 0 while index < len(symbolString) and balanced: symbol = symbolString[index] if symbol == \"(\": s.push(symbol) #pushes the open parentheses to the stack. else: if s.isEmpty(): #if there is no open parentheses in the stack, #the closing parentheses just found makes the string unbalanced. balanced = False else: #if there is an open parentheses in the stack, the #closing parentheses just found has a matching open parentheses. s.pop() index = index + 1 if balanced and s.isEmpty(): #if the string is balanced and there are no #remaining open parentheses. return True else: return False def main(): print(parChecker('((()))')) print(parChecker('(()')) main()  "
},
{
  "id": "linear-basic_balanced-symbols-a-general-case",
  "level": "1",
  "url": "linear-basic_balanced-symbols-a-general-case.html",
  "type": "Section",
  "number": "3.7",
  "title": "Balanced Symbols - A General Case",
  "body": " Balanced Symbols - A General Case  The balanced parentheses problem shown above is a specific case of a more general situation that arises in many programming languages. The general problem of balancing and nesting different kinds of opening and closing symbols occurs frequently. For example, in Python square brackets, [ and ] , are used for lists; curly brackets, { and } , are used for dictionaries; and parenthesis, ( and ) , are used for tuples and arithmetic expressions. In C++, square brackets, [ and ] , are used for arrays and vectors, brackets { and } separate possibly nested blocks of code, and operations are given inside of possibly nested parentheses ( and ) . It is possible to mix symbols as long as each maintains its own open and close relationship. Strings of symbols such as  { { ( [ ] [ ] ) } ( ) } [ [ { { ( ( ) ) } } ] ] [ ] [ ] [ ] ( ) { }  are properly balanced in that not only does each opening symbol have a corresponding closing symbol, but the types of symbols match as well.  Compare those with the following strings that are not balanced:  ( [ ) ] ( ( ( ) ] ) ) [ { ( ) ]  The simple parentheses checker from the previous section can easily be extended to handle these new types of symbols. Recall that each opening symbol is simply pushed on the stack to wait for the matching closing symbol to appear later in the sequence. When a closing symbol does appear, the only difference is that we must check to be sure that it correctly matches the type of the opening symbol on top of the stack. If the two symbols do not match, the string is not balanced. Once again, if the entire string is processed and nothing is left on the stack, the string is correctly balanced.  Implementations of this are shown in . The key C++ feature appears in line 38 where we call a helper function, matches , to assist with symbol-matching. Each symbol that is removed from the stack must be checked to see that it matches the current closing symbol. If a mismatch occurs, the Boolean variable balanced is set to false .   Generalized Balance Symbol Checking  C++ Implementation \/\/program that returns whether a string is balanced or not #include <iostream> #include <string> #include <stack> using namespace std; \/\/checks if a symbol is in the string of \"{[(\" bool inString(string symbol, string symbols){ return symbols.find(symbol) != string::npos; } \/\/function that returns a boolean value based on whether the strings match bool matches(string open, string close){ string opens = \"({[\"; string closers = \")]}\"; bool val = inString(open, opens) == inString(close, closers); return val; } bool parChecker(string symbolString){ stack<string> s; bool balanced = true; int index = 0; int symbolLength = symbolString.length(); while(index < symbolLength && balanced){ string symbol; symbol = symbolString[index]; string opens = \"([{\"; string closes = \"}])\"; if (inString(symbol, opens)){ s.push(symbol); } else if(inString(symbol, closes)){ if (s.empty()){ balanced = false; } else { string top = s.top(); s.pop(); if (!matches(top, symbol)){ balanced = false; break; } } } index = index + 1; } if(balanced && s.empty()){ return true; } else { return false; } } int main() { cout << parChecker(\"{}\") << endl; cout << parChecker(\"[{()}]\") << endl; return 0; }  Python Implementation #Program does the same as before, except with 2 extra symbols. from pythonds.basic.stack import Stack def parChecker(symbolString): s = Stack() balanced = True index = 0 while index < len(symbolString) and balanced: symbol = symbolString[index] if symbol in \"([{\": #if the current symbol == #an open symbol. s.push(symbol) else: if s.isEmpty(): #if there is a closed symbol #but no open symbol is pending. balanced = False else: top = s.pop() if not matches(top,symbol): #if the current closed symbol #is a different type than the #pending open one. balanced = False index = index + 1 if balanced and s.isEmpty(): #if the string is completely analyzed with #no remaining open symbols. return True else: return False def matches(open,close): #Checks if the type of an open and closed symbol are the same. opens = \"([{\" closers = \")]}\" return opens.index(open) == closers.index(close) def main(): print(parChecker('{[([][])]()}')) print(parChecker('[{()]')) main()   These two examples show that stacks are very important data structures for the processing of language constructs in computer science. Almost any notation you can think of has some type of nested symbols that must be matched in a balanced order. A number of other important uses for stacks exist in computer science. We will continue to explore them in the next sections.    Reading Question   Using the program below, click on the line of code that adds an open parenthesis to the stack. Remember that the function to do this would be the push function.  bool parChecker(string symbolString){ :   stack<string> s; :   bool balanced = true; :   int index = 0; :   int symbolLength = symbolString.length(); :   while(index < symbolLength && balanced){   string symbol; :   symbol = symbolString[index]; :   string opens = \"({[\"; :   if (inString(symbol, opens)){ :   s.push(symbol); :  } else {  if (s.empty()){   balanced = false; :  } else {   string top = s.top(); :   s.pop(); :   if (!matches(top, symbol)){ :   balanced = false; :  }  }  }   index = index + 1; :  }   if(balanced && s.empty()){ :   return true; :  } else {   return false; :  }  }       "
},
{
  "id": "expl-lst-parcheck2",
  "level": "2",
  "url": "linear-basic_balanced-symbols-a-general-case.html#expl-lst-parcheck2",
  "type": "Exploration",
  "number": "3.7.1",
  "title": "Generalized Balance Symbol Checking.",
  "body": " Generalized Balance Symbol Checking  C++ Implementation \/\/program that returns whether a string is balanced or not #include <iostream> #include <string> #include <stack> using namespace std; \/\/checks if a symbol is in the string of \"{[(\" bool inString(string symbol, string symbols){ return symbols.find(symbol) != string::npos; } \/\/function that returns a boolean value based on whether the strings match bool matches(string open, string close){ string opens = \"({[\"; string closers = \")]}\"; bool val = inString(open, opens) == inString(close, closers); return val; } bool parChecker(string symbolString){ stack<string> s; bool balanced = true; int index = 0; int symbolLength = symbolString.length(); while(index < symbolLength && balanced){ string symbol; symbol = symbolString[index]; string opens = \"([{\"; string closes = \"}])\"; if (inString(symbol, opens)){ s.push(symbol); } else if(inString(symbol, closes)){ if (s.empty()){ balanced = false; } else { string top = s.top(); s.pop(); if (!matches(top, symbol)){ balanced = false; break; } } } index = index + 1; } if(balanced && s.empty()){ return true; } else { return false; } } int main() { cout << parChecker(\"{}\") << endl; cout << parChecker(\"[{()}]\") << endl; return 0; }  Python Implementation #Program does the same as before, except with 2 extra symbols. from pythonds.basic.stack import Stack def parChecker(symbolString): s = Stack() balanced = True index = 0 while index < len(symbolString) and balanced: symbol = symbolString[index] if symbol in \"([{\": #if the current symbol == #an open symbol. s.push(symbol) else: if s.isEmpty(): #if there is a closed symbol #but no open symbol is pending. balanced = False else: top = s.pop() if not matches(top,symbol): #if the current closed symbol #is a different type than the #pending open one. balanced = False index = index + 1 if balanced and s.isEmpty(): #if the string is completely analyzed with #no remaining open symbols. return True else: return False def matches(open,close): #Checks if the type of an open and closed symbol are the same. opens = \"([{\" closers = \")]}\" return opens.index(open) == closers.index(close) def main(): print(parChecker('{[([][])]()}')) print(parChecker('[{()]')) main()  "
},
{
  "id": "stackclick",
  "level": "2",
  "url": "linear-basic_balanced-symbols-a-general-case.html#stackclick",
  "type": "Reading Question",
  "number": "3.7.1",
  "title": "",
  "body": "Using the program below, click on the line of code that adds an open parenthesis to the stack. Remember that the function to do this would be the push function.  bool parChecker(string symbolString){ :   stack<string> s; :   bool balanced = true; :   int index = 0; :   int symbolLength = symbolString.length(); :   while(index < symbolLength && balanced){   string symbol; :   symbol = symbolString[index]; :   string opens = \"({[\"; :   if (inString(symbol, opens)){ :   s.push(symbol); :  } else {  if (s.empty()){   balanced = false; :  } else {   string top = s.top(); :   s.pop(); :   if (!matches(top, symbol)){ :   balanced = false; :  }  }  }   index = index + 1; :  }   if(balanced && s.empty()){ :   return true; :  } else {   return false; :  }  }  "
},
{
  "id": "linear-basic_converting-decimal-numbers-to-binary-numbers",
  "level": "1",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html",
  "type": "Section",
  "number": "3.8",
  "title": "Converting Decimal Numbers to Binary Numbers",
  "body": " Converting Decimal Numbers to Binary Numbers  In your study of computer science, you have probably been exposed in one way or another to the idea of a binary number. Binary representation is important in computer science since all values stored within a computer exist as a string of binary digits, a string of 0s and 1s. Without the ability to convert back and forth between common representations and binary numbers, we would need to interact with computers in very awkward ways.  Integer values are common data items. They are used in computer programs and computation all the time. We learn about them in math class and of course represent them using the decimal number system, or base 10. The decimal number and its corresponding binary equivalent are interpreted respectively as   and   But how can we easily convert integer values into binary numbers? The answer is an algorithm called Divide by 2 that uses a stack to keep track of the digits for the binary result.  The Divide by 2 algorithm assumes that we start with an integer greater than 0. A simple iteration then continually uses integer division to divide the decimal number by 2 and to keep track of the remainder. The first division by 2 gives information as to whether the value is even or odd. When the number is even, dividing it by 2 will leave a remainder of 0, meaning the binary representation of the number will have a 0 in the least significant bit. Conversely, when the number is odd, the remainder will be 1, indicating a 1 in the least significant bit. We think about building our binary number as a sequence of digits; the first remainder we compute will actually be the last digit in the sequence. As shown in , we again see the reversal property that signals that a stack is likely to be the appropriate data structure for solving the problem.   Decimal-to-Binary Conversion    The code in implements the Divide by 2 algorithm. The function divideBy2 takes an argument that is a decimal number and repeatedly divides it by 2. Line 11 uses the built-in modulo operator, %, to extract the remainder and line 12 then pushes it on the stack. After the division process reaches 0, a binary string is constructed in lines 16-19. Line 16 creates an empty string. The binary digits are popped from the stack one at a time and appended to the right-hand end of the string. The binary string is then returned.   Divide By 2 Algorithm  C++ Implementation \/\/converts a given decimal number into binary. #include <iostream> #include <stack> #include <string> using namespace std; string divideBy2(int decNumber) { \/\/performs the conversion process. stack<int> remstack; while (decNumber > 0) { \/\/gets the remainder of division by 2 \/\/and adds the remainder to a stack. int rem = decNumber % 2; remstack.push(rem); decNumber = decNumber \/ 2; } string binString = \"\"; while (!remstack.empty()) { \/\/adds the remainder numbers in the stack into a string. binString.append(to_string(remstack.top())); remstack.pop(); } return binString; } int main() { cout << divideBy2(42) << endl; return 0; }  Python Implementation #converts a given decimal number into binary. from pythonds.basic.stack import Stack def divideBy2(decNumber): #performs the conversion process. remstack = Stack() while decNumber > 0: #gets the remainder of division by 2 #and adds the remainder to a stack. rem = decNumber % 2 remstack.push(rem) decNumber = decNumber \/\/ 2 binString = \"\" while not remstack.isEmpty(): #adds the numbers in the stack to a string. binString = binString + str(remstack.pop()) return binString def main(): print(divideBy2(42)) main()   The algorithm for binary conversion can easily be extended to perform the conversion for any base. In computer science it is common to use a number of different base encodings for integers. The most common of these are binary (base 2), octal (base 8), and hexadecimal (base 16).  The decimal number and its corresponding octal and hexadecimal equivalents and are interpreted as:   and   The function divideBy2 can be modified to accept not only a decimal value but also a base for the intended conversion. The Divide by 2 idea is simply replaced with a more general Divide by base. A new function called baseConverter , shown in , takes a decimal number and any base between 2 and 16 as parameters. The remainders are still pushed onto the stack until the value being converted becomes 0. The same left-to-right string construction technique can be used with one slight change. Base 2 through base 10 numbers require a maximum of 10 digits, so the typical digit characters 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9 work fine. The problem comes when we go beyond base 10. We can no longer simply use these remainders as digits, because they are themselves represented as two-digit decimal numbers. Instead we need to create a set of digits that can be used to represent those remainders beyond 9.   Implementation of baseConverter  \/\/converts a decimal number into desired base 1-16. #include <iostream> #include <stack> #include <string> using namespace std; string baseConverter(int decNumber, int base) { \/\/performs the conversion process. string digits[] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}; stack<int> remstack; while (decNumber > 0) { \/\/adds the remainder after division of base, to the stack. int rem = decNumber % base; remstack.push(rem); decNumber = decNumber \/ base; } string newString = \"\"; while (!remstack.empty()) { \/\/makes a string out of all the items in the stack. newString.append(digits[remstack.top()]); remstack.pop(); } return newString; } int main() { int mynum = 25; cout << baseConverter(mynum, 2) << endl; cout << baseConverter(mynum, 16) << endl; return 0; }  Python Implementation #converts a decimal number into desired base 1-16. from pythonds.basic.stack import Stack def baseConverter(decNumber,base): #performs the conversion process. digits = \"0123456789ABCDEF\" remstack = Stack() while decNumber > 0: #adds the remainder after division of base, to the stack. rem = decNumber % base remstack.push(rem) decNumber = decNumber \/\/ base newString = \"\" while not remstack.isEmpty(): #makes a string out of all the items in the stack. newString = newString + digits[remstack.pop()] return newString def main(): imynum = 25 print(baseConverter(imynum, 2)) print(baseConverter(imynum, 16)) main()   A solution to this problem is to extend the digit set to include some additional characters to represent digits. For example, hexadecimal uses the ten decimal digits along with the first six alphabet characters for the 16 digits. To implement this, a digit string is created (line 11 in ) that stores the digits in their corresponding positions. The digit 0 is at string position 0, 1 is at position 1, A is at position 10, B is at position 11, and so on. When a remainder is removed from the stack, it can be used to index into the digit string and the correct resulting digit can be appended to the answer. For example, if the remainder 13 is removed from the stack, the digit D is appended to the resulting string.   Reading Questions   What is value of 25 expressed as an octal (base 8) number?  Correct because 25 = 3x8 + 1.   What is value of 256 expressed as a hexadecimal (base 16) number?  Correct because 256 = 1x16^2.   What is value of 26 expressed in base 26?  Correct because 26 = 1x26^1.      "
},
{
  "id": "fig-decbin",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#fig-decbin",
  "type": "Figure",
  "number": "3.8.1",
  "title": "",
  "body": " Decimal-to-Binary Conversion   "
},
{
  "id": "expl-lst-binconverter",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#expl-lst-binconverter",
  "type": "Exploration",
  "number": "3.8.1",
  "title": "Divide By 2 Algorithm.",
  "body": " Divide By 2 Algorithm  C++ Implementation \/\/converts a given decimal number into binary. #include <iostream> #include <stack> #include <string> using namespace std; string divideBy2(int decNumber) { \/\/performs the conversion process. stack<int> remstack; while (decNumber > 0) { \/\/gets the remainder of division by 2 \/\/and adds the remainder to a stack. int rem = decNumber % 2; remstack.push(rem); decNumber = decNumber \/ 2; } string binString = \"\"; while (!remstack.empty()) { \/\/adds the remainder numbers in the stack into a string. binString.append(to_string(remstack.top())); remstack.pop(); } return binString; } int main() { cout << divideBy2(42) << endl; return 0; }  Python Implementation #converts a given decimal number into binary. from pythonds.basic.stack import Stack def divideBy2(decNumber): #performs the conversion process. remstack = Stack() while decNumber > 0: #gets the remainder of division by 2 #and adds the remainder to a stack. rem = decNumber % 2 remstack.push(rem) decNumber = decNumber \/\/ 2 binString = \"\" while not remstack.isEmpty(): #adds the numbers in the stack to a string. binString = binString + str(remstack.pop()) return binString def main(): print(divideBy2(42)) main()  "
},
{
  "id": "linear-basic_converting-decimal-numbers-to-binary-numbers-18",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#linear-basic_converting-decimal-numbers-to-binary-numbers-18",
  "type": "Exploration",
  "number": "3.8.2",
  "title": "Implementation of <code class=\"code-inline tex2jax_ignore\">baseConverter<\/code>.",
  "body": " Implementation of baseConverter  \/\/converts a decimal number into desired base 1-16. #include <iostream> #include <stack> #include <string> using namespace std; string baseConverter(int decNumber, int base) { \/\/performs the conversion process. string digits[] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}; stack<int> remstack; while (decNumber > 0) { \/\/adds the remainder after division of base, to the stack. int rem = decNumber % base; remstack.push(rem); decNumber = decNumber \/ base; } string newString = \"\"; while (!remstack.empty()) { \/\/makes a string out of all the items in the stack. newString.append(digits[remstack.top()]); remstack.pop(); } return newString; } int main() { int mynum = 25; cout << baseConverter(mynum, 2) << endl; cout << baseConverter(mynum, 16) << endl; return 0; }  Python Implementation #converts a decimal number into desired base 1-16. from pythonds.basic.stack import Stack def baseConverter(decNumber,base): #performs the conversion process. digits = \"0123456789ABCDEF\" remstack = Stack() while decNumber > 0: #adds the remainder after division of base, to the stack. rem = decNumber % base remstack.push(rem) decNumber = decNumber \/\/ base newString = \"\" while not remstack.isEmpty(): #makes a string out of all the items in the stack. newString = newString + digits[remstack.pop()] return newString def main(): imynum = 25 print(baseConverter(imynum, 2)) print(baseConverter(imynum, 16)) main()  "
},
{
  "id": "convert-base-1",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#convert-base-1",
  "type": "Reading Question",
  "number": "3.8.1",
  "title": "",
  "body": " What is value of 25 expressed as an octal (base 8) number?  Correct because 25 = 3x8 + 1. "
},
{
  "id": "convert-base-2",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#convert-base-2",
  "type": "Reading Question",
  "number": "3.8.2",
  "title": "",
  "body": " What is value of 256 expressed as a hexadecimal (base 16) number?  Correct because 256 = 1x16^2. "
},
{
  "id": "convert-base-3",
  "level": "2",
  "url": "linear-basic_converting-decimal-numbers-to-binary-numbers.html#convert-base-3",
  "type": "Reading Question",
  "number": "3.8.3",
  "title": "",
  "body": " What is value of 26 expressed in base 26?  Correct because 26 = 1x26^1. "
},
{
  "id": "linear-basic_infix-prefix-and-postfix-expressions",
  "level": "1",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html",
  "type": "Section",
  "number": "3.9",
  "title": "Infix, Prefix and Postfix Expressions",
  "body": " Infix, Prefix and Postfix Expressions    infix expression   An infix expression is a standard mathematical notation in which operators are written between the operands they act on. It is the most commonly used expression format in most programming languages, including C++. In this format, the operator is placed between the two operands. For example, the addition of two numbers a and b is represented as a + b. Example: (a + b) * c    When you write an arithmetic expression such as B * C, the form of the expression provides you with information so that you can interpret it correctly. In this case we know that the variable B is being multiplied by the variable C since the multiplication operator * appears between them in the expression. This type of notation is referred to as infix since the operator is in between the two operands that it is working on.  Consider another infix example, A + B * C. The operators + and * still appear between the operands, but there is a problem. Which operands do they work on first? Does the + work on A and B or does the * take B and C? The expression seems ambiguous.  In fact, you have been reading and writing these types of expressions for a long time and they do not cause you any problem. The reason for this is that you know something about the operators + and *. Each operator has a precedence level. Operators of higher precedence are used before operators of lower precedence. The only thing that can change that order is the presence of parentheses. The precedence order for arithmetic operators places multiplication and division above addition and subtraction. If two operators of equal precedence appear, then a left-to-right ordering or associativity is used.  Let's interpret the troublesome expression A + B * C using operator precedence. B and C are multiplied first, and A is then added to that result. (A + B) * C would force the addition of A and B to be done first before the multiplication. In expression A + B + C, by precedence (via associativity), the leftmost + would be done first.  Although all this may be obvious to you, remember that computers need to know exactly what operators to perform and in what order. One way to write an expression that guarantees there will be no confusion with respect to the order of operations is to create what is called a fully parenthesized expression. This type of expression uses one pair of parentheses for each operator. The parentheses dictate the order of operations; there is no ambiguity. There is also no need to remember any precedence rules.  The expression A + B * C + D can be rewritten as ((A + (B * C)) + D) to show that the multiplication happens first, followed by the leftmost addition. A + B + C + D can be written as (((A + B) + C) + D) since the addition operations associate from left to right.  There are two other very important expression formats that may not seem obvious to you at first. Consider the infix expression A + B. What would happen if we moved the operator before the two operands? The resulting expression would be + A B. Likewise, we could move the operator to the end. We would get A B +. These look a bit strange.  These changes to the position of the operator with respect to the operands create two new expression formats, prefix and postfix . Prefix expression notation requires that all operators precede the two operands that they work on. Postfix, on the other hand, requires that its operators come after the corresponding operands. A few more examples should help to make this a bit clearer (see ).  In prefix, A + B * C would be written as + A * B C . The multiplication operator comes immediately before the operands B and C, denoting that * has precedence over +. The addition operator then appears before the A and the result of the multiplication.  In postfix, the expression A + B * C would be A B C * +. Again, the order of operations is preserved since the * appears immediately after the B and the C, denoting that * has precedence, with + coming after. Although the operators moved and now appear either before or after their respective operands, the order of the operands stayed exactly the same relative to one another.   Examples of Infix, Prefix, and Postfix    Infix Expression    Prefix Expression    Postfix Expression     A + B  + A B  A B +    A + B * C  + A * B C  A B C * +    Now consider the infix expression (A + B) * C. Recall that in this case, infix requires the parentheses to force the performance of the addition before the multiplication. However, when A + B was written in prefix, the addition operator was simply moved before the operands, + A B. The result of this operation becomes the first operand for the multiplication. The multiplication operator is moved in front of the entire expression, giving us * + A B C. Likewise, in postfix A B + forces the addition to happen first. The multiplication can be done to that result and the remaining operand C. The proper postfix expression is then A B + C *.  Consider these three expressions again (see ). Something very important has happened. Where did the parentheses go? Why don't we need them in prefix and postfix? The answer is that the operators are no longer ambiguous with respect to the operands that they work on. Only infix notation requires the additional symbols. The order of operations within prefix and postfix expressions is completely determined by the position of the operator and nothing else. In many ways, this makes infix the least desirable notation to use.   An Expression with Parentheses    Infix Expression    Prefix Expression    Postfix Expression     (A + B) * C  * + A B C  A B + C *    shows some additional examples of infix expressions and the equivalent prefix and postfix expressions. Be sure that you understand how they are equivalent in terms of the order of the operations being performed.   Additional Examples of Infix, Prefix, and Postfix    Infix Expression    Prefix Expression    Postfix Expression     A + B * C + D  + + A * B C D  A B C * + D +    (A + B) * (C + D)  * + A B + C D  A B + C D + *    A * B + C * D  + * A B * C D  A B * C D * +    A + B + C + D  + + + A B C D  A B + C + D +      Conversion of Infix Expressions to Prefix and Postfix   prefix expression   A prefix expression, also known as Polish notation, is a mathematical notation in which every operator follows all of its operands. The primary advantage of prefix notation is that it completely eliminates the need for parentheses to indicate orders of operations. The order in which operations are to be performed is evident from the position of the operators and operands. Example: For the infix expression (a + b) * c, the corresponding prefix notation is * + a b c.    So far, we have used ad hoc methods to convert between infix expressions and the equivalent prefix and postfix expression notations. As you might expect, there are algorithmic ways to perform the conversion that allow any expression of any complexity to be correctly transformed.  The first technique that we will consider uses the notion of a fully parenthesized expression that was discussed earlier. Recall that A + B * C can be written as (A + (B * C)) to show explicitly that the multiplication has precedence over the addition. On closer observation, however, you can see that each parenthesis pair also denotes the beginning and the end of an operand pair with the corresponding operator in the middle.  Look at the right parenthesis in the subexpression (B * C) above. If we were to move the multiplication symbol to that position and remove the matching left parenthesis, giving us B C *, we would in effect have converted the subexpression to postfix notation. If the addition operator were also moved to its corresponding right parenthesis position and the matching left parenthesis were removed, the complete postfix expression would result (see ).   Moving Operators to the Right for Postfix Notation    If we do the same thing but instead of moving the symbol to the position of the right parenthesis, we move it to the left, we get prefix notation (see ). The position of the parenthesis pair is actually a clue to the final position of the enclosed operator.   Moving Operators to the Left for Prefix Notation    So in order to convert an expression, no matter how complex, to either prefix or postfix notation, fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation.  Here is a more complex expression: (A + B) * C - (D - E) * (F + G). shows the conversion to postfix and prefix notations.   Converting a Complex Expression to Prefix and Postfix Notations      General Infix-to-Postfix Conversion   postfix expression   A postfix expression, commonly known as Reverse Polish notation (RPN), is a mathematical notation in which every operator follows its operands. Postfix notation has the advantage of being able to represent a mathematical expression without the need for parentheses, which simplifies the algorithm to process the expression. The order of operations is determined by the position of the operator in relation to its operands. Example: For the infix expression (a + b) * c, the corresponding postfix notation is a b + c *.    We need to develop an algorithm to convert any infix expression to a postfix expression. To do this we will look closer at the conversion process.  Consider once again the expression A + B * C. As shown above, A B C * + is the postfix equivalent. We have already noted that the operands A, B, and C stay in their relative positions. It is only the operators that change position. Let's look again at the operators in the infix expression. The first operator that appears from left to right is +. However, in the postfix expression, + is at the end since the next operator, *, has precedence over addition. The order of the operators in the original expression is reversed in the resulting postfix expression.  As we process the expression, the operators have to be saved somewhere since their corresponding right operands have not yet been seen. Additionally, because of their priority, the order of these saved operators might need to be changed, which is the case for the multiplication and addition in this example. Since the addition operator comes before the multiplication operator and has lower precedence, it needs to appear after the multiplication operator is used. Because of this reversal of order, it makes sense to consider using a stack to keep the operators until they are needed.  What about (A + B) * C? Recall that A B + C * is the postfix equivalent. Again, processing this infix expression from left to right, we see + first. In this case, when we see *, + has already been placed in the result expression because it has precedence over * by virtue of the parentheses. We can now start to see how the conversion algorithm will work. When we see a left parenthesis, we will save it to denote that another operator of high precedence will be coming. That operator will need to wait until the corresponding right parenthesis appears to denote its position (recall the fully parenthesized technique). When that right parenthesis does appear, the operator can be popped from the stack.  As we scan the infix expression from left to right, we will use a stack to keep the operators. This will provide the reversal that we noted in the first example. The top of the stack will always be the most recently saved operator. Whenever we read a new operator, we will need to consider how that operator compares in precedence with the operators, if any, already on the stack.  Assume the infix expression is a string of tokens delimited by spaces. The operator tokens are *, \/, +, and -, along with the left and right parentheses, ( and ). The operand tokens are the single-character identifiers A, B, C, and so on. The following steps will produce a string of tokens in postfix order.    Create an empty stack called opstack for keeping operators. Create an empty vector for output.    Scan the current token of the input vector from left to right (using a loop).    If the token is an operand, append it to the end of the output list(vector).    If the token is a left parenthesis, push it on the opstack .    If the token is a right parenthesis, pop the opstack until the corresponding left parenthesis is removed. Append each operator to the end of the output vector.    If the token is an operator, *, \/, +, or -, push it on the opstack . However, first remove any operators already on the opstack that have higher or equal precedence and append them to the output vector.      When the input expression has been completely processed, check the opstack . Any operators still on the stack can be removed and appended to the end of the output vector.    shows the conversion algorithm working on the expression A * B + C * D. Note that the first * operator is removed upon seeing the + operator. Also, + stays on the stack when the second * occurs, since multiplication has precedence over addition. At the end of the infix expression the stack is popped twice, removing both operators and placing + as the last operator in the postfix expression.   Converting A * B + C * D to Postfix Notation    In order to code the algorithm in C++, we will use a hash map called prec to hold the precedence values for the operators which will be implemented with an unordered map. This hash map will map each operator char to an integer that can be compared against the precedence levels of other operators (we have arbitrarily used the integers 3, 2, and 1). The left parenthesis will receive the lowest value possible. This way any operator that is compared against it will have higher precedence and will be placed on top of it. Line 18 defines the operands to be any upper-case character or digit. The complete conversion function is shown in .   Infix to Postfix Conversion  C++ Implementation \/\/Converts an infix expression to a postfix expression. #include <iostream> #include <stack> #include <unordered_map> #include <string> #include <vector> using namespace std; string infixToPostfix(string infixexpr) { \/\/performs the postfix process. unordered_map <char,int> prec; prec['*']=3; prec['\/']=3; prec['+']=2; prec['-']=2; prec['(']=1; stack<char> opStack; vector<char> postfixVector; string letsnums = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; for (char token:infixexpr) { \/\/for each character in infixexpr if (token == ' ') { continue; } else if (letsnums.find(token)<=letsnums.length()) { \/\/finds if the token is inside of letsnums postfixVector.emplace_back(token); \/\/ appends to the end of the container. } else if (token == '(') { opStack.push(token); } else if (token == ')') { char topToken; topToken = opStack.top(); opStack.pop(); while (topToken != '(') { postfixVector.emplace_back(topToken); topToken=opStack.top(); opStack.pop(); } } else { \/\/if the token is not inside of letsnums. while (!opStack.empty() && (prec[opStack.top()]>=prec[token])) \/\/while the stack is not empty and \/\/the top item of the stack is on a \/\/higher level of PEMDAS than token. { postfixVector.emplace_back(opStack.top()); opStack.pop(); } opStack.push(token); } } while (!opStack.empty()) { postfixVector.emplace_back(opStack.top()); opStack.pop(); } string s(postfixVector.begin(),postfixVector.end()); return s; } int main() { cout <<\"infix: A * B + C * D\\n\" << \"postfix: \"; cout << infixToPostfix(\"A * B + C * D\") << endl; cout << \"infix: ( A + B ) * C - ( D - E ) * ( F + G )\\n\" << \"postfix: \"; cout << infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\") << endl; return 0; }  Python Implementation #Converts an infix expression to a postfix expression. from pythonds.basic.stack import Stack def infixToPostfix(infixexpr): #performs the postfix process. prec = {} prec[\"*\"] = 3 prec[\"\/\"] = 3 prec[\"+\"] = 2 prec[\"-\"] = 2 prec[\"(\"] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: #for each character in infixexpr if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": postfixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]): #while the stack is not empty and #the top item of the stack is on a #higher level of PEMDAS than token. postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return \" \".join(postfixList) def main(): print(infixToPostfix(\"A * B + C * D\")) print(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) main()    A few more results of execution are shown below.  >>> infixtopostfix(\"( A + B ) * ( C + D )\") 'A B + C D + *' >>> infixtopostfix(\"( A + B ) * C\") 'A B + C *' >>> infixtopostfix(\"A + B * C\") 'A B C * +' >>>    Postfix Evaluation  As a final stack example, we will consider the evaluation of an expression that is already in postfix notation. In this case, a stack is again the data structure of choice. However, as you scan the postfix expression, it is the operands that must wait, not the operators as in the conversion algorithm above. Another way to think about the solution is that whenever an operator is seen on the input, the two most recent operands will be used in the evaluation.  To see this in more detail, consider the postfix expression 4 5 6 * + . As you scan the expression from left to right, you first encounter the operands 4 and 5. At this point, you are still unsure what to do with them until you see the next symbol. Placing each on the stack ensures that they are available if an operator comes next.  In this case, the next symbol is another operand. So, as before, push it and check the next symbol. Now we see an operator, *. This means that the two most recent operands need to be used in a multiplication operation. By popping the stack twice, we can get the proper operands and then perform the multiplication (in this case getting the result 30).  We can now handle this result by placing it back on the stack so that it can be used as an operand for the later operators in the expression. When the final operator is processed, there will be only one value left on the stack. Pop and return it as the result of the expression. shows the stack contents as this entire example expression is being processed.   Stack Contents During Evaluation    shows a slightly more complex example, 7 8 + 3 2 + \/. There are two things to note in this example. First, the stack size grows, shrinks, and then grows again as the subexpressions are evaluated. Second, the division operation needs to be handled carefully. Recall that the operands in the postfix expression are in their original order since postfix changes only the placement of operators. When the operands for the division are popped from the stack, they are reversed. Since division is not a commutative operator, in other words is not the same as , we must be sure that the order of the operands is not switched.   A More Complex Example of Evaluation    Assume the postfix expression is a string of tokens delimited by spaces. The operators are *, \/, +, and - and the operands are assumed to be single-digit integer values. The output will be an integer result.    Create an empty stack called operandStack .    Iterate across the input using a for loop.    Scan the token vector from left to right.    If the token is an operand, convert it from a string to an integer and push the value onto the operandStack . (Using the ASCII, you can get this by subtracting 48)    If the token is an operator, *, \/, +, or -, it will need two operands. Pop the operandStack twice. The first pop is the second operand and the second pop is the first operand. Perform the arithmetic operation. Push the result back on the operandStack .      When the input expression has been completely processed, the result is on the stack. Pop the operandStack and return the value.    The complete function for the evaluation of postfix expressions is shown in . To assist with the arithmetic, a helper function doMath is defined that will take two operands and an operator and then perform the proper arithmetic operation.   Postfix Expression Evaluator  C++ Implementation \/\/Solves a postfix math problem. #include <iostream> #include <stack> #include <string> using namespace std; int doMath(char op, int op1, int op2) { \/\/Does math based on what op is passed as. if (op == '*') { return (op1 * op2); } else if (op == '\/') { return (op1 \/ op2); } else if (op == '+') { return (op1 + op2); } else { return (op1 - op2); } } int postfixEval(string postfixExpr) { stack<int> operandStack; string nums = \"0123456789\"; for (char i : postfixExpr) { if ((nums.find(i) <= nums.length())) { \/\/ Check if the current char is a number operandStack.push(int(i) - 48); \/\/ conversion from char to ascii \/\/ then subtract 48 to get the int value } else if (i != ' ') { int operand2 = operandStack.top(); operandStack.pop(); int operand1 = operandStack.top(); operandStack.pop(); int result = doMath(i, operand1, operand2); operandStack.push(result); } } return operandStack.top(); } int main() { cout << \"7 8 + 3 2 + \/\" << endl; cout << postfixEval(\"7 8 + 3 2 + \/\") << endl; return 0; }  Python Implementation #Solves a postfix math problem. from pythonds.basic.stack import Stack def postfixEval(postfixExpr): operandStack = Stack() tokenList = postfixExpr.split() for token in tokenList: if token in \"0123456789\": operandStack.push(int(token)) else: operand2 = operandStack.pop() operand1 = operandStack.pop() result = doMath(token,operand1,operand2) operandStack.push(result) return operandStack.pop() def doMath(op, op1, op2): #Does math based on what op is passed as. if op == \"*\": return op1 * op2 elif op == \"\/\": return op1 \/ op2 elif op == \"+\": return op1 + op2 else: return op1 - op2 def main(): print(postfixEval('7 8 + 3 2 + \/')) main()   It is important to note that in both the postfix conversion and the postfix evaluation programs we assumed that there were no errors in the input expression. Using these programs as a starting point, you can easily see how error detection and reporting can be included. We leave this as an exercise at the end of the chapter.   Reading Questions   What does the prefix expression of this infix expression look like: ((A+B)*(C-D)) if this were modeled using a stack with the top being the end of the expression and the bottom being the beginning of the expression?   D  C  -  B  A  +  *    Without using the activecode infixToPostfix function, convert the following expression to postfix 10 + 3 * 5 \/ (16 - 4) .  Correct. The numbers appear to be in the correct order check your operators   What is the result of evaluating the following: 17 10 + 3 * 9 \/ =   Correct.   Modify the infixToPostfix function above so that it can convert the following expression. Once you have the answer from the code put it in the blank below: 5 * 3 \/(4 - 2) .  Correct. The numbers appear to be in the correct order check your operators       "
},
{
  "id": "def-infix-expression",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#def-infix-expression",
  "type": "Definition",
  "number": "3.9.1",
  "title": "",
  "body": " infix expression   An infix expression is a standard mathematical notation in which operators are written between the operands they act on. It is the most commonly used expression format in most programming languages, including C++. In this format, the operator is placed between the two operands. For example, the addition of two numbers a and b is represented as a + b. Example: (a + b) * c   "
},
{
  "id": "linear-basic_infix-prefix-and-postfix-expressions-2-2",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_infix-prefix-and-postfix-expressions-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "infix "
},
{
  "id": "linear-basic_infix-prefix-and-postfix-expressions-2-4",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_infix-prefix-and-postfix-expressions-2-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "precedence "
},
{
  "id": "linear-basic_infix-prefix-and-postfix-expressions-2-6",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_infix-prefix-and-postfix-expressions-2-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "fully parenthesized "
},
{
  "id": "linear-basic_infix-prefix-and-postfix-expressions-2-9",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_infix-prefix-and-postfix-expressions-2-9",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "prefix postfix "
},
{
  "id": "linear-basic_xfix_examples",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_xfix_examples",
  "type": "Table",
  "number": "3.9.2",
  "title": "",
  "body": " Examples of Infix, Prefix, and Postfix    Infix Expression    Prefix Expression    Postfix Expression     A + B  + A B  A B +    A + B * C  + A * B C  A B C * +   "
},
{
  "id": "linear-basic_tbl-parexample",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_tbl-parexample",
  "type": "Table",
  "number": "3.9.3",
  "title": "",
  "body": " An Expression with Parentheses    Infix Expression    Prefix Expression    Postfix Expression     (A + B) * C  * + A B C  A B + C *   "
},
{
  "id": "linear-basic_tbl-example3",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#linear-basic_tbl-example3",
  "type": "Table",
  "number": "3.9.4",
  "title": "",
  "body": " Additional Examples of Infix, Prefix, and Postfix    Infix Expression    Prefix Expression    Postfix Expression     A + B * C + D  + + A * B C D  A B C * + D +    (A + B) * (C + D)  * + A B + C D  A B + C D + *    A * B + C * D  + * A B * C D  A B * C D * +    A + B + C + D  + + + A B C D  A B + C + D +   "
},
{
  "id": "def-prefix-expression",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#def-prefix-expression",
  "type": "Definition",
  "number": "3.9.5",
  "title": "",
  "body": " prefix expression   A prefix expression, also known as Polish notation, is a mathematical notation in which every operator follows all of its operands. The primary advantage of prefix notation is that it completely eliminates the need for parentheses to indicate orders of operations. The order in which operations are to be performed is evident from the position of the operators and operands. Example: For the infix expression (a + b) * c, the corresponding prefix notation is * + a b c.   "
},
{
  "id": "xfix_fig-moveright",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-moveright",
  "type": "Figure",
  "number": "3.9.6",
  "title": "",
  "body": " Moving Operators to the Right for Postfix Notation   "
},
{
  "id": "xfix_fig-moveleft",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-moveleft",
  "type": "Figure",
  "number": "3.9.7",
  "title": "",
  "body": " Moving Operators to the Left for Prefix Notation   "
},
{
  "id": "xfix_fig-complexmove",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-complexmove",
  "type": "Figure",
  "number": "3.9.8",
  "title": "",
  "body": " Converting a Complex Expression to Prefix and Postfix Notations   "
},
{
  "id": "def-postfix-expression",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#def-postfix-expression",
  "type": "Definition",
  "number": "3.9.9",
  "title": "",
  "body": " postfix expression   A postfix expression, commonly known as Reverse Polish notation (RPN), is a mathematical notation in which every operator follows its operands. Postfix notation has the advantage of being able to represent a mathematical expression without the need for parentheses, which simplifies the algorithm to process the expression. The order of operations is determined by the position of the operator in relation to its operands. Example: For the infix expression (a + b) * c, the corresponding postfix notation is a b + c *.   "
},
{
  "id": "xfix_fig-intopost",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-intopost",
  "type": "Figure",
  "number": "3.9.10",
  "title": "",
  "body": " Converting A * B + C * D to Postfix Notation   "
},
{
  "id": "expl-lst-intopost-cpp",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#expl-lst-intopost-cpp",
  "type": "Exploration",
  "number": "3.9.1",
  "title": "Infix to Postfix Conversion.",
  "body": " Infix to Postfix Conversion  C++ Implementation \/\/Converts an infix expression to a postfix expression. #include <iostream> #include <stack> #include <unordered_map> #include <string> #include <vector> using namespace std; string infixToPostfix(string infixexpr) { \/\/performs the postfix process. unordered_map <char,int> prec; prec['*']=3; prec['\/']=3; prec['+']=2; prec['-']=2; prec['(']=1; stack<char> opStack; vector<char> postfixVector; string letsnums = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; for (char token:infixexpr) { \/\/for each character in infixexpr if (token == ' ') { continue; } else if (letsnums.find(token)<=letsnums.length()) { \/\/finds if the token is inside of letsnums postfixVector.emplace_back(token); \/\/ appends to the end of the container. } else if (token == '(') { opStack.push(token); } else if (token == ')') { char topToken; topToken = opStack.top(); opStack.pop(); while (topToken != '(') { postfixVector.emplace_back(topToken); topToken=opStack.top(); opStack.pop(); } } else { \/\/if the token is not inside of letsnums. while (!opStack.empty() && (prec[opStack.top()]>=prec[token])) \/\/while the stack is not empty and \/\/the top item of the stack is on a \/\/higher level of PEMDAS than token. { postfixVector.emplace_back(opStack.top()); opStack.pop(); } opStack.push(token); } } while (!opStack.empty()) { postfixVector.emplace_back(opStack.top()); opStack.pop(); } string s(postfixVector.begin(),postfixVector.end()); return s; } int main() { cout <<\"infix: A * B + C * D\\n\" << \"postfix: \"; cout << infixToPostfix(\"A * B + C * D\") << endl; cout << \"infix: ( A + B ) * C - ( D - E ) * ( F + G )\\n\" << \"postfix: \"; cout << infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\") << endl; return 0; }  Python Implementation #Converts an infix expression to a postfix expression. from pythonds.basic.stack import Stack def infixToPostfix(infixexpr): #performs the postfix process. prec = {} prec[\"*\"] = 3 prec[\"\/\"] = 3 prec[\"+\"] = 2 prec[\"-\"] = 2 prec[\"(\"] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: #for each character in infixexpr if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": postfixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]): #while the stack is not empty and #the top item of the stack is on a #higher level of PEMDAS than token. postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return \" \".join(postfixList) def main(): print(infixToPostfix(\"A * B + C * D\")) print(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) main()  "
},
{
  "id": "xfix_fig-evalpost1",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-evalpost1",
  "type": "Figure",
  "number": "3.9.11",
  "title": "",
  "body": " Stack Contents During Evaluation   "
},
{
  "id": "xfix_fig-evalpost2",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#xfix_fig-evalpost2",
  "type": "Figure",
  "number": "3.9.12",
  "title": "",
  "body": " A More Complex Example of Evaluation   "
},
{
  "id": "expl-lst-postfixeval-cpp",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#expl-lst-postfixeval-cpp",
  "type": "Exploration",
  "number": "3.9.2",
  "title": "Postfix Expression Evaluator.",
  "body": " Postfix Expression Evaluator  C++ Implementation \/\/Solves a postfix math problem. #include <iostream> #include <stack> #include <string> using namespace std; int doMath(char op, int op1, int op2) { \/\/Does math based on what op is passed as. if (op == '*') { return (op1 * op2); } else if (op == '\/') { return (op1 \/ op2); } else if (op == '+') { return (op1 + op2); } else { return (op1 - op2); } } int postfixEval(string postfixExpr) { stack<int> operandStack; string nums = \"0123456789\"; for (char i : postfixExpr) { if ((nums.find(i) <= nums.length())) { \/\/ Check if the current char is a number operandStack.push(int(i) - 48); \/\/ conversion from char to ascii \/\/ then subtract 48 to get the int value } else if (i != ' ') { int operand2 = operandStack.top(); operandStack.pop(); int operand1 = operandStack.top(); operandStack.pop(); int result = doMath(i, operand1, operand2); operandStack.push(result); } } return operandStack.top(); } int main() { cout << \"7 8 + 3 2 + \/\" << endl; cout << postfixEval(\"7 8 + 3 2 + \/\") << endl; return 0; }  Python Implementation #Solves a postfix math problem. from pythonds.basic.stack import Stack def postfixEval(postfixExpr): operandStack = Stack() tokenList = postfixExpr.split() for token in tokenList: if token in \"0123456789\": operandStack.push(int(token)) else: operand2 = operandStack.pop() operand1 = operandStack.pop() result = doMath(token,operand1,operand2) operandStack.push(result) return operandStack.pop() def doMath(op, op1, op2): #Does math based on what op is passed as. if op == \"*\": return op1 * op2 elif op == \"\/\": return op1 \/ op2 elif op == \"+\": return op1 + op2 else: return op1 - op2 def main(): print(postfixEval('7 8 + 3 2 + \/')) main()  "
},
{
  "id": "question1_100_4",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#question1_100_4",
  "type": "Reading Question",
  "number": "3.9.3.1",
  "title": "",
  "body": " What does the prefix expression of this infix expression look like: ((A+B)*(C-D)) if this were modeled using a stack with the top being the end of the expression and the bottom being the beginning of the expression?   D  C  -  B  A  +  *  "
},
{
  "id": "infix-1",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#infix-1",
  "type": "Reading Question",
  "number": "3.9.3.2",
  "title": "",
  "body": " Without using the activecode infixToPostfix function, convert the following expression to postfix 10 + 3 * 5 \/ (16 - 4) .  Correct. The numbers appear to be in the correct order check your operators "
},
{
  "id": "infix-2",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#infix-2",
  "type": "Reading Question",
  "number": "3.9.3.3",
  "title": "",
  "body": " What is the result of evaluating the following: 17 10 + 3 * 9 \/ =   Correct. "
},
{
  "id": "infix-3",
  "level": "2",
  "url": "linear-basic_infix-prefix-and-postfix-expressions.html#infix-3",
  "type": "Reading Question",
  "number": "3.9.3.4",
  "title": "",
  "body": " Modify the infixToPostfix function above so that it can convert the following expression. Once you have the answer from the code put it in the blank below: 5 * 3 \/(4 - 2) .  Correct. The numbers appear to be in the correct order check your operators "
},
{
  "id": "linear-basic_what-is-a-queue",
  "level": "1",
  "url": "linear-basic_what-is-a-queue.html",
  "type": "Section",
  "number": "3.10",
  "title": "What Is a Queue?",
  "body": " What Is a Queue?   queue A queue is an ordered collection of items where the addition of new items happens at one end, called the rear, and the removal of existing items occurs at the other end, commonly called the front. As an element enters the queue it starts at the rear and makes its way toward the front, waiting until that time when it is the next element to be removed.  FIFO The most recently added item in the queue must wait at the end of the collection. The item that has been in the collection the longest is at the front. This ordering principle is sometimes called FIFO , first-in first-out . It is also known as first-come first-served.  The simplest example of a queue is the typical line that we all participate in from time to time. We wait in a line for a movie, we wait in the check-out line at a grocery store, and we wait in the cafeteria line (so that we can pop the tray stack). Well-behaved lines, or queues, are very restrictive in that they have only one way in and only one way out. There is no jumping in the middle and no leaving before you have waited the necessary amount of time to get to the front. shows a simple queue of Python data objects.  Figure 1: A queue of strings  Computer science also has common examples of queues. Our computer laboratory has 30 computers networked with a single printer. When students want to print, their print tasks get in line with all the other printing tasks that are waiting. The first task in is the next to be completed. If you are last in line, you must wait for all the other tasks to print ahead of you. We will explore this interesting example in more detail later.  In addition to printing queues, operating systems use a number of different queues to control processes within a computer. The scheduling of what gets done next is typically based on a queuing algorithm that tries to execute programs as quickly as possible and serve as many users as it can. Also, as we type, sometimes keystrokes get ahead of the characters that appear on the screen. This is due to the computer doing other work at that moment. The keystrokes are being placed in a queue-like buffer so that they can eventually be displayed on the screen in the proper order.     "
},
{
  "id": "linear-basic_what-is-a-queue-2",
  "level": "2",
  "url": "linear-basic_what-is-a-queue.html#linear-basic_what-is-a-queue-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "queue "
},
{
  "id": "linear-basic_what-is-a-queue-3",
  "level": "2",
  "url": "linear-basic_what-is-a-queue.html#linear-basic_what-is-a-queue-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "FIFO first-in first-out "
},
{
  "id": "fig-qubasicqueue1",
  "level": "2",
  "url": "linear-basic_what-is-a-queue.html#fig-qubasicqueue1",
  "type": "Figure",
  "number": "3.10.1",
  "title": "",
  "body": "Figure 1: A queue of strings "
},
{
  "id": "linear-basic_the-queue-abstract-data-type",
  "level": "1",
  "url": "linear-basic_the-queue-abstract-data-type.html",
  "type": "Section",
  "number": "3.11",
  "title": "The Queue Abstract Data Type",
  "body": " The Queue Abstract Data Type  queue abstract data type queue ADT The queue abstract data type or queue ADT is defined by the following structure and operations. A queue is structured, as described above, as an ordered collection of items which are added at one end, called the rear, and removed from the other end, called the front. Queues maintain a first-in-first-out (FIFO) ordering property. The standard queue operations are given below.    queue<dataType> queueName creates a new queue that is empty. It returns an empty queue.    push(item) adds a new item to the rear of the queue. It needs the item and returns nothing.    pop() removes the front item from the queue. It needs no parameters. The queue is modified.    empty() tests to see whether the queue is empty. It needs no parameters and returns a Boolean value.    size() returns the number of items in the queue. It needs no parameters and returns an integer.    front() returns the first item in the queue without removing the item.    back() returns the last item in the queue without removing the item.    As an example, if we assume that q is a queue that has been created and is currently empty, then shows the results of a sequence of queue operations. The queue contents are shown such that the front is on the right. 4 was the first item pushed so it is the first item returned by dequeue.   Example Queue Operations    Queue Operation    Queue Contents    Return Value      q.empty()    []    true      q.push(4)    [4]        q.push(12)    [12,4]        q.push(3)    [3,12,4]        q.size()    [3,12,4]    3      q.empty()    [3,12,4]    false      q.push(97)    [97,3,12,4]        q.pop()    [97,3,12]        q.pop()    [97,3]        q.size()    [97,3]    2        "
},
{
  "id": "linear-basic_the-queue-abstract-data-type-2",
  "level": "2",
  "url": "linear-basic_the-queue-abstract-data-type.html#linear-basic_the-queue-abstract-data-type-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "queue abstract data type queue ADT first-in-first-out (FIFO) "
},
{
  "id": "linear-basic_tbl-queueoperations",
  "level": "2",
  "url": "linear-basic_the-queue-abstract-data-type.html#linear-basic_tbl-queueoperations",
  "type": "Table",
  "number": "3.11.1",
  "title": "",
  "body": " Example Queue Operations    Queue Operation    Queue Contents    Return Value      q.empty()    []    true      q.push(4)    [4]        q.push(12)    [12,4]        q.push(3)    [3,12,4]        q.size()    [3,12,4]    3      q.empty()    [3,12,4]    false      q.push(97)    [97,3,12,4]        q.pop()    [97,3,12]        q.pop()    [97,3]        q.size()    [97,3]    2    "
},
{
  "id": "linear-basic_using-a-queue-in-c",
  "level": "1",
  "url": "linear-basic_using-a-queue-in-c.html",
  "type": "Section",
  "number": "3.12",
  "title": "Using a Queue in C++",
  "body": " Using a Queue in C++  Now we will turn our attention to using the queue data structure with the help of the Standard Template Library (STL) in C++.  As we described in Chapter 1, in C++, as in any object-oriented programming language, the implementation of choice for an abstract data type such as a queue is a class in which the queue operations are implemented as methods. Fortunately, the STL already has a well written implementation of the queue class.  In following queue implementation ( ) as push operations occur, new items are always added on the rear end of the queue and pop operations will manipulate the opposite side, the front end.   Queue Implementation  C++ Implementation #include <iostream> #include <queue> \/\/ Using an STL queue using namespace std; int main() { queue<int> newQueue; newQueue.push(3); newQueue.push(8); newQueue.push(15); cout << \"Queue Empty? \" << newQueue.empty() << endl; cout << \"Queue Size: \" << newQueue.size() << endl; cout << \"Top Element of the Queue: \" << newQueue.front() << endl; newQueue.pop(); cout << \"Top Element of the Queue: \" << newQueue.front() << endl; return 0; }  Python Implementation class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.insert(0,item) def pop(self): return self.items.pop() def front(self): return self.items[len(self.items)-1]; def size(self): return len(self.items) def main(): q=Queue() q.push(3) q.push(8) q.push(15) print(\"Queue Empty? \", q.isEmpty()) print(\"Queue Size: \", q.size()) print(\"Front Element of the Queue: \", q.front()) q.pop(); print(\"Front Element of the Queue: \", q.front()) main()    Reading Question   Suppose you have the following series of queue operations.  queue<int> q; q.push(10); q.push(20); q.push(30); q.pop();  What items are left on the queue?     10, 20    Remember the first item added to the queue is the first item removed. Remember FIFO.      20, 30    Yes, first in first out means that the 10 is now gone.      10, 30    Queues and stacks are both data structures where you can only access the first or the last items.      10, 20, 30    Oops, maybe you missed the pop call at the end?         "
},
{
  "id": "linear-basic_using-a-queue-in-c-4",
  "level": "2",
  "url": "linear-basic_using-a-queue-in-c.html#linear-basic_using-a-queue-in-c-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "rear front "
},
{
  "id": "expl-lst-queuecode1-cpp",
  "level": "2",
  "url": "linear-basic_using-a-queue-in-c.html#expl-lst-queuecode1-cpp",
  "type": "Exploration",
  "number": "3.12.1",
  "title": "Queue Implementation.",
  "body": " Queue Implementation  C++ Implementation #include <iostream> #include <queue> \/\/ Using an STL queue using namespace std; int main() { queue<int> newQueue; newQueue.push(3); newQueue.push(8); newQueue.push(15); cout << \"Queue Empty? \" << newQueue.empty() << endl; cout << \"Queue Size: \" << newQueue.size() << endl; cout << \"Top Element of the Queue: \" << newQueue.front() << endl; newQueue.pop(); cout << \"Top Element of the Queue: \" << newQueue.front() << endl; return 0; }  Python Implementation class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.insert(0,item) def pop(self): return self.items.pop() def front(self): return self.items[len(self.items)-1]; def size(self): return len(self.items) def main(): q=Queue() q.push(3) q.push(8) q.push(15) print(\"Queue Empty? \", q.isEmpty()) print(\"Queue Size: \", q.size()) print(\"Front Element of the Queue: \", q.front()) q.pop(); print(\"Front Element of the Queue: \", q.front()) main()  "
},
{
  "id": "queue_1",
  "level": "2",
  "url": "linear-basic_using-a-queue-in-c.html#queue_1",
  "type": "Reading Question",
  "number": "3.12.1",
  "title": "",
  "body": " Suppose you have the following series of queue operations.  queue<int> q; q.push(10); q.push(20); q.push(30); q.pop();  What items are left on the queue?     10, 20    Remember the first item added to the queue is the first item removed. Remember FIFO.      20, 30    Yes, first in first out means that the 10 is now gone.      10, 30    Queues and stacks are both data structures where you can only access the first or the last items.      10, 20, 30    Oops, maybe you missed the pop call at the end?    "
},
{
  "id": "linear-basic_simulation-hot-potato",
  "level": "1",
  "url": "linear-basic_simulation-hot-potato.html",
  "type": "Section",
  "number": "3.13",
  "title": "Simulation: Hot Potato",
  "body": " Simulation: Hot Potato  One of the typical applications for showing a queue in action is to simulate a real situation that requires data to be managed in a FIFO manner. To begin, let's consider the children's game Hot Potato. In this game (see ) children line up in a circle and pass an item from neighbor to neighbor as fast as they can. At a certain point in the game, the action is stopped and the child who has the item (the potato) is removed from the circle. Play continues until only one child is left.   A Six Person Game of Hot Potato    This game is a modern-day equivalent of the famous Josephus problem. Based on a legend about the famous first-century historian Flavius Josephus, the story is told that in the Jewish revolt against Rome, Josephus and 39 of his comrades held out against the Romans in a cave. With defeat imminent, they decided that they would rather die than be slaves to the Romans. They arranged themselves in a circle. One man was designated as number one, and proceeding clockwise they killed every seventh man. Josephus, according to the legend, was among other things an accomplished mathematician. He instantly figured out where he ought to sit in order to be the last to go. When the time came, instead of killing himself, he joined the Roman side. You can find many different versions of this story. Some count every third man and some allow the last man to escape on a horse. In any case, the idea is the same.  We will implement a general simulation of Hot Potato. Our program will input an array of names and a constant, call it num, to be used for counting. It will return the name of the last person remaining after repetitive counting by num . What happens at that point is up to you.  To simulate the circle, we will use a queue (see ). Assume that the child holding the potato will be at the front of the queue. Upon passing the potato, the simulation will simply dequeue and then immediately enqueue that child, putting her at the end of the line. She will then wait until all the others have been at the front before it will be her turn again. After num dequeue\/enqueue operations, the child at the front will be removed permanently and another cycle will begin. This process will continue until only one name remains (the size of the queue is 1).   A Queue Implementation of Hot Potato    The program is shown in . A call to the hotPotato function using 7 as the counting constant returns Susan .   Hot Potato Simulator  C++ Implementation \/\/This program creates a simulation of hot potato. #include <iostream> #include <queue> #include <string> using namespace std; string hotPotato(string nameArray[], int num) { queue<string> simqueue; int namelsLenght = nameArray->length(); for (int i = 0; i < namelsLenght; i++) { \/\/puts the entire array into a queue. simqueue.push(nameArray[i]); } while (simqueue.size() > 1) { \/\/loop continues until there is one remaining item. for (int i = 0; i < num; i++) { simqueue.push(simqueue.front()); simqueue.pop(); } simqueue.pop(); } return simqueue.front(); } int main() { string s[] = {\"Bill\", \"David\", \"Susan\", \"Jane\", \"Kent\", \"Brad\"}; cout << hotPotato(s, 7) << endl; return 0; }  Python Implementation #This program creates a simulation of hot potato. from pythonds.basic.queue import Queue def hotPotato(namelist, num): simqueue = Queue() for name in namelist: #adds all items in the list into a queue. simqueue.enqueue(name) while simqueue.size() > 1: #continues until there is only one remaining item. for i in range(num): simqueue.enqueue(simqueue.dequeue()) simqueue.dequeue() return simqueue.dequeue() def main(): print(hotPotato([\"Bill\",\"David\",\"Susan\",\"Jane\",\"Kent\",\"Brad\"],7)) main()   Note that in this example the value of the counting constant is greater than the number of names in the array. This is not a problem since the queue acts like a circle and counting continues back at the beginning until the value is reached. Also, notice that the array is loaded into the queue such that the first name on the array will be at the front of the queue. Bill in this case is the first item in the array and therefore moves to the front of the queue. A variation of this implementation, described in the exercises, allows for a random counter.     "
},
{
  "id": "fig-quhotpotato",
  "level": "2",
  "url": "linear-basic_simulation-hot-potato.html#fig-quhotpotato",
  "type": "Figure",
  "number": "3.13.1",
  "title": "",
  "body": " A Six Person Game of Hot Potato   "
},
{
  "id": "linear-basic_simulation-hot-potato-5",
  "level": "2",
  "url": "linear-basic_simulation-hot-potato.html#linear-basic_simulation-hot-potato-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "simulation "
},
{
  "id": "fig-qupotatoqueue",
  "level": "2",
  "url": "linear-basic_simulation-hot-potato.html#fig-qupotatoqueue",
  "type": "Figure",
  "number": "3.13.2",
  "title": "",
  "body": " A Queue Implementation of Hot Potato   "
},
{
  "id": "expl-lst-josephussim-cpp",
  "level": "2",
  "url": "linear-basic_simulation-hot-potato.html#expl-lst-josephussim-cpp",
  "type": "Exploration",
  "number": "3.13.1",
  "title": "Hot Potato Simulator.",
  "body": " Hot Potato Simulator  C++ Implementation \/\/This program creates a simulation of hot potato. #include <iostream> #include <queue> #include <string> using namespace std; string hotPotato(string nameArray[], int num) { queue<string> simqueue; int namelsLenght = nameArray->length(); for (int i = 0; i < namelsLenght; i++) { \/\/puts the entire array into a queue. simqueue.push(nameArray[i]); } while (simqueue.size() > 1) { \/\/loop continues until there is one remaining item. for (int i = 0; i < num; i++) { simqueue.push(simqueue.front()); simqueue.pop(); } simqueue.pop(); } return simqueue.front(); } int main() { string s[] = {\"Bill\", \"David\", \"Susan\", \"Jane\", \"Kent\", \"Brad\"}; cout << hotPotato(s, 7) << endl; return 0; }  Python Implementation #This program creates a simulation of hot potato. from pythonds.basic.queue import Queue def hotPotato(namelist, num): simqueue = Queue() for name in namelist: #adds all items in the list into a queue. simqueue.enqueue(name) while simqueue.size() > 1: #continues until there is only one remaining item. for i in range(num): simqueue.enqueue(simqueue.dequeue()) simqueue.dequeue() return simqueue.dequeue() def main(): print(hotPotato([\"Bill\",\"David\",\"Susan\",\"Jane\",\"Kent\",\"Brad\"],7)) main()  "
},
{
  "id": "linear-basic_simulation-printing-tasks",
  "level": "1",
  "url": "linear-basic_simulation-printing-tasks.html",
  "type": "Section",
  "number": "3.14",
  "title": "Simulation: Printing Tasks",
  "body": " Simulation: Printing Tasks   A more interesting simulation allows us to study the behavior of the printing queue described earlier in this section. Recall that as students send printing tasks to the shared printer, the tasks are placed in a queue to be processed in a first-come first-served manner. Many questions arise with this configuration. The most important of these might be whether the printer is capable of handling a certain amount of work. If it cannot, students will be waiting too long for printing and may miss their next class.  Consider the following situation in a computer science laboratory. On any average day about 10 students are working in the lab at any given hour. These students typically print up to twice during that time, and the length of these tasks ranges from 1 to 20 pages. The printer in the lab is older, capable of processing 10 pages per minute of draft quality. The printer could be switched to give better quality, but then it would produce only five pages per minute. The slower printing speed could make students wait too long. What page rate should be used?  We could decide by building a simulation that models the laboratory. We will need to construct representations for students, printing tasks, and the printer ( ). As students submit printing tasks, we will add them to a waiting list, a queue of print tasks attached to the printer. When the printer completes a task, it will look at the queue to see if there are any remaining tasks to process. Of interest for us is the average amount of time students will wait for their papers to be printed. This is equal to the average amount of time a task waits in the queue.   Computer Science Laboratory Printing Queue    To model this situation we need to use some probabilities. For example, students may print a paper from 1 to 20 pages in length. If each length from 1 to 20 is equally likely, the actual length for a print task can be simulated by using a random number between 1 and 20 inclusive. This means that there is equal chance of any length from 1 to 20 appearing.  If there are 10 students in the lab and each prints twice, then there are 20 print tasks per hour on average. What is the chance that at any given second, a print task is going to be created? The way to answer this is to consider the ratio of tasks to time. Twenty tasks per hour means that on average there will be one task every 180 seconds:   For every second we can simulate the chance that a print task occurs by generating a random number between 1 and 180 inclusive. If the number is 180, we say a task has been created. Note that it is possible that many tasks could be created in a row or we may wait quite a while for a task to appear. That is the nature of simulation. You want to simulate the real situation as closely as possible given that you know general parameters.    Main Simulation Steps  Here is the main simulation.    Create a queue of print tasks. Each task will be given a timestamp upon its arrival. The queue is empty to start.    For each second ( currentSecond ):    Does a new print task get created? If so, add it to the queue with the currentSecond as the timestamp.    If the printer is not busy and if a task is waiting,    Remove the next task from the print queue and assign it to the printer.    Subtract the timestamp from the currentSecond to compute the waiting time for that task.    Append the waiting time for that task to a list for later processing.    Based on the number of pages in the print task, figure out how much time will be required.      The printer now does one second of printing if necessary. It also subtracts one second from the time required for that task.    If the task has been completed, in other words the time required has reached zero, the printer is no longer busy.      After the simulation is complete, compute the average waiting time from the list of waiting times generated.      C++ Implementation  To design this simulation we will create classes for the three real-world objects described above: Printer , Task , and PrintQueue .  The Printer class ( ) will need to track whether it has a current task. If it does, then it is busy (lines 13–17) and the amount of time needed can be computed from the number of pages in the task. The constructor will also allow the pages-per-minute setting to be initialized. The tick method decrements the internal timer and sets the printer to idle (line 11) if the task is completed.   The Printer class  class Printer { public: Printer(int pagesPerMinute) { pagerate = pagesPerMinute; timeRemaining=0; working = false; } void tick() { \/\/Performed once per second in the simulation. if (working) { \/\/ If we're working on something... timeRemaining--;\/\/ Subtract the remaining time. if (timeRemaining <= 0) working = false; \/\/ When finished, stop working. } } bool busy() { return working; } void startNext(Task newtask) { currentTask=newtask; timeRemaining=newtask.getPages()*60\/pagerate; working = true; } private: int pagerate; \/\/ unit is pages per minute. Task currentTask = {0};\/\/ Current task. default is a dummy value. bool working; \/\/ Are we working on the current task? int timeRemaining; \/\/ Time remaining, in \"seconds\". };   The Task class ( ) will represent a single printing task. When the task is created, a random number generator will provide a length from 1 to 20 pages. We have chosen to use the rand() function to provide the random number using the format below. srand() is used to give different random numbers each time the program is executed by setting the random numbers based on the computer's current time.  >> srand(time(NULL)); >>> rand()%20+1; 18 >>> rand()%20+1; 8  Each task will also need to keep a timestamp to be used for computing waiting time. This timestamp will represent the time that the task was created and placed in the printer queue. The waitTime method can then be used to retrieve the amount of time spent in the queue before printing begins.   The Task class  class Task { public: Task(int time) { timestamp = time; pages=(rand()%20) + 1; } int getStamp() { return timestamp; } int getPages() { return pages; } int waitTime(int currenttime) { return (currenttime - timestamp); } private: int timestamp; int pages; };   The main simulation ( ) implements the algorithm described above. The printQueue object is an instance of our existing queue ADT. A boolean helper function, newPrintTask , decides whether a new printing task has been created. We have again chosen to use the randrange function from the random module to return a random integer between 1 and 180. Print tasks arrive once every 180 seconds. By arbitrarily choosing 180 from the range of random integers (line 32), we can simulate this random event. The simulation function allows us to set the total time and the pages per minute for the printer.   The main simulation function  void simulation(int numSeconds, int pagesPerMinute) { Printer labprinter(pagesPerMinute); \/\/The Queue ADT from the standard container library. queue<Task> printQueue; \/\/A vector of wait-times for each task. vector<int> waitingTimes; \/\/For every second in the simulation... for (int i = 0; i < numSeconds; i++) { \/\/If there's a new printing task, add it to the queue. if (newPrintTask()) { Task task(i);\/\/Create it... printQueue.push(task);\/\/Push it. } \/\/If the printer is not busy and the queue is not empty: if (!labprinter.busy() &&!printQueue.empty()) { Task nextTask = printQueue.front(); \/\/ Assign a new task from the queue. printQueue.pop(); \/\/ Remove it from the front \/\/Add the estimated wait time to our vector. waitingTimes.push_back(nextTask.waitTime(i)); labprinter.startNext(nextTask); } \/\/Process the current task. labprinter.tick(); } \/\/Average out every wait time for the simulation. float total=0; for (int waitTime : waitingTimes) total += waitTime; cout << \"Average Wait \"<<total\/waitingTimes.size()<<\" secs \"<<printQueue.size()<<\" tasks remaining.\"<<endl; }   When we run the simulation, we should not be concerned that the results are different each time. This is due to the probabilistic nature of the random numbers. We are interested in the trends that may be occurring as the parameters to the simulation are adjusted. Here are some results.  First, we will run the simulation for a period of 60 minutes (3,600 seconds) using a page rate of five pages per minute. In addition, we will run 10 independent trials. Remember that because the simulation works with random numbers each run will return different results.  >>>for (int i=0; i<10; i++) { simulation(3600,5); } Average Wait 165.38 secs 2 tasks remaining. Average Wait 95.07 secs 1 tasks remaining. Average Wait 65.05 secs 2 tasks remaining. Average Wait 99.74 secs 1 tasks remaining. Average Wait 17.27 secs 0 tasks remaining. Average Wait 239.61 secs 5 tasks remaining. Average Wait 75.11 secs 1 tasks remaining. Average Wait 48.33 secs 0 tasks remaining. Average Wait 39.31 secs 3 tasks remaining. Average Wait 376.05 secs 1 tasks remaining.  After running our 10 trials we can see that the mean average wait time is 122.09 seconds. You can also see that there is a large variation in the average weight time with a minimum average of 17.27 seconds and a maximum of 376.05 seconds. You may also notice that in only two of the cases were all the tasks completed.  Now, we will adjust the page rate to 10 pages per minute, and run the 10 trials again, with a faster page rate our hope would be that more tasks would be completed in the one hour time frame.  >>>for (int i=0; i<10; i++) { simulation(3600,10); } Average Wait 1.29 secs 0 tasks remaining. Average Wait 7.00 secs 0 tasks remaining. Average Wait 28.96 secs 1 tasks remaining. Average Wait 13.55 secs 0 tasks remaining. Average Wait 12.67 secs 0 tasks remaining. Average Wait 6.46 secs 0 tasks remaining. Average Wait 22.33 secs 0 tasks remaining. Average Wait 12.39 secs 0 tasks remaining. Average Wait 7.27 secs 0 tasks remaining. Average Wait 18.17 secs 0 tasks remaining.  You can run the simulation for yourself in ActiveCode 2.   \/\/Program that simulates printing task management. #include <iostream> #include <queue> #include <vector> #include <cstdlib> using namespace std; class Task { public: Task(int time) { timestamp = time; pages=(rand()%20) + 1; } int getStamp() { return timestamp; } int getPages() { return pages; } int waitTime(int currenttime) { return (currenttime - timestamp); } private: int timestamp; int pages; }; class Printer { public: Printer(int pagesPerMinute) { pagerate = pagesPerMinute; timeRemaining=0; working = false; } void tick() { \/\/Performed once per second in the simulation. if (working) { \/\/ If we're working on something... timeRemaining--;\/\/ Subtract the remaining time. if (timeRemaining <= 0) working = false; \/\/ When finished, stop working. } } bool busy() { return working; } void startNext(Task newtask) { currentTask=newtask; timeRemaining=newtask.getPages()*60\/pagerate; working = true; } private: int pagerate; \/\/ unit is pages per minute. Task currentTask = {0};\/\/ Current task. default is a dummy value. bool working; \/\/ Are we working on the current task? int timeRemaining; \/\/ Time remaining, in \"seconds\". }; bool newPrintTask() { \/\/uses random to decide if there is a new print task. \/\/generates a random number from 1...180, and returns \/\/a boolean indicating whether or not it equals 180. return (rand() % 180 + 1) == 180; } void simulation(int numSeconds, int pagesPerMinute) { Printer labprinter(pagesPerMinute); \/\/The Queue ADT from the standard container library. queue<Task> printQueue; \/\/A vector of wait-times for each task. vector<int> waitingTimes; \/\/For every second in the simulation... for (int i = 0; i < numSeconds; i++) { \/\/If there's a new printing task, add it to the queue. if (newPrintTask()) { Task task(i);\/\/Create it... printQueue.push(task);\/\/Push it. } \/\/If the printer is not busy and the queue is not empty: if (!labprinter.busy() &&!printQueue.empty()) { Task nextTask = printQueue.front(); \/\/ Assign a new task from the queue. printQueue.pop(); \/\/ Remove it from the front \/\/Add the estimated wait time to our vector. waitingTimes.push_back(nextTask.waitTime(i)); labprinter.startNext(nextTask); } \/\/Process the current task. labprinter.tick(); } \/\/Average out every wait time for the simulation. float total=0; for (int waitTime : waitingTimes) total += waitTime; cout << \"Average Wait \"<<total\/waitingTimes.size()<<\" secs \"<<printQueue.size()<<\" tasks remaining.\"<<endl; } int main() { \/\/Seed random number generator with the current time \/\/This ensures a unique random simulation every time it's ran. srand(time(NULL)); for (int i=0; i<10; i++) { simulation(3600, 5); } return 0; }     Discussion  We were trying to answer a question about whether the current printer could handle the task load if it were set to print with a better quality but slower page rate. The approach we took was to write a simulation that modeled the printing tasks as random events of various lengths and arrival times.  The output above shows that with 5 pages per minute printing, the average waiting time varied from a low of 17 seconds to a high of 376 seconds (about 6 minutes). With a faster printing rate, the low value was 1 second with a high of only 28. In addition, in 8 out of 10 runs at 5 pages per minute there were print tasks still waiting in the queue at the end of the hour.  Therefore, we are perhaps persuaded that slowing the printer down to get better quality may not be a good idea. Students cannot afford to wait that long for their papers, especially when they need to be getting on to their next class. A six-minute wait would simply be too long.  This type of simulation analysis allows us to answer many questions, commonly known as what if questions. All we need to do is vary the parameters used by the simulation and we can simulate any number of interesting behaviors. For example,    What if enrollment goes up and the average number of students increases by 20?    What if it is Saturday and students are not needing to get to class? Can they afford to wait?    What if the size of the average print task decreases since C++ is such a powerful language and programs tend to be much shorter?    These questions could all be answered by modifying the above simulation. However, it is important to remember that the simulation is only as good as the assumptions that are used to build it. Real data about the number of print tasks per hour and the number of students per hour was necessary to construct a robust simulation.   Self Check  How would you modify the printer simulation to reflect a larger number of students? Suppose that the number of students was doubled. You may need to make some reasonable assumptions about how this simulation was put together but what would you change? Modify the code. Also suppose that the length of the average print task was cut in half. Change the code to reflect that change. Finally how would you parameterize the number of students, rather than changing the code we would like to make the number of students a parameter of the simulation.       "
},
{
  "id": "fig-qulabsim",
  "level": "2",
  "url": "linear-basic_simulation-printing-tasks.html#fig-qulabsim",
  "type": "Figure",
  "number": "3.14.1",
  "title": "",
  "body": " Computer Science Laboratory Printing Queue   "
},
{
  "id": "linear-basic_lst-printer",
  "level": "2",
  "url": "linear-basic_simulation-printing-tasks.html#linear-basic_lst-printer",
  "type": "Listing",
  "number": "3.14.2",
  "title": "The <code class=\"code-inline tex2jax_ignore\">Printer<\/code> class",
  "body": " The Printer class  class Printer { public: Printer(int pagesPerMinute) { pagerate = pagesPerMinute; timeRemaining=0; working = false; } void tick() { \/\/Performed once per second in the simulation. if (working) { \/\/ If we're working on something... timeRemaining--;\/\/ Subtract the remaining time. if (timeRemaining <= 0) working = false; \/\/ When finished, stop working. } } bool busy() { return working; } void startNext(Task newtask) { currentTask=newtask; timeRemaining=newtask.getPages()*60\/pagerate; working = true; } private: int pagerate; \/\/ unit is pages per minute. Task currentTask = {0};\/\/ Current task. default is a dummy value. bool working; \/\/ Are we working on the current task? int timeRemaining; \/\/ Time remaining, in \"seconds\". };  "
},
{
  "id": "linear-basic_lst-task",
  "level": "2",
  "url": "linear-basic_simulation-printing-tasks.html#linear-basic_lst-task",
  "type": "Listing",
  "number": "3.14.3",
  "title": "The <code class=\"code-inline tex2jax_ignore\">Task<\/code> class",
  "body": " The Task class  class Task { public: Task(int time) { timestamp = time; pages=(rand()%20) + 1; } int getStamp() { return timestamp; } int getPages() { return pages; } int waitTime(int currenttime) { return (currenttime - timestamp); } private: int timestamp; int pages; };  "
},
{
  "id": "linear-basic_lst-qumainsim",
  "level": "2",
  "url": "linear-basic_simulation-printing-tasks.html#linear-basic_lst-qumainsim",
  "type": "Listing",
  "number": "3.14.4",
  "title": "The main simulation function",
  "body": " The main simulation function  void simulation(int numSeconds, int pagesPerMinute) { Printer labprinter(pagesPerMinute); \/\/The Queue ADT from the standard container library. queue<Task> printQueue; \/\/A vector of wait-times for each task. vector<int> waitingTimes; \/\/For every second in the simulation... for (int i = 0; i < numSeconds; i++) { \/\/If there's a new printing task, add it to the queue. if (newPrintTask()) { Task task(i);\/\/Create it... printQueue.push(task);\/\/Push it. } \/\/If the printer is not busy and the queue is not empty: if (!labprinter.busy() &&!printQueue.empty()) { Task nextTask = printQueue.front(); \/\/ Assign a new task from the queue. printQueue.pop(); \/\/ Remove it from the front \/\/Add the estimated wait time to our vector. waitingTimes.push_back(nextTask.waitTime(i)); labprinter.startNext(nextTask); } \/\/Process the current task. labprinter.tick(); } \/\/Average out every wait time for the simulation. float total=0; for (int waitTime : waitingTimes) total += waitTime; cout << \"Average Wait \"<<total\/waitingTimes.size()<<\" secs \"<<printQueue.size()<<\" tasks remaining.\"<<endl; }  "
},
{
  "id": "linear-basic_discussion-8",
  "level": "2",
  "url": "linear-basic_simulation-printing-tasks.html#linear-basic_discussion-8",
  "type": "Note",
  "number": "3.14.5",
  "title": "Self Check.",
  "body": " Self Check  How would you modify the printer simulation to reflect a larger number of students? Suppose that the number of students was doubled. You may need to make some reasonable assumptions about how this simulation was put together but what would you change? Modify the code. Also suppose that the length of the average print task was cut in half. Change the code to reflect that change. Finally how would you parameterize the number of students, rather than changing the code we would like to make the number of students a parameter of the simulation.  "
},
{
  "id": "linear-basic_what-is-a-deque",
  "level": "1",
  "url": "linear-basic_what-is-a-deque.html",
  "type": "Section",
  "number": "3.15",
  "title": "What Is a Deque?",
  "body": " What Is a Deque?  deque A deque , also known as a double-ended queue, is an ordered collection of items similar to the queue. It has two ends, a front and a rear, and the items remain positioned in the collection. What makes a deque different is the unrestrictive nature of adding and removing items. New items can be added at either the front or the rear. Likewise, existing items can be removed from either end. In a sense, this hybrid linear structure provides all the capabilities of stacks and queues in a single data structure. shows a deque of Python data objects.  It is important to note that even though the deque can assume many of the characteristics of stacks and queues, it does not require the LIFO and FIFO orderings that are enforced by those data structures. It is up to you to make consistent use of the addition and removal operations.  Figure 1: A Deque of Python Data Objects     "
},
{
  "id": "linear-basic_what-is-a-deque-2",
  "level": "2",
  "url": "linear-basic_what-is-a-deque.html#linear-basic_what-is-a-deque-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "deque "
},
{
  "id": "fig-basicdeque",
  "level": "2",
  "url": "linear-basic_what-is-a-deque.html#fig-basicdeque",
  "type": "Figure",
  "number": "3.15.1",
  "title": "",
  "body": "Figure 1: A Deque of Python Data Objects "
},
{
  "id": "linear-basic_the-deque-abstract-data-type",
  "level": "1",
  "url": "linear-basic_the-deque-abstract-data-type.html",
  "type": "Section",
  "number": "3.16",
  "title": "The Deque Abstract Data Type",
  "body": " The Deque Abstract Data Type  The deque abstract data type is defined by the following structure and operations. A deque is structured, as described above, as an ordered collection of items where items are added and removed from either end, either front or rear. The deque operations are given below.    deque<dataType> dequeName creates a new deque that is empty. It returns an empty deque.    push_front(item) adds a new item to the front of the deque. It needs the item and returns nothing.    push_back(item) adds a new item to the rear of the deque. It needs the item and returns nothing.    pop_front() removes the front item from the deque. It needs no parameters. The deque is modified.    pop_back() removes the rear item from the deque. It needs no parameters. The deque is modified.    empty() tests to see whether the deque is empty. It needs no parameters and returns a boolean value.    size() returns the number of items in the deque. It needs no parameters and returns an integer.    As an example, if we assume that d is a deque that has been created and is currently empty, then shows the results of a sequence of deque operations. Note that the contents in front are listed on the right. It is very important to keep track of the front and the rear as you move items in and out of the collection as things can get a bit confusing.   Examples of Deque Operations    Deque Operation    Deque Contents    Return Value      d.empty()    []    True      d.push_back(4)    [4]        d.push_back(17)    [17,4]        d.push_front(93)    [17,4,93]        d.push_front(65)    [17,4,93,65]        d.size()    [17,4,93,65]    4      d.empty()    [17,4,93,65]    False      d.push_back(25)    [25,17,4,93,65]        d.pop_back()    [17,4,93,65]        d.pop_front()    [17,4,93]          "
},
{
  "id": "linear-basic_tbl-dequeoperations",
  "level": "2",
  "url": "linear-basic_the-deque-abstract-data-type.html#linear-basic_tbl-dequeoperations",
  "type": "Table",
  "number": "3.16.1",
  "title": "",
  "body": " Examples of Deque Operations    Deque Operation    Deque Contents    Return Value      d.empty()    []    True      d.push_back(4)    [4]        d.push_back(17)    [17,4]        d.push_front(93)    [17,4,93]        d.push_front(65)    [17,4,93,65]        d.size()    [17,4,93,65]    4      d.empty()    [17,4,93,65]    False      d.push_back(25)    [25,17,4,93,65]        d.pop_back()    [17,4,93,65]        d.pop_front()    [17,4,93]      "
},
{
  "id": "linear-basic_using-a-deque-in-c",
  "level": "1",
  "url": "linear-basic_using-a-deque-in-c.html",
  "type": "Section",
  "number": "3.17",
  "title": "Using a Deque in C++",
  "body": " Using a Deque in C++  As we have done in previous sections, we will use the Standard Template Library (STL) of C++ to use a Deque. Again, the Deque library from STL will provide a very nice set of methods upon which to build the details of the deque. Our code ( ) will assume that the front of the deque is at position 0 in the array.   Dequeue Implementation  C++ Implementation \/\/Example code of a deque. #include <iostream> #include <deque> #include <string> using namespace std; int main() { deque<string> d; cout << \"Deque Empty? \" << d.empty() << endl; d.push_back(\"Zebra\"); cout << \"Deque Empty? \" << d.empty() << endl; d.push_front(\"Turtle\"); \/\/pushes to the front of the deque. d.push_front(\"Panda\"); d.push_back(\"Catfish\"); \/\/pushes to the back of the deque. d.push_back(\"Giraffe\"); cout << \"Deque Size: \" << d.size() << endl; cout << \"Item at the front: \" << d.front() << endl; cout << \"Item at the back: \" << d.back() << endl; cout << endl << \"Items in the Deque: \" << endl; int dsize = d.size(); for(int i = 0; i < dsize; i++){ \/\/prints each item in the deque. cout << d.at(i) << \" \"; } cout << endl; d.pop_back(); d.pop_front(); cout << endl << \"Item at the front: \" << d.front() << endl; cout << \"Itm at the back: \" << d.back() << endl; cout << \"Deque Size: \" << d.size() << endl; cout << endl << \"Items in the Deque: \" << endl; int dsize2 = d.size(); for(int i = 0; i < dsize2; i++){ \/\/prints each item in the deque. cout << d.at(i) << \" \"; return 0; } }  Python Implementation #Example code of a deque. class Deque: def __init__(self): self.items = [] def empty(self): return self.items == [] def push_back(self, item): self.items.append(item) def push_front(self, item): self.items.insert(0,item) def pop_back(self): self.items.pop() def pop_front(self): self.items.pop(0) def back(self): return self.items[-1] def front(self): return self.items[0] def size(self): return len(self.items) def at(self, index): return self.items[index] def main(): d = Deque() print(\"Deque Empty? \", d.empty()) d.push_back(\"Zebra\") print(\"Deque Empty? \", d.empty()) d.push_front(\"Turtle\") #pushes to the front of the deque. d.push_front(\"Panda\") d.push_back(\"Catfish\") #pushes to the back of the deque. d.push_back(\"Giraffe\") print(\"Deque Size: \", d.size()) print(\"Item at the front: \", d.front()) print(\"Item at the back: \", d.back()) print(\"\\n\") print(\"Items in the Deque: \") for i in range(d.size()): #prints each item in the deque. print(d.at(i), end=\" \") print(\"\\n\") d.pop_back() d.pop_front() print(\"Item at the front: \", d.front()) print(\"Item at the back: \", d.back()) print(\"Deque Size: \", d.size()) print(\"\\n\") print(\"Items in the Deque: \") for i in range(d.size()): #prints each item in the deque. print(d.at(i), end=\" \") print(\"\\n\") main()   You can see many similarities to C++ code already used for stacks and queues. You are also likely to observe that in this implementation adding and removing items from the back is O(1) whereas adding and removing from the front is O(n). This is to be expected given the common operations that appear for adding and removing items. Again, the important thing is to be certain that we know where the front and rear are assigned in the implementation.     "
},
{
  "id": "expl-lst-dequecode-cpp",
  "level": "2",
  "url": "linear-basic_using-a-deque-in-c.html#expl-lst-dequecode-cpp",
  "type": "Exploration",
  "number": "3.17.1",
  "title": "Dequeue Implementation.",
  "body": " Dequeue Implementation  C++ Implementation \/\/Example code of a deque. #include <iostream> #include <deque> #include <string> using namespace std; int main() { deque<string> d; cout << \"Deque Empty? \" << d.empty() << endl; d.push_back(\"Zebra\"); cout << \"Deque Empty? \" << d.empty() << endl; d.push_front(\"Turtle\"); \/\/pushes to the front of the deque. d.push_front(\"Panda\"); d.push_back(\"Catfish\"); \/\/pushes to the back of the deque. d.push_back(\"Giraffe\"); cout << \"Deque Size: \" << d.size() << endl; cout << \"Item at the front: \" << d.front() << endl; cout << \"Item at the back: \" << d.back() << endl; cout << endl << \"Items in the Deque: \" << endl; int dsize = d.size(); for(int i = 0; i < dsize; i++){ \/\/prints each item in the deque. cout << d.at(i) << \" \"; } cout << endl; d.pop_back(); d.pop_front(); cout << endl << \"Item at the front: \" << d.front() << endl; cout << \"Itm at the back: \" << d.back() << endl; cout << \"Deque Size: \" << d.size() << endl; cout << endl << \"Items in the Deque: \" << endl; int dsize2 = d.size(); for(int i = 0; i < dsize2; i++){ \/\/prints each item in the deque. cout << d.at(i) << \" \"; return 0; } }  Python Implementation #Example code of a deque. class Deque: def __init__(self): self.items = [] def empty(self): return self.items == [] def push_back(self, item): self.items.append(item) def push_front(self, item): self.items.insert(0,item) def pop_back(self): self.items.pop() def pop_front(self): self.items.pop(0) def back(self): return self.items[-1] def front(self): return self.items[0] def size(self): return len(self.items) def at(self, index): return self.items[index] def main(): d = Deque() print(\"Deque Empty? \", d.empty()) d.push_back(\"Zebra\") print(\"Deque Empty? \", d.empty()) d.push_front(\"Turtle\") #pushes to the front of the deque. d.push_front(\"Panda\") d.push_back(\"Catfish\") #pushes to the back of the deque. d.push_back(\"Giraffe\") print(\"Deque Size: \", d.size()) print(\"Item at the front: \", d.front()) print(\"Item at the back: \", d.back()) print(\"\\n\") print(\"Items in the Deque: \") for i in range(d.size()): #prints each item in the deque. print(d.at(i), end=\" \") print(\"\\n\") d.pop_back() d.pop_front() print(\"Item at the front: \", d.front()) print(\"Item at the back: \", d.back()) print(\"Deque Size: \", d.size()) print(\"\\n\") print(\"Items in the Deque: \") for i in range(d.size()): #prints each item in the deque. print(d.at(i), end=\" \") print(\"\\n\") main()  "
},
{
  "id": "linear-basic_palindrome-checker",
  "level": "1",
  "url": "linear-basic_palindrome-checker.html",
  "type": "Section",
  "number": "3.18",
  "title": "Palindrome-Checker",
  "body": " Palindrome-Checker  palindrome An interesting problem that can be easily solved using the deque data structure is the classic palindrome problem. A palindrome is a string that reads the same forward and backward, for example, radar , toot , and madam . We would like to construct an algorithm to input a string of characters and check whether it is a palindrome.  The solution to this problem will use a deque to store the characters of the string. We will process the string from left to right and add each character to the rear of the deque. At this point, the deque will be acting very much like an ordinary queue. However, we can now make use of the dual functionality of the deque. The front of the deque will hold the first character of the string and the rear of the deque will hold the last character (see ).   A Deque    Since we can remove both of them directly, we can compare them and continue only if they match. If we can keep matching first and the last items, we will eventually either run out of characters or be left with a deque of size 1 depending on whether the length of the original string was even or odd. In either case, the string must be a palindrome. The complete function for palindrome-checking appears in .   Basic Palindrome Checker  C++ Implementation \/\/program that detects palindromes. #include <deque> #include <iostream> #include <string> using namespace std; bool palchecker(string aString) { deque<char> chardeque; int strLen = aString.length(); for (int i = 0; i < strLen; i++) { \/\/pushes each char in the string to the deque. chardeque.push_back(aString[i]); } bool stillEqual = true; while (chardeque.size() > 1 && stillEqual) { char first = chardeque.front(); chardeque.pop_front(); char last = chardeque.back(); chardeque.pop_back(); if (first != last) { \/\/if the two opposite positions of the \/\/word is not the same, then it is not \/\/a palindrome. stillEqual = false; } } return stillEqual; } int main() { cout << palchecker(\"lsdkjfskf\") << endl; cout << palchecker(\"radar\") << endl; }  Python Implementation #Program that detects palindromes. from pythonds.basic.deque import Deque def palchecker(aString): chardeque = Deque() for ch in aString: #pushes each char in the string to the deque. chardeque.addRear(ch) stillEqual = True while chardeque.size() > 1 and stillEqual: first = chardeque.removeFront() last = chardeque.removeRear() if first != last: #if the two opposite positions of the #word is not the same, then it is not #a palindrome. stillEqual = False return stillEqual def main(): print(palchecker(\"lsdkjfskf\")) print(palchecker(\"radar\")) main()   Below we can see an upgraded code for checking palindromes, which is able to handle strings with capital letters, spaces, and special characters.  .   Advanced Palindrome Checker  \/\/program that detects palindromes. \/* The Advanced Palindrome Checker By: David Reynoso and David Andrejsin *\/ using namespace std; #include <deque> #include <fstream> \/\/ for file handling #include <iostream> #include <string> #include \"stdlib.h\" \/\/ for the system command #include <algorithm> \/\/ provides an algorithm for easier removal of characters from a string string processor(string aString) { \/\/ goes through string and finds uppercase letters and converts \/\/ them to lower case, also finds special characters and gets rid of them \/\/ ultimately, prepares a string for a correct palindrome evaluation int strLen = aString.length(); string str = \"\"; for (int i = 0; i < strLen; i++) { str += tolower(aString[i]); } str.erase(remove(str.begin(), str.end(), ' '), str.end()); str.erase(remove(str.begin(), str.end(), '.'), str.end()); str.erase(remove(str.begin(), str.end(), '?'), str.end()); str.erase(remove(str.begin(), str.end(), '!'), str.end()); str.erase(remove(str.begin(), str.end(), ','), str.end()); str.erase(remove(str.begin(), str.end(), ';'), str.end()); str.erase(remove(str.begin(), str.end(), ':'), str.end()); str.erase(remove(str.begin(), str.end(), '#'), str.end()); str.erase(remove(str.begin(), str.end(), '\"'), str.end()); str.erase(remove(str.begin(), str.end(), '\\''), str.end()); \/\/ we had to use a backslash to espace the function of ' str.erase(remove(str.begin(), str.end(), '-'), str.end()); str.erase(remove(str.begin(), str.end(), '('), str.end()); str.erase(remove(str.begin(), str.end(), ')'), str.end()); return str; } bool palchecker(string aString) { \/\/ an algorithm that checks whether a string is a palindrome aString = processor(aString); \/\/ calls a function that prepares the string for a proper evaluation of the palindrome deque<char> chardeque; int strLen = aString.length(); for (int i = 0; i < strLen; i++) { \/\/pushes each char in the string to the deque. chardeque.push_back(aString[i]); } bool stillEqual = true; while (chardeque.size() > 1 && stillEqual) { char first = chardeque.front(); chardeque.pop_front(); char last = chardeque.back(); chardeque.pop_back(); if (first != last) { \/\/if the two opposite positions of the \/\/word is not the same, then it is not \/\/a palindrome. stillEqual = false; } } return stillEqual; } int main() { cout << palchecker(\"Radar\") << endl; cout << palchecker(\"Are we not pure? 'No sir!' Panama's moody Noriega brags. 'It is garbage!' Irony dooms a man; a prisoner up to new era.\") << endl; cout << palchecker(\"Barge in! Relate mere war of 1991 for a were-metal Ernie grab!\") << endl; cout << palchecker(\"not a palindrome\") << endl; }    Reading Questions  Drag each data structure to its corresponding ordering principle This is feedback. Stack last-in first-out Deque mixed depending upon input order Queue first-in first-out  Click on the cause of a syntax error in the following code. Remember how we declare variables  deque<int> d; :  d.push_back(\"Zebra\"); :  d.push_front(\"Turtle\"); :  d.push_front(\"Panda\"); :  d.push_back(\"Catfish\"); :  d.push_back(\"Giraffe\"); :    If you add five items to your code in this order potato , rutabaga , avocado , squash , eggplant which structure would take the least steps to retrieve rutabaga ?     Deque    Yes, but it is not the only option.      Stack    No, a stack would pop from the top, thus having more entries in the way before it gets to rutabega.      Queue    Yes, but it is not the only option.      Both B & C    One of these two would be correct, but the other would not.      Both A & C    Correct!         "
},
{
  "id": "linear-basic_palindrome-checker-2",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#linear-basic_palindrome-checker-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "palindrome "
},
{
  "id": "fig-palindrome",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#fig-palindrome",
  "type": "Figure",
  "number": "3.18.1",
  "title": "",
  "body": " A Deque   "
},
{
  "id": "expl-linear-basic_palinedrome",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#expl-linear-basic_palinedrome",
  "type": "Exploration",
  "number": "3.18.1",
  "title": "Basic Palindrome Checker.",
  "body": " Basic Palindrome Checker  C++ Implementation \/\/program that detects palindromes. #include <deque> #include <iostream> #include <string> using namespace std; bool palchecker(string aString) { deque<char> chardeque; int strLen = aString.length(); for (int i = 0; i < strLen; i++) { \/\/pushes each char in the string to the deque. chardeque.push_back(aString[i]); } bool stillEqual = true; while (chardeque.size() > 1 && stillEqual) { char first = chardeque.front(); chardeque.pop_front(); char last = chardeque.back(); chardeque.pop_back(); if (first != last) { \/\/if the two opposite positions of the \/\/word is not the same, then it is not \/\/a palindrome. stillEqual = false; } } return stillEqual; } int main() { cout << palchecker(\"lsdkjfskf\") << endl; cout << palchecker(\"radar\") << endl; }  Python Implementation #Program that detects palindromes. from pythonds.basic.deque import Deque def palchecker(aString): chardeque = Deque() for ch in aString: #pushes each char in the string to the deque. chardeque.addRear(ch) stillEqual = True while chardeque.size() > 1 and stillEqual: first = chardeque.removeFront() last = chardeque.removeRear() if first != last: #if the two opposite positions of the #word is not the same, then it is not #a palindrome. stillEqual = False return stillEqual def main(): print(palchecker(\"lsdkjfskf\")) print(palchecker(\"radar\")) main()  "
},
{
  "id": "advanced-linear-basic_palinedrome-cpp",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#advanced-linear-basic_palinedrome-cpp",
  "type": "Listing",
  "number": "3.18.2",
  "title": "Advanced Palindrome Checker",
  "body": " Advanced Palindrome Checker  \/\/program that detects palindromes. \/* The Advanced Palindrome Checker By: David Reynoso and David Andrejsin *\/ using namespace std; #include <deque> #include <fstream> \/\/ for file handling #include <iostream> #include <string> #include \"stdlib.h\" \/\/ for the system command #include <algorithm> \/\/ provides an algorithm for easier removal of characters from a string string processor(string aString) { \/\/ goes through string and finds uppercase letters and converts \/\/ them to lower case, also finds special characters and gets rid of them \/\/ ultimately, prepares a string for a correct palindrome evaluation int strLen = aString.length(); string str = \"\"; for (int i = 0; i < strLen; i++) { str += tolower(aString[i]); } str.erase(remove(str.begin(), str.end(), ' '), str.end()); str.erase(remove(str.begin(), str.end(), '.'), str.end()); str.erase(remove(str.begin(), str.end(), '?'), str.end()); str.erase(remove(str.begin(), str.end(), '!'), str.end()); str.erase(remove(str.begin(), str.end(), ','), str.end()); str.erase(remove(str.begin(), str.end(), ';'), str.end()); str.erase(remove(str.begin(), str.end(), ':'), str.end()); str.erase(remove(str.begin(), str.end(), '#'), str.end()); str.erase(remove(str.begin(), str.end(), '\"'), str.end()); str.erase(remove(str.begin(), str.end(), '\\''), str.end()); \/\/ we had to use a backslash to espace the function of ' str.erase(remove(str.begin(), str.end(), '-'), str.end()); str.erase(remove(str.begin(), str.end(), '('), str.end()); str.erase(remove(str.begin(), str.end(), ')'), str.end()); return str; } bool palchecker(string aString) { \/\/ an algorithm that checks whether a string is a palindrome aString = processor(aString); \/\/ calls a function that prepares the string for a proper evaluation of the palindrome deque<char> chardeque; int strLen = aString.length(); for (int i = 0; i < strLen; i++) { \/\/pushes each char in the string to the deque. chardeque.push_back(aString[i]); } bool stillEqual = true; while (chardeque.size() > 1 && stillEqual) { char first = chardeque.front(); chardeque.pop_front(); char last = chardeque.back(); chardeque.pop_back(); if (first != last) { \/\/if the two opposite positions of the \/\/word is not the same, then it is not \/\/a palindrome. stillEqual = false; } } return stillEqual; } int main() { cout << palchecker(\"Radar\") << endl; cout << palchecker(\"Are we not pure? 'No sir!' Panama's moody Noriega brags. 'It is garbage!' Irony dooms a man; a prisoner up to new era.\") << endl; cout << palchecker(\"Barge in! Relate mere war of 1991 for a were-metal Ernie grab!\") << endl; cout << palchecker(\"not a palindrome\") << endl; }  "
},
{
  "id": "orderingPrinciples",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#orderingPrinciples",
  "type": "Reading Question",
  "number": "3.18.1",
  "title": "",
  "body": "Drag each data structure to its corresponding ordering principle This is feedback. Stack last-in first-out Deque mixed depending upon input order Queue first-in first-out "
},
{
  "id": "Remembertypes",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#Remembertypes",
  "type": "Reading Question",
  "number": "3.18.2",
  "title": "",
  "body": "Click on the cause of a syntax error in the following code. Remember how we declare variables  deque<int> d; :  d.push_back(\"Zebra\"); :  d.push_front(\"Turtle\"); :  d.push_front(\"Panda\"); :  d.push_back(\"Catfish\"); :  d.push_back(\"Giraffe\"); :  "
},
{
  "id": "structureefficiency",
  "level": "2",
  "url": "linear-basic_palindrome-checker.html#structureefficiency",
  "type": "Reading Question",
  "number": "3.18.3",
  "title": "",
  "body": " If you add five items to your code in this order potato , rutabaga , avocado , squash , eggplant which structure would take the least steps to retrieve rutabaga ?     Deque    Yes, but it is not the only option.      Stack    No, a stack would pop from the top, thus having more entries in the way before it gets to rutabega.      Queue    Yes, but it is not the only option.      Both B & C    One of these two would be correct, but the other would not.      Both A & C    Correct!    "
},
{
  "id": "linear-basic_summary",
  "level": "1",
  "url": "linear-basic_summary.html",
  "type": "Section",
  "number": "3.19",
  "title": "Summary",
  "body": " Summary    Linear data structures maintain their data in an ordered fashion.    Stacks are simple data structures that maintain a LIFO, last-in first-out, ordering.    The fundamental operations for a stack are push , pop , and empty .    Queues are simple data structures that maintain a FIFO, first-in first-out, ordering.    The fundamental operations for a queue are push , pop , and empty .    Prefix, infix, and postfix are all ways to write expressions.    Stacks are very useful for designing algorithms to evaluate and translate expressions.    Stacks can provide a reversal characteristic.    Queues can assist in the construction of timing simulations.    Simulations use random number generators to create a real-life situation and allow us to answer what if types of questions.    Deques are data structures that allow hybrid behavior like that of stacks and queues.    The fundamental operations for a deque are push_front , push_back , pop_front , pop_back , and empty .       "
},
{
  "id": "linear-basic_discussion-questions",
  "level": "1",
  "url": "linear-basic_discussion-questions.html",
  "type": "Section",
  "number": "3.20",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Convert the following values to binary using divide by 2. Show the stack of remainders.    17    45    96      Convert the following infix expressions to prefix (use full parentheses):    (A+B)*(C+D)*(E+F)    A+((B+C)*(D+E))    A*B*C*D+E+F      Convert the above infix expressions to postfix (use full parentheses).    Convert the above infix expressions to postfix using the direct conversion algorithm. Show the stack as the conversion takes place.    Evaluate the following postfix expressions. Show the stack as each operand and operator is processed.    2 3 * 4 +    1 2 + 3 + 4 + 5 +    1 2 3 4 5 * + * +      The alternative implementation of the Queue ADT is to use a vector such that the rear of the queue is at the end of the vector. What would this mean for Big-O performance?       "
},
{
  "id": "linear-basic_programming-exercises",
  "level": "1",
  "url": "linear-basic_programming-exercises.html",
  "type": "Section",
  "number": "3.21",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Modify the infix-to-postfix algorithm so that it can handle errors.    Modify the postfix evaluation algorithm so that it can handle errors.    Implement a direct infix evaluator that combines the functionality of infix-to-postfix conversion and the postfix evaluation algorithm. Your evaluator should process infix tokens from left to right and use two stacks, one for operators and one for operands, to perform the evaluation.    Turn your direct infix evaluator from the previous problem into a calculator.    Implement the Queue ADT, using a vector such that the rear of the queue is at the end of the vector.    Design and implement an experiment to do benchmark comparisons of the two queue implementations. What can you learn from such an experiment?    It is possible to implement a queue such that both enqueue and dequeue have performance on average . In this case it means that most of the time enqueue and dequeue will be except in one particular circumstance where dequeue will be .    Consider a real life situation. Formulate a question and then design a simulation that can help to answer it. Possible situations include:    Cars lined up at a car wash    Customers at a grocery store check-out    Airplanes taking off and landing on a runway    A bank teller    Be sure to state any assumptions that you make and provide any probabilistic data that must be considered as part of the scenario.    Modify the Hot Potato simulation to allow for a randomly chosen counting value so that each pass is not predictable from the previous one.    Implement a radix sorting machine. A radix sort for base 10 integers is a mechanical sorting technique that utilizes a collection of bins, one main bin and 10 digit bins. Each bin acts like a queue and maintains its values in the order that they arrive. The algorithm begins by placing each number in the main bin. Then it considers each value digit by digit. The first value is removed and placed in a digit bin corresponding to the digit being considered. For example, if the ones digit is being considered, 534 is placed in digit bin 4 and 667 is placed in digit bin 7. Once all the values are placed in the corresponding digit bins, the values are collected from bin 0 to bin 9 and placed back in the main bin. The process continues with the tens digit, the hundreds, and so on. After the last digit is processed, the main bin contains the values in order.    Another example of the parentheses matching problem comes from hypertext markup language (HTML). In HTML, tags exist in both opening and closing forms and must be balanced to properly describe a web document. This very simple HTML document:  <html> <head> <title> Example <\/title> <\/head> <body> <h1>Hello, world<\/h1> <\/body> <\/html>  is intended only to show the matching and nesting structure for tags in the language. Write a program that can check an HTML document for proper opening and closing tags.    Extend the program from Listing 2.15 to handle palindromes with spaces. For example, I PREFER PI is a palindrome that reads the same forward and backward if you ignore the blank characters.       "
},
{
  "id": "linear-basic_glossary",
  "level": "1",
  "url": "linear-basic_glossary.html",
  "type": "Section",
  "number": "3.22",
  "title": "Glossary",
  "body": " Glossary    algorithm  a generic, step-by-step list of instructions for solving a problem.    balanced parentheses  each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested.    deque  an ordered collection of items with two ends and the items remain positioned in the collection. New items can be added at either the front or the rear.    first-in first-out (FIFO)  ordering principle in which the first item added is also the first removed.    fully parenthesized  the usage of one pair of parentheses for each operator.    infix  expression notation in which the operator is in between the two operands that it is working on.    last-in first-out (LIFO)  ordering principle in which the last item added is also the first removed.    linear data structure  a data structure with elements that have positions relative to each other.    palindrome  a string that reads the same forward and backward.    postfix  expression notation in which all operators come after the two operands that they work on.    precedence  hierarchy on the order things occur.    prefix  expression notation in which all operators precede the two operands that they work on.    queue  an ordered collection of items where the addition of new items happens at one end and the removal of existing items occurs at the other end.    simulation  an imitation of a process or operations.    stack  an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end.       "
},
{
  "id": "linearbasic_linear-basic_matching",
  "level": "1",
  "url": "linearbasic_linear-basic_matching.html",
  "type": "Section",
  "number": "3.23",
  "title": "Matching",
  "body": " Matching   Match the term with their corresponding definition   Incorrect    algorithm  Generic step-by-step list of instructions for solving a problem    balanced parentheses  Each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested    deque  Ordered collection of items with two ends and the items remain positioned in the collection. New items can be added at either the front or the rear    first-in first-out (FIFO)  First item added is also the first removed    linear data structure  Data structure with elements that have positions relative to each other    palindrome  String that reads the same forward and backward    simulation  Replica of a process or operations    precedence  Hierarchy on the order things occur     Match the term with their corresponding definition   Incorrect    postfix  Expression notation in which all operators come after the two operands that they work on    prefix  Expression notation in which all operators precede the two operands that they work on    queue  Ordered collection of items where the addition of new items happens at one end and the removal of existing items occurs at the other end    last-in first-out (LIFO)  Last item added is also the first removed    stack  Ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end    fully parenthesized  Usage of one pair of parentheses for each operator    infix  Expression notation in which the operator is in between the two operands that it is working on       "
},
{
  "id": "Match_chap3",
  "level": "2",
  "url": "linearbasic_linear-basic_matching.html#Match_chap3",
  "type": "Checkpoint",
  "number": "3.23.1",
  "title": "",
  "body": " Match the term with their corresponding definition   Incorrect    algorithm  Generic step-by-step list of instructions for solving a problem    balanced parentheses  Each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested    deque  Ordered collection of items with two ends and the items remain positioned in the collection. New items can be added at either the front or the rear    first-in first-out (FIFO)  First item added is also the first removed    linear data structure  Data structure with elements that have positions relative to each other    palindrome  String that reads the same forward and backward    simulation  Replica of a process or operations    precedence  Hierarchy on the order things occur   "
},
{
  "id": "Match_chap3_2",
  "level": "2",
  "url": "linearbasic_linear-basic_matching.html#Match_chap3_2",
  "type": "Checkpoint",
  "number": "3.23.2",
  "title": "",
  "body": " Match the term with their corresponding definition   Incorrect    postfix  Expression notation in which all operators come after the two operands that they work on    prefix  Expression notation in which all operators precede the two operands that they work on    queue  Ordered collection of items where the addition of new items happens at one end and the removal of existing items occurs at the other end    last-in first-out (LIFO)  Last item added is also the first removed    stack  Ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end    fully parenthesized  Usage of one pair of parentheses for each operator    infix  Expression notation in which the operator is in between the two operands that it is working on   "
},
{
  "id": "linear-linked_objectives",
  "level": "1",
  "url": "linear-linked_objectives.html",
  "type": "Section",
  "number": "4.1",
  "title": "Objectives",
  "body": " Objectives    To appreciate that list-like data types such as arrays and vectors which rely on storing data in contiguous memory are just one type of list-like structure.    To learn that linked lists are a different list-like data structure.    To write code which manipulates linked lists in C++.    Understand node and pointer diagrams to illustrate the linked list.    To learn how singly and doubly linked lists are implemented in C++.    To understand the abstract data types node and linked list, including the unordered list and ordered list.       "
},
{
  "id": "linear-linked_what-are-linked-structures",
  "level": "1",
  "url": "linear-linked_what-are-linked-structures.html",
  "type": "Section",
  "number": "4.2",
  "title": "What Are Linked Structures?",
  "body": " What Are Linked Structures?   linked data structure A linked data structure is a data structure which consists of a set of data structures called nodes which are linked together and organized by links created via references or pointers.  Linked data structures include linear linked structures like linked lists as well as a variety of different types of tree data structures. In this chapter we will consider linear linked structures, both ordered and unordered.  When thinking about a linked data structure, one example is timesharing on an operating system. Timesharing is a computer's way of multitasking. Much like when human's multitask, computers do not actually handle all of its tasks at the same exact time. If you tried to listen to 3 people talk, read a book, and sing a song then you would fail like most people. What you may notice when attempting such a feat is that you pick up on bits and pieces of each separate task. This is due to your attention switching really fast between tasks.  Observe what happens when you play the following videos simultaneously:      You can hear and see all of these videos simultaneously, but only because your computer switches from one task to another so fast that it appears seamless. Just like you, your computer gives each task some time to use its resources and cycles between them really fast. Timesharing explains why a computer slows down when there are a bunch of tabs open on a browser: the more things you have to switch between, the more time it takes to finish them.  This is accomplished by the operating system's use of a circular linked list.     "
},
{
  "id": "linear-linked_what-are-linked-structures-2",
  "level": "2",
  "url": "linear-linked_what-are-linked-structures.html#linear-linked_what-are-linked-structures-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "linked data structure "
},
{
  "id": "linear-linked_implementing-an-unordered-linked-list",
  "level": "1",
  "url": "linear-linked_implementing-an-unordered-linked-list.html",
  "type": "Section",
  "number": "4.3",
  "title": "Implementing an Unordered Linked List",
  "body": " Implementing an Unordered Linked List  linked list A linked list is a linear collection of data elements whose order is not determined by the placement in memory. Instead, each element is stored in a node which points to the next node. In the next sections we implement this linked list data structure. In doing so, we need to be sure that we can maintain the relative positioning of the items. However, there is no requirement that we maintain that positioning in contiguous memory. For example, consider the collection of items shown in . It appears that these values have been placed randomly. If we can maintain some explicit information in each item, namely the location of the next item (see ), then the relative position of each item can be expressed by simply following the link from one item to the next.   Items Not Constrained in Their Physical Placement.   Image displaying a scattered set of numbers representing items not constrained in their physical placement. The numbers shown are '31' and '17' at the top, '26' to the right, '54' and '77' in the middle, and '93' at the bottom. They are arranged without a discernible pattern or alignment, suggesting a random or unstructured layout.     Relative Positions Maintained by Explicit Links.   Diagram showing a sequence of numbers connected by arrows, illustrating relative positions maintained by explicit links. The sequence starts with 'Head' pointing to '54', which links to '77', then to '31' labeled '(End)', '17', '26', and finally '93'. The arrows signify the direction of the linkage between the elements, depicting a linked structure. Captioned 'Figure 4.3.2. Relative Positions Maintained by Explicit Links'.    It is important to note that the location of the first item of the list must be explicitly specified. Once we know where the first item is, the first item can tell us where the second is, and so on. head The external reference is often referred to as the head of the list. Similarly, the last item needs to know that there is no next item.     "
},
{
  "id": "linear-linked_implementing-an-unordered-linked-list-2",
  "level": "2",
  "url": "linear-linked_implementing-an-unordered-linked-list.html#linear-linked_implementing-an-unordered-linked-list-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "linked list "
},
{
  "id": "fig-idea",
  "level": "2",
  "url": "linear-linked_implementing-an-unordered-linked-list.html#fig-idea",
  "type": "Figure",
  "number": "4.3.1",
  "title": "",
  "body": " Items Not Constrained in Their Physical Placement.   Image displaying a scattered set of numbers representing items not constrained in their physical placement. The numbers shown are '31' and '17' at the top, '26' to the right, '54' and '77' in the middle, and '93' at the bottom. They are arranged without a discernible pattern or alignment, suggesting a random or unstructured layout.   "
},
{
  "id": "fig-idea2",
  "level": "2",
  "url": "linear-linked_implementing-an-unordered-linked-list.html#fig-idea2",
  "type": "Figure",
  "number": "4.3.2",
  "title": "",
  "body": " Relative Positions Maintained by Explicit Links.   Diagram showing a sequence of numbers connected by arrows, illustrating relative positions maintained by explicit links. The sequence starts with 'Head' pointing to '54', which links to '77', then to '31' labeled '(End)', '17', '26', and finally '93'. The arrows signify the direction of the linkage between the elements, depicting a linked structure. Captioned 'Figure 4.3.2. Relative Positions Maintained by Explicit Links'.   "
},
{
  "id": "linear-linked_implementing-an-unordered-linked-list-5",
  "level": "2",
  "url": "linear-linked_implementing-an-unordered-linked-list.html#linear-linked_implementing-an-unordered-linked-list-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "head "
},
{
  "id": "linear-linked_the-node-class",
  "level": "1",
  "url": "linear-linked_the-node-class.html",
  "type": "Section",
  "number": "4.4",
  "title": "The <code class=\"code-inline tex2jax_ignore\">Node<\/code> Class",
  "body": " The Node Class  The basic building block for the linked list implementation is the node . Each node object must hold at least two pieces of information. First, the node must contain the list item itself. We will call this the data field of the node. In addition, each node must hold a reference to the next node. shows the C++ implementation. To construct a node, you need to supply the initial data value for the node. Evaluating the assignment statement below will yield a node object containing the value 93 (see ). You should note that we will typically represent a node object as shown in . The Node class also includes the usual methods to access and modify the data and the next reference.   Node Class  #include <iostream> using namespace std; class Node { private: int data; \/\/data in the beginning node Node *next; \/\/pointer to the next node public: Node(int initdata) { data = initdata; \/\/the initialized data is set as the head next = NULL; \/\/the next node is set as NULL, as there is no next node yet. } int getData() { \/\/function that return data of a given node. return data; } Node *getNext() { return next; } void setData(int newData) { data = newData; } void setNext(Node *newnext) { next = newnext; } };  >>> temp = Node(93) \/\/sets the nodes data to the integer 93 >>> temp.getData() \/\/ calls the getData() function. 93  The special C++ reference value NULL will play an important role in the Node class and later in the linked list itself. A reference to NULL will denote the fact that there is no next node.  Note:   in the constructor that a node is initially created with next and a pointer to NULL . Since this is sometimes referred to as “grounding the node,” we will use the standard ground symbol to denote a reference that is referring to NULL .    A Node Object Contains the Item and a Reference to the Next Node     A Typical Representation for a Node       "
},
{
  "id": "linear-linked_the-node-class-2",
  "level": "2",
  "url": "linear-linked_the-node-class.html#linear-linked_the-node-class-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "node data field "
},
{
  "id": "linear-linked_lst-nodeclass",
  "level": "2",
  "url": "linear-linked_the-node-class.html#linear-linked_lst-nodeclass",
  "type": "Listing",
  "number": "4.4.1",
  "title": "<code class=\"code-inline tex2jax_ignore\">Node<\/code> Class",
  "body": " Node Class  #include <iostream> using namespace std; class Node { private: int data; \/\/data in the beginning node Node *next; \/\/pointer to the next node public: Node(int initdata) { data = initdata; \/\/the initialized data is set as the head next = NULL; \/\/the next node is set as NULL, as there is no next node yet. } int getData() { \/\/function that return data of a given node. return data; } Node *getNext() { return next; } void setData(int newData) { data = newData; } void setNext(Node *newnext) { next = newnext; } }; "
},
{
  "id": "id1-fig-node",
  "level": "2",
  "url": "linear-linked_the-node-class.html#id1-fig-node",
  "type": "Figure",
  "number": "4.4.2",
  "title": "",
  "body": " A Node Object Contains the Item and a Reference to the Next Node   "
},
{
  "id": "id2-fig-node2",
  "level": "2",
  "url": "linear-linked_the-node-class.html#id2-fig-node2",
  "type": "Figure",
  "number": "4.4.3",
  "title": "",
  "body": " A Typical Representation for a Node   "
},
{
  "id": "linear-linked_implementing-an-ordered-linked-list",
  "level": "1",
  "url": "linear-linked_implementing-an-ordered-linked-list.html",
  "type": "Section",
  "number": "4.5",
  "title": "Implementing an Ordered Linked List",
  "body": " Implementing an Ordered Linked List    ordered linked list   An ordered linked list is a linear data structure consisting of a collection of nodes, each containing two main components: a data element, often referred to as the \"value\" or \"key\", and a \"reference\" or \"link\" to the next node in the sequence. These nodes are organized in a specific order based on the values of their data elements, typically in ascending or descending order.    In order to implement the ordered linked list , we must remember that the relative positions of the items are based on some underlying characteristic. The ordered linked list of integers given above (17, 26, 31, 54, 77, and 93) can be represented by a linked structure as shown in . Again, the node and link structure is ideal for representing the relative positioning of the items.   An Ordered Linked List.   Image of an ordered linked list with rectangular nodes connected by arrows. The list begins with a node labeled 'head' pointing to '17', followed by sequential nodes labeled '26', '31', '54', '77', and '93', with arrows indicating the direction of linkage from left to right. The structure represents a series of linked elements in ascending order.    To implement the OrderedList class, we will use the same technique as seen previously with unordered linked lists. Once again, an empty linked list will be denoted by a head reference to NULL (see ).   OrderedList Member Variable  class OrderedList { Node* head; }   As we consider the operations for the ordered linked list, we should note that the isEmpty and size methods can be implemented the same as with unordered linked lists since they deal only with the number of nodes in the linked list without regard to the actual item values. Likewise, the remove method will work just fine since we still need to find the item and then link around the node to remove it. The two remaining methods, search and add , will require some modification.  The search of an unordered linked list required that we traverse the nodes one at a time until we either find the item we are looking for or run out of nodes ( NULL ). It turns out that the same approach would actually work with the ordered linked list and in fact in the case where we find the item it is exactly what we need. However, in the case where the item is not in the linked list, we can take advantage of the ordering to stop the search as soon as possible.  For example, shows the ordered linked list as a search is looking for the value 45. As we traverse, starting at the head of the linked list, we first compare against 17. Since 17 is not the item we are looking for, we move to the next node, in this case 26. Again, this is not what we want, so we move on to 31 and then on to 54. Now, at this point, something is different. Since 54 is not the item we are looking for, our former strategy would be to move forward. However, due to the fact that this is an ordered linked list, that will not be necessary. Once the value in the node becomes greater than the item we are searching for, the search can stop and return False . There is no way the item could exist further out in the linked list.   Searching an Ordered Linked List.   Diagram showing the process of searching an ordered linked list. The list includes rectangular nodes with numbers '17', '26', '31', '54', '77', and '93' connected by arrows from a 'head' node. Above each node except 'head' and '93', a dashed arrow points down, labeled 'current', indicating the position being checked. Over the '54' node, there is a magnifying glass symbol, suggesting it is the current focus of the search. The list is terminated by a vertical bar symbol.    shows the complete search method. It is easy to incorporate the new condition discussed above by adding another boolean variable, stop , and initializing it to False (line 4). While stop is False (in other words, while the search is still ongoing) we can continue to look forward in the linked list (line 5). If any node is ever discovered that contains data greater than the item we are looking for, we will set stop to True (lines 9–10). The remaining lines are identical to the unordered linked list search.   search Method  bool search(int item) { Node *current = head; bool found = false; bool stop = false; while (current != NULL && !found && !stop) { if (current->getData() == item) { found = true; } else { if (current->getData() > item) { stop = true; } else { current = current->getNext(); } } } return found; }   The most significant method modification will take place in add . Recall that for unordered linked lists, the add method could simply place a new node at the head of the linked list. It was the easiest point of access. Unfortunately, this will no longer work with ordered linked lists. It is now necessary that we discover the specific place where a new item belongs in the existing ordered linked list.  Assume we have the ordered linked list consisting of 17, 26, 54, 77, and 93 and we want to add the value 31. The add method must decide that the new item belongs between 26 and 54. shows the setup that we need. As we explained earlier, we need to traverse the linked list looking for the place where the new node will be added. We know we have found that place when either we run out of nodes ( current becomes NULL ) or the value of the current node becomes greater than the item we wish to add. In our example, seeing the value 54 causes us to stop.   Adding an Item to an Ordered Linked List.   Diagram of an ordered linked list illustrating the addition of a new item. The list starts with 'head' pointing to '17', then '26', followed by '54', '77', and '93', ending with a vertical bar symbol. A separate node labeled '31' with an arrow pointing right is positioned below, with a label 'temp'. Dashed arrows labeled 'Step 1' and 'Step 2' show the process of inserting '31' between '26' and '54'. Arrows from above point to '26' and '54' labeled 'previous' and 'current' respectively, indicating their positions relative to the insertion.    As we saw with unordered linked lists, it is necessary to have an additional reference, again called previous , since current will not provide access to the node that must be modified. shows the complete add method. Lines 2–3 set up the two external references and lines 9–10 again allow previous to follow one node behind current every time through the iteration. The condition (line 5) allows the iteration to continue as long as there are more nodes and the value in the current node is not larger than the item. In either case, when the iteration fails, we have found the location for the new node.  The remainder of the method completes the two-step process shown in . Once a new node has been created for the item, the only remaining question is whether the new node will be added at the beginning of the linked list or some place in the middle. Again, previous == NULL (line 13) can be used to provide the answer.   add Method  void add(int item) { if (head == NULL) { Node *newNode = new Node(item); head = newNode; } else { Node *current = head; Node *previous = NULL; bool stop = false; while (current != NULL && !stop) { if (current->getData() > item) { stop = true; } else { previous = current; current = current->getNext(); } } Node *temp = new Node(item); if (previous == NULL) { temp->setNext(head); head = temp; } else { temp->setNext(current); previous->setNext(temp); } } }   The OrderedList class with methods discussed thus far can be found in ActiveCode 1. We leave the remaining methods as exercises. You should carefully consider whether the unordered implementations will work given that the linked list is now ordered.   \/\/ similar to unordered lists except it orders the data #include <iostream> using namespace std; class Node { private: int data; Node *next; public: Node(int initdata) { data = initdata; \/\/the nodes data. next = NULL; \/\/next will become a pointer to another Node object. } int getData() { \/\/returns the data of the Node. return data; } Node *getNext() { \/\/returns the next Node in the linked list. return next; } void setData(int newData) { \/\/Changes the data of the Node. data = newData; } void setNext(Node *newnext) { \/\/assigns the next item in the linked list. next = newnext; } }; class OrderedList { public: Node *head; \/\/The first Node of the linked list. OrderedList() { head = NULL; } bool search(int item) { \/\/finds a Node that contains item in the linked list. Node *current = head; bool found = false; bool stop = false; while (current != NULL && !found && !stop) { \/\/iterates through the entire list until item is found. if (current->getData() == item) { found = true; } else { if (current->getData() > item) { stop = true; } else { current = current->getNext(); } } } return found; } void add(int item) { if (head == NULL) { Node *newNode = new Node(item); head = newNode; } else { Node *current = head; Node *previous = NULL; bool stop = false; while (current != NULL && !stop) { if (current->getData() > item) { \/\/if the data of the current Node is greater than item: stop = true; } else { previous = current; current = current->getNext(); } } Node *temp = new Node(item); if (previous == NULL) { \/\/sets the current head as temp's next item, \/\/sets temp as the new head. temp->setNext(head); head = temp; } else { \/\/sets the current Node as temp's next Node, \/\/sets temp to previous's next Node. temp->setNext(current); previous->setNext(temp); } } } bool isEmpty() { \/\/Returns true if the head is NULL. return head == NULL; } int size() { \/\/returns the length of the linked list. Node *current = head; int count = 0; while (current != NULL) { count++; current = current->getNext(); } return count; } friend ostream& operator<<(ostream& os, const OrderedList& ol); }; ostream& operator<<(ostream& os, const OrderedList& ol) { \/\/operator for printing the data of every Node in the list. Node *current = ol.head; while (current != NULL) { os<<current->getData()<<endl; current = current->getNext(); } return os; } int main() { OrderedList mylist; mylist.add(31); mylist.add(77); mylist.add(17); mylist.add(93); mylist.add(26); mylist.add(54); cout<<\"SIZE: \"<<mylist.size()<<endl; cout<<\"contains 93?\\t\"<<mylist.search(93)<<endl; cout<<\"contains 100?\\t\"<<mylist.search(100)<<endl<<endl; cout<<\"MY LIST: \"<<endl<<mylist; return 0; }     Analysis of Linked Lists  To analyze the complexity of the linked list operations, we need to consider whether they require traversal. Consider a linked list that has n nodes. The isEmpty method is since it requires one step to check the head reference for NULL . size , on the other hand, will always require n steps since there is no way to know how many nodes are in the linked list without traversing from head to end. Therefore, size is . Adding an item to an unordered linked list will always be O(1) since we simply place the new node at the head of the linked list. However, search and remove , as well as add for an ordered linked list, all require the traversal process. Although on average they may need to traverse only half of the nodes, these methods are all since in the worst case each will process every node in the linked list.  Match the Big O() analysis to their corresponding opperation. Try again! O(1) isEmpty, add (unordered linked list) O(n) length,add, search, and remove(ordered linked list)   Q-3: After having read over unordered and ordered linked lists, what do you think a circular linked list would do differently from an ordered or unordered linked list? (Hint: think about the example from the beginning of the chapter.)     In a circular linked list, the head Node of the linked list contains a pointer to the last node in the list.    Wrong! the head Node of the list will only contain a pointer to the second Node.      In a circular linked list, the last Node of the linked list contains a pointer to the head node of the list rather than pointing to NULL.    Correct! the final Node of the linked list will contain a pointer to the first node so that it is possible to make \"circles\" around the list.      In a circular linked list, every node contains a pointer to the head of the list, making it possible to return back to the beginning of the list at any time.    Wrong! None of the nodes in the middle of the list will ever point to the head node in a circular linked list.      In a circular linked list, the head and final Node of the linked list point to each other, making it possible to traverse through the list in both directions.    Hint: This would be possible in a circular doubly linked list, but not a circular linked list.         "
},
{
  "id": "def-ordered-linked-list",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#def-ordered-linked-list",
  "type": "Definition",
  "number": "4.5.1",
  "title": "",
  "body": " ordered linked list   An ordered linked list is a linear data structure consisting of a collection of nodes, each containing two main components: a data element, often referred to as the \"value\" or \"key\", and a \"reference\" or \"link\" to the next node in the sequence. These nodes are organized in a specific order based on the values of their data elements, typically in ascending or descending order.   "
},
{
  "id": "linear-linked_implementing-an-ordered-linked-list-2-2",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#linear-linked_implementing-an-ordered-linked-list-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "ordered linked list "
},
{
  "id": "fig-orderlinked",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#fig-orderlinked",
  "type": "Figure",
  "number": "4.5.2",
  "title": "",
  "body": " An Ordered Linked List.   Image of an ordered linked list with rectangular nodes connected by arrows. The list begins with a node labeled 'head' pointing to '17', followed by sequential nodes labeled '26', '31', '54', '77', and '93', with arrows indicating the direction of linkage from left to right. The structure represents a series of linked elements in ascending order.   "
},
{
  "id": "linear-linked_lst-orderlist",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#linear-linked_lst-orderlist",
  "type": "Listing",
  "number": "4.5.3",
  "title": "<code class=\"code-inline tex2jax_ignore\">OrderedList<\/code> Member Variable",
  "body": " OrderedList Member Variable  class OrderedList { Node* head; }  "
},
{
  "id": "fig-stopearly",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#fig-stopearly",
  "type": "Figure",
  "number": "4.5.4",
  "title": "",
  "body": " Searching an Ordered Linked List.   Diagram showing the process of searching an ordered linked list. The list includes rectangular nodes with numbers '17', '26', '31', '54', '77', and '93' connected by arrows from a 'head' node. Above each node except 'head' and '93', a dashed arrow points down, labeled 'current', indicating the position being checked. Over the '54' node, there is a magnifying glass symbol, suggesting it is the current focus of the search. The list is terminated by a vertical bar symbol.   "
},
{
  "id": "linear-linked_lst-ordersearch",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#linear-linked_lst-ordersearch",
  "type": "Listing",
  "number": "4.5.5",
  "title": "<code class=\"code-inline tex2jax_ignore\">search<\/code> Method",
  "body": " search Method  bool search(int item) { Node *current = head; bool found = false; bool stop = false; while (current != NULL && !found && !stop) { if (current->getData() == item) { found = true; } else { if (current->getData() > item) { stop = true; } else { current = current->getNext(); } } } return found; }  "
},
{
  "id": "fig-orderinsert",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#fig-orderinsert",
  "type": "Figure",
  "number": "4.5.6",
  "title": "",
  "body": " Adding an Item to an Ordered Linked List.   Diagram of an ordered linked list illustrating the addition of a new item. The list starts with 'head' pointing to '17', then '26', followed by '54', '77', and '93', ending with a vertical bar symbol. A separate node labeled '31' with an arrow pointing right is positioned below, with a label 'temp'. Dashed arrows labeled 'Step 1' and 'Step 2' show the process of inserting '31' between '26' and '54'. Arrows from above point to '26' and '54' labeled 'previous' and 'current' respectively, indicating their positions relative to the insertion.   "
},
{
  "id": "linear-linked_lst-orderadd",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#linear-linked_lst-orderadd",
  "type": "Listing",
  "number": "4.5.7",
  "title": "<code class=\"code-inline tex2jax_ignore\">add<\/code> Method",
  "body": " add Method  void add(int item) { if (head == NULL) { Node *newNode = new Node(item); head = newNode; } else { Node *current = head; Node *previous = NULL; bool stop = false; while (current != NULL && !stop) { if (current->getData() > item) { stop = true; } else { previous = current; current = current->getNext(); } } Node *temp = new Node(item); if (previous == NULL) { temp->setNext(head); head = temp; } else { temp->setNext(current); previous->setNext(temp); } } }  "
},
{
  "id": "LinkedlistAnalysis",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#LinkedlistAnalysis",
  "type": "Checkpoint",
  "number": "4.5.8",
  "title": "",
  "body": "Match the Big O() analysis to their corresponding opperation. Try again! O(1) isEmpty, add (unordered linked list) O(n) length,add, search, and remove(ordered linked list) "
},
{
  "id": "LinkedListMChoice",
  "level": "2",
  "url": "linear-linked_implementing-an-ordered-linked-list.html#LinkedListMChoice",
  "type": "Checkpoint",
  "number": "4.5.9",
  "title": "",
  "body": " Q-3: After having read over unordered and ordered linked lists, what do you think a circular linked list would do differently from an ordered or unordered linked list? (Hint: think about the example from the beginning of the chapter.)     In a circular linked list, the head Node of the linked list contains a pointer to the last node in the list.    Wrong! the head Node of the list will only contain a pointer to the second Node.      In a circular linked list, the last Node of the linked list contains a pointer to the head node of the list rather than pointing to NULL.    Correct! the final Node of the linked list will contain a pointer to the first node so that it is possible to make \"circles\" around the list.      In a circular linked list, every node contains a pointer to the head of the list, making it possible to return back to the beginning of the list at any time.    Wrong! None of the nodes in the middle of the list will ever point to the head node in a circular linked list.      In a circular linked list, the head and final Node of the linked list point to each other, making it possible to traverse through the list in both directions.    Hint: This would be possible in a circular doubly linked list, but not a circular linked list.    "
},
{
  "id": "linear-linked_the-ordered-list-abstract-data-type",
  "level": "1",
  "url": "linear-linked_the-ordered-list-abstract-data-type.html",
  "type": "Section",
  "number": "4.6",
  "title": "The Ordered List Abstract Data Type",
  "body": " The Ordered List Abstract Data Type   ordered list We will now consider a type of list known as an ordered list . For example, if the list of integers shown above were an ordered list (ascending order), then it could be written as 17, 26, 31, 54, 77, and 93. Since 17 is the smallest item, it occupies the first position in the list. Likewise, since 93 is the largest, it occupies the last position.  The structure of an ordered list is a collection of items where each item holds a relative position that is based upon some underlying characteristic of the item. The ordering is typically either ascending or descending and we assume that list items have a meaningful comparison operation that is already defined. Many of the ordered list operations are the same as those of the unordered list.    OrderedList() creates a new ordered list that is empty. It needs no parameters and returns an empty list.    add(item) adds a new item to the list making sure that the order is preserved. It needs the item and returns nothing. Assume the item is not already in the list.    remove(item) removes the item from the list. It needs the item and modifies the list. Assume the item is present in the list.    search(item) searches for the item in the list. It needs the item and returns a boolean value.    isEmpty() tests to see whether the list is empty. It needs no parameters and returns a boolean value.    size() returns the number of items in the list. It needs no parameters and returns an integer.    index(item) returns the position of item in the list. It needs the item and returns the index. Assume the item is in the list.    pop() removes and returns the last item in the list. It needs nothing and returns an item. Assume the list has at least one item.    pop(pos) removes and returns the item at position pos. It needs the position and returns the item. Assume the item is in the list.      Forward lists  forward list Forward lists are sequence containers in the STL that allow you to do constant time insert and delete operations.  These containers are implemented as ordered singly-linked lists. Singly linked lists are able to store each list element in different storage locations as opposed to regular arrays which each element has to be stored next to each other. Each element holds a link to the next element in the sequence as well as the value.  Because of the unique property of forward lists that allows them to insert and delete elements at any position in the list in constant time, they perform better than other sequence containers like arrays and vectors when it comes to algorithms that use a lot of insertion, like sorting algorithms.  Unlike sequence containers like arrays and vectors where each element in the list is right next to each other, forward lists use links that connect one element to another. For this reason you cannot directly access an element in a forward list without iterating through each element that comes before that element.    forward_list<datatype> creates a new forward list that is empty.    emplace_front() Constructs and inserts an element at beginning of the forward list, right before its current first element.    push_front() Inserts an element at the beginning of the forward list, right before the current first element.    pop_front() removes the first element in the forward list container.    emplace_after() Constructs and inserts a new element after the element at a position.    insert_after() Inserts a new element after the element at a position.    erase_after() Removes elements from a forward list container at a position or a range of positions.    clear() Removes all elements from the forward list container.    Click here for more information about STL forward_lists .    Lists  list container The STL also has a list container which is different from the forward list container in that while a forward list holds a link to the next element in the sequence, a list holds a link to the previous element and the next element. Lists are implemented as doubly-linked-lists. This allows the list to have efficient iteration in both directions. However because of the additional storage space required to store the link to the previous element and the time it takes to insert and remove an element, a forward list is more efficient than a list.  Click here for more information about STL lists .      "
},
{
  "id": "linear-linked_the-ordered-list-abstract-data-type-2-1",
  "level": "2",
  "url": "linear-linked_the-ordered-list-abstract-data-type.html#linear-linked_the-ordered-list-abstract-data-type-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "ordered list "
},
{
  "id": "linear-linked_forward-lists-2",
  "level": "2",
  "url": "linear-linked_the-ordered-list-abstract-data-type.html#linear-linked_forward-lists-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Forward lists "
},
{
  "id": "linear-linked_lists-2",
  "level": "2",
  "url": "linear-linked_the-ordered-list-abstract-data-type.html#linear-linked_lists-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "list container "
},
{
  "id": "linear-linked_summary",
  "level": "1",
  "url": "linear-linked_summary.html",
  "type": "Section",
  "number": "4.7",
  "title": "Summary",
  "body": " Summary    Linked lists or sometimes lists are collections of items where each item holds a relative position.    A linked list implementation maintains logical order without requiring contiguous physical storage requirements.    Modification to the head of the linked list is a special case.       "
},
{
  "id": "linear-linked_discussion-questions",
  "level": "1",
  "url": "linear-linked_discussion-questions.html",
  "type": "Section",
  "number": "4.8",
  "title": "Discussion Questions",
  "body": " Discussion Questions    The alternative implementation of the Queue ADT is to use a list such that the rear of the queue is at the end of the list. What would this mean for Big-O performance?    What is the result of carrying out both steps of the linked list add method in reverse order? What kind of reference results? What types of problems may result?    Explain how the linked list remove method works when the item to be removed is in the last node.    Explain how the remove method works when the item is in the only node in the linked list.       "
},
{
  "id": "linear-linked_programming-exercises",
  "level": "1",
  "url": "linear-linked_programming-exercises.html",
  "type": "Section",
  "number": "4.9",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Implement the Queue ADT, using a list such that the rear of the queue is at the end of the list.    Design and implement an experiment to do benchmark comparisons of the two queue implementations. What can you learn from such an experiment?    It is possible to implement a queue using a linked list such that both enqueue and dequeue have performance on average . In this case it means that most of the time enqueue and dequeue will be except in one particular circumstance where dequeue will be .    To implement the length method, we counted the number of nodes in the list. An alternative strategy would be to store the number of nodes in the list as an additional piece of data in the head of the list. Modify the UnorderedList class to include this information and rewrite the length method.    Implement the remove method so that it works correctly in the case where the item is not in the list.    Modify the list classes to allow duplicates. Which methods will be impacted by this change?    Overload the cout operator in the UnorderedList class. What would be a good printed representation for a list?    Overload the cout operator so that lists are displayed the with square brackets.    Implement the remaining operations defined in the UnorderedList ADT (append, index, pop, insert).    Implement a slice method for the UnorderedList class. It should take two parameters, start and stop , and return a copy of the list starting at the start position and going up to but not including the stop position.    Implement the remaining operations defined in the OrderedList ADT.    Consider the relationship between Unordered and Ordered lists. Is it possible that inheritance could be used to build a more efficient implementation? Implement this inheritance hierarchy.    Implement a stack using linked lists.    Implement a queue using linked lists.    Implement a deque using linked lists.    Design and implement an experiment that will compare the performance of a C++ vector with a list implemented as a linked list.    Design and implement an experiment that will compare the performance of the C++ vector based stack and queue with the linked list implementation.    The linked list implementation given above is called a singly linked list because each node has a single pointer to the next node in sequence. An alternative implementation is known as a doubly linked list. In this implementation, each node has a pointer to the next node (commonly called next) as well as a pointer to the preceding node (commonly called back). The head pointer also contains two pointers, one to the first node in the linked list and one to the last. Code this implementation in C++.       "
},
{
  "id": "linear-linked_glossary",
  "level": "1",
  "url": "linear-linked_glossary.html",
  "type": "Section",
  "number": "4.10",
  "title": "Glossary",
  "body": " Glossary    forward list  a list that is a singly-linked (only links to one other element) sequence container.    head  the first item in a linked list.    linked data structure  a data structure which consists of a set of data structures called nodes which are linked together and organized by links created via references or pointers.    linked list  a linear collection of data elements whose order is not determined by the placement in memory.    linked list traversal  the process of systematically visiting each node in a linked list.    list  a doubly-linked (links to 2 other elements) container.    node  the element of a linked list    ordered linked list  a linked list whose elements are in an order.    ordered list  a list whose elements are ordered.    unordered linked list  a linked list whose elements are not in an order.    Drag the word on the left to its corresponding definition. Review linked lists and their properties.  forward list A list that is a singly-linked (only links to one other element) sequence container.  head The first item in a linked list.  linked data structure A data structure which consists of a set of data structures called nodes which are linked together and organized by links created via references or pointers.  linked list A linear collection of data elements whose order is not determined by the placement in memory.  linked list traversal The process of systematically visiting each node in a linked list.   Drag the word on the left to its corresponding definition. Review linked lists and their properties.  list A doubly-linked (links to 2 other elements) container.  node The element of a linked list.  ordered linked list A linked list whose elements are in an order.  ordered list A list whose elements are ordered.  unordered linked list A linked list whose elements are not in an order.      "
},
{
  "id": "matching_linkedlist0",
  "level": "2",
  "url": "linear-linked_glossary.html#matching_linkedlist0",
  "type": "Checkpoint",
  "number": "4.10.1",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition. Review linked lists and their properties.  forward list A list that is a singly-linked (only links to one other element) sequence container.  head The first item in a linked list.  linked data structure A data structure which consists of a set of data structures called nodes which are linked together and organized by links created via references or pointers.  linked list A linear collection of data elements whose order is not determined by the placement in memory.  linked list traversal The process of systematically visiting each node in a linked list.  "
},
{
  "id": "matching_linkedlist1",
  "level": "2",
  "url": "linear-linked_glossary.html#matching_linkedlist1",
  "type": "Checkpoint",
  "number": "4.10.2",
  "title": "",
  "body": "Drag the word on the left to its corresponding definition. Review linked lists and their properties.  list A doubly-linked (links to 2 other elements) container.  node The element of a linked list.  ordered linked list A linked list whose elements are in an order.  ordered list A list whose elements are ordered.  unordered linked list A linked list whose elements are not in an order.  "
},
{
  "id": "recursion_objectives",
  "level": "1",
  "url": "recursion_objectives.html",
  "type": "Section",
  "number": "5.1",
  "title": "Objectives",
  "body": " Objectives  The goals for this chapter are as follows:    To understand that complex problems that may otherwise be difficult to solve may have a simple recursive solution.    To learn how to formulate programs recursively.    To understand and apply the three laws of recursion.    To understand recursion as a form of iteration.    To implement the recursive formulation of a problem.    To understand how recursion is implemented by a computer system.    "
},
{
  "id": "recursion_what-is-recursion",
  "level": "1",
  "url": "recursion_what-is-recursion.html",
  "type": "Section",
  "number": "5.2",
  "title": "What Is Recursion?",
  "body": " What Is Recursion?  Recursion Recursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. Recursion involves a function calling itself. While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program.  "
},
{
  "id": "recursion_what-is-recursion-2",
  "level": "2",
  "url": "recursion_what-is-recursion.html#recursion_what-is-recursion-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Recursion "
},
{
  "id": "recursion_calculating-the-sum-of-a-vector-of-numbers",
  "level": "1",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html",
  "type": "Section",
  "number": "5.3",
  "title": "Calculating the Sum of a Vector of Numbers",
  "body": " Calculating the Sum of a Vector of Numbers  We will begin our investigation with a simple problem that you already know how to solve without using recursion. Suppose that you want to calculate the sum of a vector of numbers such as: . An iterative function that computes the sum is shown in . The function uses an accumulator variable ( theSum ) to compute a running total of all the numbers in the vector by starting with and adding each number in the vector.   Iterative Sum of Vector  C++ Implementation \/\/Example of summing up a vector without using recursion. #include <iostream> using namespace std; int vectsum(int numVect[]){ int theSum = 0; for (int i = 0; i < 5; i++){ theSum += numVect[i]; } return theSum; } int main() { int numVect[5] = {1, 3, 5, 7, 9}; cout << vectsum(numVect) << endl; return 0; }  Python Implementation #Example of summing up a list without using recursion. def listsum(numList): theSum = 0 for i in numList: theSum = theSum + i return theSum def main(): print(listsum([1, 3, 5, 7, 9])) main()   Pretend for a minute that you do not have while loops or for loops. How would you compute the sum of a vector of numbers? If you were a mathematician you might start by recalling that addition is a function that is defined for two parameters, a pair of numbers. To redefine the problem from adding a vector to adding pairs of numbers, we could rewrite the vector as a fully parenthesized expression. Such an expression looks like this:   We can also parenthesize the expression the other way around,   Notice that the innermost set of parentheses, , is a problem that we can solve without a loop or any special constructs. In fact, we can use the following sequence of simplifications to compute a final sum.   How can we take this idea and turn it into a C++ program? First, let's restate the sum problem in terms of C++ arrays. We might say the sum of the vector numVect is the sum of the first element of the vector ( numVect[0] ), and the sum of the numbers in the rest of the array ( numVect.erase(numVect.begin()+0) ).  In this equation returns the first element of the array and returns an array of everything but the first element. This is easily expressed in C++ as shown in .   Recursive Sum of Vector  C++ Implementation \/\/Example of summing a vector by using recursion. #include <iostream> #include <vector> using namespace std; int vectsum(vector<int> numVect){ if (numVect.size() <= 1){ return numVect[0]; } else { vector<int> slice(numVect.begin() + 1, numVect.begin()+numVect.size()); return numVect[0] + vectsum(slice); \/\/function makes a recursive call to itself. } } int main() { int arr2[] = {1, 3, 5, 7, 9}; vector<int> numVect(arr2, arr2 + (sizeof(arr2) \/ sizeof(arr2[0]))); \/\/Initializes vector with same items as arr2. cout << vectsum(numVect) << endl; return 0; }  Python Implementation #Example of summing a list using recurison. def listsum(numList): if len(numList) == 1: return numList[0] else: return numList[0] + listsum(numList[1:]) #function makes a recursive call to itself. def main(): print(listsum([1, 3, 5, 7, 9])) main()   There are a few key ideas while using vector to look at. First, on line 6 we are checking to see if the vector is one element long. This check is crucial and is our escape clause from the function. The sum of a vector of length 1 is trivial; it is just the number in the vector. Second, on line 11 our function calls itself! This is the reason that we call the vectsum algorithm recursive. A recursive function is a function that calls itself.  shows the series of\\ recursive calls that are needed to sum the vector . recursive calls You should think of this series of calls as a series of simplifications. Each time we make a recursive call we are solving a smaller problem, until we reach the point where the problem cannot get any smaller.   Series of Recursive Calls Adding a List of Numbers.   Stacked visualization of recursive function calls to sum a list of numbers. The top box shows 'sum(1,3,5,7,9)' with an arrow pointing to '1 +'. The next box down shows 'sum(3,5,7,9)' with an arrow pointing to '3 +', followed by boxes for 'sum(5,7,9)' with '5 +', 'sum(7,9)' with '7 +', and the last box 'sum(9)' with just '9'. Each box is connected to the next, representing the recursive nature of the calls.    When we reach the point where the problem is as simple as it can get, we begin to piece together the solutions of each of the small problems until the initial problem is solved. shows the additions that are performed as vectsum works its way backward through the series of calls. When vectsum returns from the topmost problem, we have the solution to the whole problem.   Series of Recursive Returns from Adding a List of Numbers.   Diagram illustrating the resolution of recursive function calls summing a list of numbers. The bottom box shows 'sum(9)' equaling '9', with an arrow pointing left to the next box 'sum(7,9)' showing '7 + 9'. Above that, 'sum(5,7,9)' equals '5 + 16', then 'sum(3,5,7,9)' with '3 + 21', and at the top, 'sum(1,3,5,7,9)' resulting in '1 + 24'. Each function call resolves to a value that is used in the computation of the previous call, with the final sum at the top being '25'.    "
},
{
  "id": "expl-lst-itsum",
  "level": "2",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html#expl-lst-itsum",
  "type": "Exploration",
  "number": "5.3.1",
  "title": "Iterative Sum of Vector.",
  "body": " Iterative Sum of Vector  C++ Implementation \/\/Example of summing up a vector without using recursion. #include <iostream> using namespace std; int vectsum(int numVect[]){ int theSum = 0; for (int i = 0; i < 5; i++){ theSum += numVect[i]; } return theSum; } int main() { int numVect[5] = {1, 3, 5, 7, 9}; cout << vectsum(numVect) << endl; return 0; }  Python Implementation #Example of summing up a list without using recursion. def listsum(numList): theSum = 0 for i in numList: theSum = theSum + i return theSum def main(): print(listsum([1, 3, 5, 7, 9])) main()  "
},
{
  "id": "expl-lst-recsum-cpp",
  "level": "2",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html#expl-lst-recsum-cpp",
  "type": "Exploration",
  "number": "5.3.2",
  "title": "Recursive Sum of Vector.",
  "body": " Recursive Sum of Vector  C++ Implementation \/\/Example of summing a vector by using recursion. #include <iostream> #include <vector> using namespace std; int vectsum(vector<int> numVect){ if (numVect.size() <= 1){ return numVect[0]; } else { vector<int> slice(numVect.begin() + 1, numVect.begin()+numVect.size()); return numVect[0] + vectsum(slice); \/\/function makes a recursive call to itself. } } int main() { int arr2[] = {1, 3, 5, 7, 9}; vector<int> numVect(arr2, arr2 + (sizeof(arr2) \/ sizeof(arr2[0]))); \/\/Initializes vector with same items as arr2. cout << vectsum(numVect) << endl; return 0; }  Python Implementation #Example of summing a list using recurison. def listsum(numList): if len(numList) == 1: return numList[0] else: return numList[0] + listsum(numList[1:]) #function makes a recursive call to itself. def main(): print(listsum([1, 3, 5, 7, 9])) main()  "
},
{
  "id": "recursion_calculating-the-sum-of-a-vector-of-numbers-14",
  "level": "2",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html#recursion_calculating-the-sum-of-a-vector-of-numbers-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "recursive calls "
},
{
  "id": "fig-recsumin",
  "level": "2",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html#fig-recsumin",
  "type": "Figure",
  "number": "5.3.1",
  "title": "",
  "body": " Series of Recursive Calls Adding a List of Numbers.   Stacked visualization of recursive function calls to sum a list of numbers. The top box shows 'sum(1,3,5,7,9)' with an arrow pointing to '1 +'. The next box down shows 'sum(3,5,7,9)' with an arrow pointing to '3 +', followed by boxes for 'sum(5,7,9)' with '5 +', 'sum(7,9)' with '7 +', and the last box 'sum(9)' with just '9'. Each box is connected to the next, representing the recursive nature of the calls.   "
},
{
  "id": "fig-recsumout",
  "level": "2",
  "url": "recursion_calculating-the-sum-of-a-vector-of-numbers.html#fig-recsumout",
  "type": "Figure",
  "number": "5.3.2",
  "title": "",
  "body": " Series of Recursive Returns from Adding a List of Numbers.   Diagram illustrating the resolution of recursive function calls summing a list of numbers. The bottom box shows 'sum(9)' equaling '9', with an arrow pointing left to the next box 'sum(7,9)' showing '7 + 9'. Above that, 'sum(5,7,9)' equals '5 + 16', then 'sum(3,5,7,9)' with '3 + 21', and at the top, 'sum(1,3,5,7,9)' resulting in '1 + 24'. Each function call resolves to a value that is used in the computation of the previous call, with the final sum at the top being '25'.   "
},
{
  "id": "recursion_the-three-laws-of-recursion",
  "level": "1",
  "url": "recursion_the-three-laws-of-recursion.html",
  "type": "Section",
  "number": "5.4",
  "title": "The Three Laws of Recursion",
  "body": " The Three Laws of Recursion  Like the robots of Asimov, all recursive algorithms must obey three important laws:     A recursive algorithm must have a base case .    A recursive algorithm must change its state and move toward the base case.    A recursive algorithm must call itself, recursively.     Let's look at each one of these laws in more detail and see how it was used in the vectsum algorithm. First, a base case is the condition that allows the algorithm to stop recursing. base case A base case is typically a problem that is small enough to solve directly. In the vectsum algorithm the base case is a list of length 1.  To obey the second law, we must arrange for a change of state that moves the algorithm toward the base case. A change of state means that some data that the algorithm is using is modified. Usually the data that represents our problem gets smaller in some way. In the vectsum algorithm our primary data structure is a vector, so we must focus our state-changing efforts on the vector. Since the base case is a list of length 1, a natural progression toward the base case is to shorten the vector. This is exactly what happens on line 5 of when we call vectsum with a shorter list.  The final law is that the algorithm must call itself. This is the very definition of recursion. Recursion is a confusing concept to many beginning programmers. As a novice programmer, you have learned that functions are good because you can take a large problem and break it up into smaller problems. The smaller problems can be solved by writing a function to solve each problem. When we talk about recursion it may seem that we are talking ourselves in circles. We have a problem to solve with a function, but that function solves the problem by calling itself! But the logic is not circular at all; the logic of recursion is an elegant expression of solving a problem by breaking it down into smaller and easier problems.  It is important to note that regardless of whether or not a recursive function implements these three rules, it may still take an unrealistic amount of time to compute (and thus not be particularly useful). A great example of this is the ackermann function (shown in ), named after Wilhelm Ackermann, which recursively expands to unrealistic proportions. An example as to how many calls this function makes to itself is the case of ackermann(4,3). In this case, it calls itself well over 100 billion times, with an average time of expected completion that falls after the predicted end of the universe. Despite this, it will eventually come to an answer, but you probably won't be around to see it. This goes to show that the efficiency of recursive functions are largely dependent on how they're implemented.   Ackermann Function  \/\/ackermann function example #include <iostream> using namespace std; unsigned int ackermann(unsigned int m, unsigned int n) { if (m == 0) {\/\/Base case return n + 1; } if (n == 0) { return ackermann(m - 1, 1);\/\/ subtract, move to base case } \/\/notice a call to the ackermann function as a parameter \/\/for another call to the ackermann function. This is where \/\/it gets unrealistically complicated. return ackermann(m - 1, ackermann(m, n - 1));\/\/subtract here too } int main(){ \/\/compute the ackermann function. \/\/Try replacing the 1,2 parameters with 4,3 and see what happens cout << ackermann(1,2) << endl; return 0; }   In the remainder of this chapter we will look at more examples of recursion. In each case we will focus on designing a solution to a problem by using the three laws of recursion.    Why is a base case needed in a recursive function?     If a recursive function didn't have a base case, then the function would end too early.    Incorrect. The complete opposite would happen instead.      If a recursive function didn't have a base case, then the function would return an undesired outcome.    Incorrect. In fact, the program wouldn't return anything.      If a recursive function didn't have a base case, then the function would continue to make recursive calls creating an infinite loop.    Correct! a base case is needed to end the continuous recursive calls, so that the program doesn't get stuck in a never ending loop.      If a recursive function didn't have a base case, then the function would not be able to ever make recursive calls in the first place.    Incorrect. Recursive calls will continue to be called even without a base case.      How many recursive calls are made when computing the sum of the vector {2,4,6,8,10}?     6    There are only five numbers on the vector, the number of recursive calls will not be greater than the size of the vector.      5    The initial call to vectsum is not a recursive call.      4    the first recursive call passes the vector {4,6,8,10}, the second {6,8,10} and so on until [10].      3    This would not be enough calls to cover all the numbers on the vector      Suppose you are going to write a recursive function to calculate the factorial of a number. fact(n) returns n * n-1 * n-2 * … Where the factorial of zero is defined to be 1. What would be the most appropriate base case?     n == 0    Although this would work there are better and slightly more efficient choices. since fact(1) and fact(0) are the same.      n == 1    A good choice, but what happens if you call fact(0)?      n >= 0    This base case would be true for all numbers greater than zero so fact of any positive number would be 1.      n <= 1    Good, this is the most efficient, and even keeps your program from crashing if you try to compute the factorial of a negative number.      "
},
{
  "id": "recursion_the-three-laws-of-recursion-3-1",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#recursion_the-three-laws-of-recursion-3-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "base case "
},
{
  "id": "recursion_the-three-laws-of-recursion-4",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#recursion_the-three-laws-of-recursion-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "base case "
},
{
  "id": "ackermann",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#ackermann",
  "type": "Listing",
  "number": "5.4.1",
  "title": "",
  "body": " Ackermann Function  \/\/ackermann function example #include <iostream> using namespace std; unsigned int ackermann(unsigned int m, unsigned int n) { if (m == 0) {\/\/Base case return n + 1; } if (n == 0) { return ackermann(m - 1, 1);\/\/ subtract, move to base case } \/\/notice a call to the ackermann function as a parameter \/\/for another call to the ackermann function. This is where \/\/it gets unrealistically complicated. return ackermann(m - 1, ackermann(m, n - 1));\/\/subtract here too } int main(){ \/\/compute the ackermann function. \/\/Try replacing the 1,2 parameters with 4,3 and see what happens cout << ackermann(1,2) << endl; return 0; }  "
},
{
  "id": "question_recsimp_1",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#question_recsimp_1",
  "type": "Reading Question",
  "number": "5.4.1",
  "title": "",
  "body": " Why is a base case needed in a recursive function?     If a recursive function didn't have a base case, then the function would end too early.    Incorrect. The complete opposite would happen instead.      If a recursive function didn't have a base case, then the function would return an undesired outcome.    Incorrect. In fact, the program wouldn't return anything.      If a recursive function didn't have a base case, then the function would continue to make recursive calls creating an infinite loop.    Correct! a base case is needed to end the continuous recursive calls, so that the program doesn't get stuck in a never ending loop.      If a recursive function didn't have a base case, then the function would not be able to ever make recursive calls in the first place.    Incorrect. Recursive calls will continue to be called even without a base case.    "
},
{
  "id": "question_recsimp_2",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#question_recsimp_2",
  "type": "Reading Question",
  "number": "5.4.2",
  "title": "",
  "body": " How many recursive calls are made when computing the sum of the vector {2,4,6,8,10}?     6    There are only five numbers on the vector, the number of recursive calls will not be greater than the size of the vector.      5    The initial call to vectsum is not a recursive call.      4    the first recursive call passes the vector {4,6,8,10}, the second {6,8,10} and so on until [10].      3    This would not be enough calls to cover all the numbers on the vector    "
},
{
  "id": "question_recsimp_3",
  "level": "2",
  "url": "recursion_the-three-laws-of-recursion.html#question_recsimp_3",
  "type": "Reading Question",
  "number": "5.4.3",
  "title": "",
  "body": " Suppose you are going to write a recursive function to calculate the factorial of a number. fact(n) returns n * n-1 * n-2 * … Where the factorial of zero is defined to be 1. What would be the most appropriate base case?     n == 0    Although this would work there are better and slightly more efficient choices. since fact(1) and fact(0) are the same.      n == 1    A good choice, but what happens if you call fact(0)?      n >= 0    This base case would be true for all numbers greater than zero so fact of any positive number would be 1.      n <= 1    Good, this is the most efficient, and even keeps your program from crashing if you try to compute the factorial of a negative number.    "
},
{
  "id": "recursion_converting-an-integer-to-a-string-in-any-base",
  "level": "1",
  "url": "recursion_converting-an-integer-to-a-string-in-any-base.html",
  "type": "Section",
  "number": "5.5",
  "title": "Converting an Integer to a String in Any Base",
  "body": " Converting an Integer to a String in Any Base  Suppose you want to convert an integer to a string in some base between binary and hexadecimal. For example, convert the integer 10 to its string representation in decimal as \"10\" , or to its string representation in binary as \"1010\" . While there are many algorithms to solve this problem, including the algorithm discussed in the stack section, the recursive formulation of the problem is very elegant.  Let's look at a concrete example using base 10 and the number 769. Suppose we have a sequence of characters corresponding to the first 10 digits, like convString = \"0123456789\" . It is easy to convert a number less than 10 to its string equivalent by looking it up in the sequence. For example, if the number is 9, then the string is convString[9] or \"9\" . If we can arrange to break up the number 769 into three single-digit numbers, 7, 6, and 9, then converting it to a string is simple. A number less than 10 sounds like a good base case.  Knowing what our base is suggests that the overall algorithm will involve three components:     Reduce the original number to a series of single-digit numbers.    Convert the single digit-number to a string using a lookup.    Concatenate the single-digit strings together to form the final result.     The next step is to figure out how to change state and make progress toward the base case. Since we are working with an integer, let's consider what mathematical operations might reduce a number. The most likely candidates are division and subtraction. While subtraction might work, it is unclear what we should subtract from what. Integer division with remainders gives us a clear direction. Let's look at what happens if we divide a number by the base we are trying to convert to.  Using integer division to divide 769 by 10, we get 76 with a remainder of 9. This gives us two good results. First, the remainder is a number less than our base that can be converted to a string immediately by lookup. Second, we get a number that is smaller than our original and moves us toward the base case of having a single number less than our base. Now our job is to convert 76 to its string representation. Again we will use integer division plus remainder to get results of 7 and 6 respectively. Finally, we have reduced the problem to converting 7, which we can do easily since it satisfies the base case condition of , where . The series of operations we have just performed is illustrated in . Notice that the numbers we want to remember are in the remainder boxes along the right side of the diagram.   Converting an Integer to a String in Base 10.   Flowchart demonstrating the conversion of an integer to a string in base 10 using recursion. The process starts with 'toStr(769)', which divides '769' by '10' and adds the remainder 'g'. The result feeds into 'toStr(76)', which again divides by '10' to add the remainder '6'. The final call is 'toStr(7)', which is less than '10' and therefore converts directly to '7'. The remainders at each step are used to build the string representation of the integer.    shows the C++ and Python code that implements the algorithm outlined above for any base between 2 and 16.   Convert Integer to String  C++ Implementation \/\/Recursive example of converting from int to string. #include <iostream> #include <string> using namespace std; string toStr(int n, int base) { string convertString = \"0123456789ABCDEF\"; if (n < base) { return string(1, convertString[n]); \/\/ converts char to string, and returns it } else { return toStr(n\/base, base) + convertString[n%base]; \/\/ function makes a recursive call to itself. } } int main() { cout << toStr(1453, 16); }  Python Implementation #Recursive example of converting an int to str. def toStr(n,base): convertString = \"0123456789ABCDEF\" if n < base: return convertString[n] else: return toStr(n\/\/base,base) + convertString[n%base] #function makes a recursive call to itself. def main(): print(toStr(1453,16)) main()   Notice that in line 7 we check for the base case where n is less than the base we are converting to. When we detect the base case, we stop recursing and simply return the string from the convertString sequence. In line 10 we satisfy both the second and third laws–by making the recursive call and by reducing the problem size–using division.  Let's trace the algorithm again; this time we will convert the number 10 to its base 2 string representation ( \"1010\" ).   Converting the Number 10 to its Base 2 String Representation.   Flowchart depicting the recursive process of converting the number 10 to its binary (base 2) string representation. The topmost operation 'toStr(10)' shows the division '10 \/ 2' with a remainder '0'. This leads to 'toStr(5)', with division '5 \/ 2' and remainder '1', followed by 'toStr(2)' with division '2 \/ 2' and remainder '0', and finally 'toStr(1)' indicating '1 < 2' and yielding a remainder '1'. The remainders collected at each step form the binary representation of the number 10.    shows that we get the results we are looking for, but it looks like the digits are in the wrong order. The algorithm works correctly because we make the recursive call first on line 6, then we add the string representation of the remainder. If we reversed returning the convertString lookup and returning the toStr call, the resulting string would be backward! But by delaying the concatenation operation until after the recursive call has returned, we get the result in the proper order. This should remind you of our discussion of stacks back in the previous chapter.    Is the process of stepping through a recursive function similar to the construct of a stack or a queue?     A stack, because a recursive function will complete the final function call before any of the other function calls, similar to how a stack has the Last-in-First-out principle.    Correct! a recursive function will complete the final function call first, because the rest of the calls are waiting for the results of the calls they made.      A queue, because a recursive function will complete its intial function call before any of the other function calls, similar to how a queue has the First-in-First-out principle.    Incorrect. Think of it this way, when a function is called and it calls itself, the original function call cannot be completed until the new function call is completed.     Write a function that takes a string as a parameter and returns a new string that is the reverse of the old string. Hint: using the substr(strIndex1, strIndex2) method for returning specific sections of a string can help.    #include <iostream> #include <string> using namespace std; void testEqual(string a, string b){ if (a == b){ cout << \"PASS\" << endl; } else{ cout << \"Failed\" << endl; } } string reverse(string s){ \/\/Code Here return s; } int main(){ testEqual(reverse(\"hello\"),\"olleh\"); testEqual(reverse(\"l\"),\"l\"); testEqual(reverse(\"follow\"),\"wollof\"); testEqual(reverse(\"\"),\"\"); return 0; }    Write a function that takes a string as a parameter and returns True if the string is a palindrome, False otherwise. Remember that a string is a palindrome if it is spelled the same both forward and backward. For example: radar is a palindrome. for bonus points palindromes can also be phrases, but you need to remove the spaces and punctuation before checking. for example: madam i'm adam is a palindrome. Other fun palindromes include:    kayak.    aibohphobia.    Live not on evil.    Reviled did I live, said I, as evil I did deliver.    Go hang a salami; I'm a lasagna hog.    Able was I ere I saw Elba.    Kanakanak – a town in Alaska.    Wassamassaw – a town in South Dakota.      #include <iostream> #include <string> using namespace std; void testEqual(bool a, bool b){ if (a == b){ cout << \"PASS\" << endl; } else{ cout << \"Failed\" << endl; } } string removeWhite(string s) { \/\/Code Here return s; } bool isPal(string s) { \/\/Code Here return false; } int main(){ testEqual(isPal(removeWhite(\"x\")),true); testEqual(isPal(removeWhite(\"radar\")),true); testEqual(isPal(removeWhite(\"hello\")),false); testEqual(isPal(removeWhite(\"\")),true); testEqual(isPal(removeWhite(\"hannah\")),true); testEqual(isPal(removeWhite(\"madam i'm adam\")),true); return 0; }     "
},
{
  "id": "fig-tostr",
  "level": "2",
  "url": "recursion_converting-an-integer-to-a-string-in-any-base.html#fig-tostr",
  "type": "Figure",
  "number": "5.5.1",
  "title": "",
  "body": " Converting an Integer to a String in Base 10.   Flowchart demonstrating the conversion of an integer to a string in base 10 using recursion. The process starts with 'toStr(769)', which divides '769' by '10' and adds the remainder 'g'. The result feeds into 'toStr(76)', which again divides by '10' to add the remainder '6'. The final call is 'toStr(7)', which is less than '10' and therefore converts directly to '7'. The remainders at each step are used to build the string representation of the integer.   "
},
{
  "id": "expl-rectostr",
  "level": "2",
  "url": "recursion_converting-an-integer-to-a-string-in-any-base.html#expl-rectostr",
  "type": "Exploration",
  "number": "5.5.1",
  "title": "Convert Integer to String.",
  "body": " Convert Integer to String  C++ Implementation \/\/Recursive example of converting from int to string. #include <iostream> #include <string> using namespace std; string toStr(int n, int base) { string convertString = \"0123456789ABCDEF\"; if (n < base) { return string(1, convertString[n]); \/\/ converts char to string, and returns it } else { return toStr(n\/base, base) + convertString[n%base]; \/\/ function makes a recursive call to itself. } } int main() { cout << toStr(1453, 16); }  Python Implementation #Recursive example of converting an int to str. def toStr(n,base): convertString = \"0123456789ABCDEF\" if n < base: return convertString[n] else: return toStr(n\/\/base,base) + convertString[n%base] #function makes a recursive call to itself. def main(): print(toStr(1453,16)) main()  "
},
{
  "id": "fig-tostr2",
  "level": "2",
  "url": "recursion_converting-an-integer-to-a-string-in-any-base.html#fig-tostr2",
  "type": "Figure",
  "number": "5.5.2",
  "title": "",
  "body": " Converting the Number 10 to its Base 2 String Representation.   Flowchart depicting the recursive process of converting the number 10 to its binary (base 2) string representation. The topmost operation 'toStr(10)' shows the division '10 \/ 2' with a remainder '0'. This leads to 'toStr(5)', with division '5 \/ 2' and remainder '1', followed by 'toStr(2)' with division '2 \/ 2' and remainder '0', and finally 'toStr(1)' indicating '1 < 2' and yielding a remainder '1'. The remainders collected at each step form the binary representation of the number 10.   "
},
{
  "id": "RecursiveQ1",
  "level": "2",
  "url": "recursion_converting-an-integer-to-a-string-in-any-base.html#RecursiveQ1",
  "type": "Reading Question",
  "number": "5.5.1",
  "title": "",
  "body": " Is the process of stepping through a recursive function similar to the construct of a stack or a queue?     A stack, because a recursive function will complete the final function call before any of the other function calls, similar to how a stack has the Last-in-First-out principle.    Correct! a recursive function will complete the final function call first, because the rest of the calls are waiting for the results of the calls they made.      A queue, because a recursive function will complete its intial function call before any of the other function calls, similar to how a queue has the First-in-First-out principle.    Incorrect. Think of it this way, when a function is called and it calls itself, the original function call cannot be completed until the new function call is completed.    "
},
{
  "id": "recursion_stack-frames-implementing-recursion",
  "level": "1",
  "url": "recursion_stack-frames-implementing-recursion.html",
  "type": "Section",
  "number": "5.6",
  "title": "Stack Frames: Implementing Recursion",
  "body": " Stack Frames: Implementing Recursion  Suppose that instead of concatenating the result of the recursive call to toStr with the string from convertString , we modified our algorithm to push the strings onto a stack instead of making the recursive call. The code for this modified algorithm is shown in .   Using Stack Instead of Recursion  C++ Implementation \/\/Example of the toStr function using a stack instead of recursion. #include <iostream> #include <string> #include <stack> using namespace std; stack<char> rStack; string toStr(int n, int base) { string convertString = \"0123456789ABCDEF\"; while (n > 0) { if (n < base) { rStack.push(convertString[n]); \/\/pushes string n to the stack } else { rStack.push(convertString[n % base]); \/\/pushes string n modulo base to the stack. } n = n\/base; } string res; while (!rStack.empty()) { \/\/combines all the items in the stack into a full string. res = res + (string(1, rStack.top())); rStack.pop(); } return res; } int main() { cout << toStr(1453, 16); }  Python Implementation #Example of the toStr function using a stack instead of recursion. from pythonds.basic.stack import Stack rStack = Stack() def toStr(n,base): convertString = \"0123456789ABCDEF\" while n > 0: if n < base: rStack.push(convertString[n]) #adds string n to the stack. else: rStack.push(convertString[n % base]) #adds string n modulo base to the stack. n = n \/\/ base res = \"\" while not rStack.isEmpty(): #combines all the items in the stack to make the full string. res = res + str(rStack.pop()) return res def main(): print(toStr(1453,16)) main()   Each time we make a call to toStr , we push a character on the stack. Returning to the previous example we can see that after the fourth call to toStr the stack would look like . Notice that now we can simply pop the characters off the stack and concatenate them into the final result, \"1010\" .   Strings Placed on the Stack During Conversion.   Image of a stack with character strings representing the result of a conversion process. The stack shows four blocks, each containing a single character. From top to bottom, the blocks are labeled '1', '0', '1', and '0', aligned vertically above a horizontal line that represents the base of the stack. This illustrates the sequence of characters placed on the stack during a number conversion, presumably from a recursive process.    The previous example gives us some insight into how C++ implements a recursive function call. When a function is called in Python, a stack frame is allocated to handle the local variables of the function. When the function returns, the return value is left on top of the stack for the calling function to access. illustrates the call stack after the return statement on line 4.   Call Stack Generated from toStr(10,2).   Diagram illustrating a call stack generated from the function toStr(10,2), which converts the number 10 into a base 2 string. The bottom of the stack shows 'toStr(10\/2, 2) + convertString[10%2]', then above it 'toStr(5,2) n = 5 base = 2' with 'toStr(5\/2,2) + convertString[5%2]', followed by 'toStr(2,2) n = 2 base = 2' and at the top 'toStr(2\/2,2) + convertString[2%2]'. A single character '1' floats above the stack, indicating the start of the conversion process.    Notice that the call to toStr(2\/\/2,2) leaves a return value of \"1\" on the stack. This return value is then used in place of the function call ( toStr(1,2) ) in the expression \"1\" + convertString[2%2] , which will leave the string \"10\" on the top of the stack. In this way, the C++ call stack takes the place of the stack we used explicitly in . In our list summing example, you can think of the return value on the stack taking the place of an accumulator variable.  The stack frames also provide a scope for the variables used by the function. Even though we are calling the same function over and over, each call creates a new scope for the variables that are local to the function.  "
},
{
  "id": "expl-lst-recstack-cpp",
  "level": "2",
  "url": "recursion_stack-frames-implementing-recursion.html#expl-lst-recstack-cpp",
  "type": "Exploration",
  "number": "5.6.1",
  "title": "Using Stack Instead of Recursion.",
  "body": " Using Stack Instead of Recursion  C++ Implementation \/\/Example of the toStr function using a stack instead of recursion. #include <iostream> #include <string> #include <stack> using namespace std; stack<char> rStack; string toStr(int n, int base) { string convertString = \"0123456789ABCDEF\"; while (n > 0) { if (n < base) { rStack.push(convertString[n]); \/\/pushes string n to the stack } else { rStack.push(convertString[n % base]); \/\/pushes string n modulo base to the stack. } n = n\/base; } string res; while (!rStack.empty()) { \/\/combines all the items in the stack into a full string. res = res + (string(1, rStack.top())); rStack.pop(); } return res; } int main() { cout << toStr(1453, 16); }  Python Implementation #Example of the toStr function using a stack instead of recursion. from pythonds.basic.stack import Stack rStack = Stack() def toStr(n,base): convertString = \"0123456789ABCDEF\" while n > 0: if n < base: rStack.push(convertString[n]) #adds string n to the stack. else: rStack.push(convertString[n % base]) #adds string n modulo base to the stack. n = n \/\/ base res = \"\" while not rStack.isEmpty(): #combines all the items in the stack to make the full string. res = res + str(rStack.pop()) return res def main(): print(toStr(1453,16)) main()  "
},
{
  "id": "fig-recstack",
  "level": "2",
  "url": "recursion_stack-frames-implementing-recursion.html#fig-recstack",
  "type": "Figure",
  "number": "5.6.1",
  "title": "",
  "body": " Strings Placed on the Stack During Conversion.   Image of a stack with character strings representing the result of a conversion process. The stack shows four blocks, each containing a single character. From top to bottom, the blocks are labeled '1', '0', '1', and '0', aligned vertically above a horizontal line that represents the base of the stack. This illustrates the sequence of characters placed on the stack during a number conversion, presumably from a recursive process.   "
},
{
  "id": "recursion_stack-frames-implementing-recursion-6",
  "level": "2",
  "url": "recursion_stack-frames-implementing-recursion.html#recursion_stack-frames-implementing-recursion-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "stack frame "
},
{
  "id": "fig-callstack",
  "level": "2",
  "url": "recursion_stack-frames-implementing-recursion.html#fig-callstack",
  "type": "Figure",
  "number": "5.6.2",
  "title": "",
  "body": " Call Stack Generated from toStr(10,2).   Diagram illustrating a call stack generated from the function toStr(10,2), which converts the number 10 into a base 2 string. The bottom of the stack shows 'toStr(10\/2, 2) + convertString[10%2]', then above it 'toStr(5,2) n = 5 base = 2' with 'toStr(5\/2,2) + convertString[5%2]', followed by 'toStr(2,2) n = 2 base = 2' and at the top 'toStr(2\/2,2) + convertString[2%2]'. A single character '1' floats above the stack, indicating the start of the conversion process.   "
},
{
  "id": "recursion_introduction-visualizing-recursion",
  "level": "1",
  "url": "recursion_introduction-visualizing-recursion.html",
  "type": "Section",
  "number": "5.7",
  "title": "Introduction: Visualizing Recursion",
  "body": " Introduction: Visualizing Recursion  In the previous section we looked at some problems that were easy to solve using recursion; however, it can still be difficult to find a mental model or a way of visualizing what is happening in a recursive function. This can make recursion difficult for people to grasp. In this section we will look at a couple of examples of using recursion to draw some interesting pictures. As you watch these pictures take shape you will get some new insight into the recursive process that may be helpful in cementing your understanding of recursion.  The conventional tool used for these kinds of illustrations is Python's turtle graphics module called turtle . The turtle module is standard with all versions of Python and is very easy to use. The metaphor is quite simple. You can create a turtle and the turtle can move forward, backward, turn left, turn right, etc. The turtle can have its tail up or down. When the turtle's tail is down and the turtle moves it draws a line as it moves. To increase the artistic value of the turtle you can change the width of the tail as well as the color of the ink the tail is dipped in.  Here is a simple example to illustrate some turtle graphics basics. We will use the turtle module to draw a spiral recursively. shows how it is done. After importing the turtle module we create a turtle. When the turtle is created it also creates a window for itself to draw in. Next we define the drawSpiral function. The base case for this simple function is when the length of the line we want to draw, as given by the len parameter, is reduced to zero or less. If the length of the line is longer than zero we instruct the turtle to go forward by len units and then turn right 90 degrees. The recursive step is when we call drawSpiral again with a reduced length.   Example of Turtle Graphics  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void spiral(ct::Turtle& turtle, int length) { if (length > 0) { turtle.forward(length); turtle.right(90); spiral(turtle, length - 5); } } int main() { ct::TurtleScreen screen; ct::Turtle turtle(screen); spiral(turtle, 100); screen.bye(); return 0; }  Python Implementation #Creates an inward spiral through recursion. import turtle def drawSpiral(myTurtle, lineLen): if lineLen > 0: myTurtle.forward(lineLen) myTurtle.right(90) drawSpiral(myTurtle,lineLen-5) #function makes recursive call. def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() drawSpiral(myTurtle,100) myWin.exitonclick() main()   That is really about all the turtle graphics you need to know in order to make some pretty impressive drawings. For our next program we are going to draw a fractal tree. Fractals come from a branch of mathematics, and have much in common with recursion. The definition of a fractal is that when you look at it the fractal has the same basic shape no matter how much you magnify it. Some examples from nature are the coastlines of continents, snowflakes, mountains, and even trees or shrubs. The fractal nature of many of these natural phenomenon makes it possible for programmers to generate very realistic looking scenery for computer generated movies. In our next example we will generate a fractal tree.  To understand how this is going to work it is helpful to think of how we might describe a tree using a fractal vocabulary. Remember that we said above that a fractal is something that looks the same at all different levels of magnification. If we translate this to trees and shrubs we might say that even a small twig has the same shape and characteristics as a whole tree. Using this idea we could say that a tree is a trunk, with a smaller tree going off to the right and another smaller tree going off to the left. If you think of this definition recursively it means that we will apply the recursive definition of a tree to both of the smaller left and right trees.  Let's translate this idea to some C++ code. shows how we can use Python with our turtle to generate a fractal tree. Let's look at the code a bit more closely. You will see that on lines 5 and 7 we are making a recursive call. On line 5 we make the recursive call right after the turtle turns to the right by 20 degrees; this is the right tree mentioned above. Then in line 7 the turtle makes another recursive call, but this time after turning left by 40 degrees. The reason the turtle must turn left by 40 degrees is that it needs to undo the original 20 degree turn to the right and then do an additional 20 degree turn to the left in order to draw the left tree. Also notice that each time we make a recursive call to tree we subtract some amount from the branchLen parameter; this is to make sure that the recursive trees get smaller and smaller. You should also recognize the initial if statement on line 2 as a check for the base case of branchLen getting too small. The C++ equivalent to this function is shown below and exists in Turtle.cpp .   Fractal Tree  def tree(branchLen,t): if branchLen > 5: t.forward(branchLen) t.right(20) tree(branchLen-15,t) t.left(40) tree(branchLen-10,t) t.right(20) t.backward(branchLen)   The complete program for this tree example is shown in . Before you run the code think about how you expect to see the tree take shape. Look at the recursive calls and think about how this tree will unfold. Will it be drawn symmetrically with the right and left halves of the tree taking shape simultaneously? Will it be drawn right side first then left side?   Complete Tree Code  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void tree(ct::Turtle& turtle, int length) { if(length > 5){ turtle.forward(length); turtle.right(20); tree(turtle, length - 15); turtle.left(40); tree(turtle, length - 15); turtle.right(20); turtle.back(length); } } int main() { ct::TurtleScreen screen; screen.tracer(3);\/\/Draw faster. ct::Turtle turtle(screen); turtle.pencolor({\"green\"}); \/\/Make the trees \"grow\" upwards turtle.left(90); \/\/Start growing from further down. turtle.penup(); turtle.backward(100); turtle.pendown(); \/\/Draw the tree. tree(turtle, 75); screen.bye(); return 0; }  Python Implementation #Creates a tree by using recursion. import turtle def tree(branchLen,t): if branchLen > 5: t.forward(branchLen) #Turtle goes forward. t.right(20) tree(branchLen-15,t) #Recursive call t.left(40) tree(branchLen-15,t) #Recursive call t.right(20) t.backward(branchLen) #Turtle must go back the same distance #as it went forward to draw the tree #evenly. def main(): t = turtle.Turtle() myWin = turtle.Screen() t.left(90) t.up() t.backward(100) t.down() t.color(\"green\") tree(75,t) myWin.exitonclick() main()   Notice how each branch point on the tree corresponds to a recursive call, and notice how the tree is drawn to the right all the way down to its shortest twig. You can see this in . Now, notice how the program works its way back up the trunk until the entire right side of the tree is drawn. You can see the right half of the tree in . Then the left side of the tree is drawn, but not by going as far out to the left as possible. Rather, once again the entire right side of the left tree is drawn until we finally make our way out to the smallest twig on the left.   The Beginning of a Fractal Tree.   Screenshot of a computer window titled 'Python Turtle Graphics' showing the initial stage of a fractal tree drawing. The window displays a simple black curve on a white background, representing the trunk of the tree starting to branch off. This image captures the first step in a programming exercise to draw a complex fractal tree using recursive functions.     The First Half of the Tree.   Screenshot of a computer window with the title 'Python Turtle Graphics', depicting a partially completed fractal tree drawing. The graphic shows a black tree with a simple trunk that splits into several branching limbs and smaller branches, all rendered on a white background. The image visually represents the midpoint of a recursive drawing process in programming, with the tree structure becoming increasingly complex towards the top.    This simple tree program is just a starting point for you, and you will notice that the tree does not look particularly realistic because nature is just not as symmetric as a computer program. The exercises at the end of the chapter will give you some ideas for how to explore some interesting options to make your tree look more realistic.   Modify the recursive tree program using one or all of the following ideas:    Find the HDC-related operations to modify the thickness of the branches so that as the branchLen gets smaller, the line gets thinner.    Modify the color of the branches so that as the branchLen gets very short it is colored like a leaf.    Modify the angle used in turning the turtle so that at each branch point the angle is selected at random in some range. For example choose the angle between 15 and 45 degrees. Play around to see what looks good.    Modify the branchLen recursively so that instead of always subtracting the same amount you subtract a random amount in some range.         "
},
{
  "id": "expl-lst-turt1-cpp",
  "level": "2",
  "url": "recursion_introduction-visualizing-recursion.html#expl-lst-turt1-cpp",
  "type": "Exploration",
  "number": "5.7.1",
  "title": "Example of Turtle Graphics.",
  "body": " Example of Turtle Graphics  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void spiral(ct::Turtle& turtle, int length) { if (length > 0) { turtle.forward(length); turtle.right(90); spiral(turtle, length - 5); } } int main() { ct::TurtleScreen screen; ct::Turtle turtle(screen); spiral(turtle, 100); screen.bye(); return 0; }  Python Implementation #Creates an inward spiral through recursion. import turtle def drawSpiral(myTurtle, lineLen): if lineLen > 0: myTurtle.forward(lineLen) myTurtle.right(90) drawSpiral(myTurtle,lineLen-5) #function makes recursive call. def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() drawSpiral(myTurtle,100) myWin.exitonclick() main()  "
},
{
  "id": "lst-fractree-py",
  "level": "2",
  "url": "recursion_introduction-visualizing-recursion.html#lst-fractree-py",
  "type": "Listing",
  "number": "5.7.1",
  "title": "",
  "body": " Fractal Tree  def tree(branchLen,t): if branchLen > 5: t.forward(branchLen) t.right(20) tree(branchLen-15,t) t.left(40) tree(branchLen-10,t) t.right(20) t.backward(branchLen)  "
},
{
  "id": "expl-lst-complete-tree-cpp",
  "level": "2",
  "url": "recursion_introduction-visualizing-recursion.html#expl-lst-complete-tree-cpp",
  "type": "Exploration",
  "number": "5.7.2",
  "title": "Complete Tree Code.",
  "body": " Complete Tree Code  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void tree(ct::Turtle& turtle, int length) { if(length > 5){ turtle.forward(length); turtle.right(20); tree(turtle, length - 15); turtle.left(40); tree(turtle, length - 15); turtle.right(20); turtle.back(length); } } int main() { ct::TurtleScreen screen; screen.tracer(3);\/\/Draw faster. ct::Turtle turtle(screen); turtle.pencolor({\"green\"}); \/\/Make the trees \"grow\" upwards turtle.left(90); \/\/Start growing from further down. turtle.penup(); turtle.backward(100); turtle.pendown(); \/\/Draw the tree. tree(turtle, 75); screen.bye(); return 0; }  Python Implementation #Creates a tree by using recursion. import turtle def tree(branchLen,t): if branchLen > 5: t.forward(branchLen) #Turtle goes forward. t.right(20) tree(branchLen-15,t) #Recursive call t.left(40) tree(branchLen-15,t) #Recursive call t.right(20) t.backward(branchLen) #Turtle must go back the same distance #as it went forward to draw the tree #evenly. def main(): t = turtle.Turtle() myWin = turtle.Screen() t.left(90) t.up() t.backward(100) t.down() t.color(\"green\") tree(75,t) myWin.exitonclick() main()  "
},
{
  "id": "fig-tree1",
  "level": "2",
  "url": "recursion_introduction-visualizing-recursion.html#fig-tree1",
  "type": "Figure",
  "number": "5.7.2",
  "title": "",
  "body": " The Beginning of a Fractal Tree.   Screenshot of a computer window titled 'Python Turtle Graphics' showing the initial stage of a fractal tree drawing. The window displays a simple black curve on a white background, representing the trunk of the tree starting to branch off. This image captures the first step in a programming exercise to draw a complex fractal tree using recursive functions.   "
},
{
  "id": "fig-tree2",
  "level": "2",
  "url": "recursion_introduction-visualizing-recursion.html#fig-tree2",
  "type": "Figure",
  "number": "5.7.3",
  "title": "",
  "body": " The First Half of the Tree.   Screenshot of a computer window with the title 'Python Turtle Graphics', depicting a partially completed fractal tree drawing. The graphic shows a black tree with a simple trunk that splits into several branching limbs and smaller branches, all rendered on a white background. The image visually represents the midpoint of a recursive drawing process in programming, with the tree structure becoming increasingly complex towards the top.   "
},
{
  "id": "recursion_sierpinski-triangle",
  "level": "1",
  "url": "recursion_sierpinski-triangle.html",
  "type": "Section",
  "number": "5.8",
  "title": "Sierpinski Triangle",
  "body": " Sierpinski Triangle  Another fractal that exhibits the property of self-similarity is the Sierpinski triangle. An example is shown in . The Sierpinski triangle illustrates a three-way recursive algorithm. The procedure for drawing a Sierpinski triangle by hand is simple. Start with a single large triangle. Divide this large triangle into three new triangles by connecting the midpoint of each side. Ignoring the middle triangle that you just created, apply the same procedure to each of the three corner triangles. Each time you create a new set of triangles, you recursively apply this procedure to the three smaller corner triangles. You can continue to apply this procedure indefinitely if you have a sharp enough pencil. Before you continue reading, you may want to try drawing the Sierpinski triangle yourself, using the method described.   The Sierpinski Triangle.   Image of the Sierpinski Triangle, a fractal composed of colored triangles. The main triangle is outlined with progressively smaller triangles in alternating colors of red, green, and white, forming a pattern that repeats at smaller scales. The center of the triangle features a large inverted blue triangle, emphasizing the fractal's characteristic self-similarity.    Since we can continue to apply the algorithm indefinitely, what is the base case? We will see that the base case is set arbitrarily as the number of times we want to divide the triangle into pieces. Sometimes we call this number the degree of the fractal. Each time we make a recursive call, we subtract 1 from the degree until we reach 0. When we reach a degree of 0, we stop making recursive calls. The code that generated the Sierpinski Triangle in is shown in .   Darawing the Sierpinski Triangle  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void draw_triangle(ct::Point a, ct::Point b, ct::Point c, ct::Color color, ct::Turtle& myTurtle){ myTurtle.fillcolor(color); myTurtle.penup(); myTurtle.goTo(a); myTurtle.pendown(); myTurtle.begin_fill(); myTurtle.goTo(c); myTurtle.goTo(b); myTurtle.goTo(a); myTurtle.end_fill(); } \/\/getMid already defined as \"middle\" function in C-Turtle namespace :) void sierpinski(ct::Point a, ct::Point b, ct::Point c, int degree, ct::Turtle& myTurtle){ const std::string colormap[] = {\"blue\", \"red\", \"green\", \"white\", \"yellow\", \"violet\", \"orange\"}; draw_triangle(a,b,c, {colormap[degree]}, myTurtle); if(degree > 0){ sierpinski(a, ct::middle(a, b), ct::middle(a, c), degree - 1, myTurtle); sierpinski(b, ct::middle(a, b), ct::middle(b, c), degree - 1, myTurtle); sierpinski(c, ct::middle(c, b), ct::middle(a, c), degree - 1, myTurtle); } } int main() { ct::TurtleScreen screen; screen.tracer(3);\/\/Draw faster. ct::Turtle turtle(screen); ct::Point myPoints[] = { {-100, -50}, {0, 100}, {100, -50} }; sierpinski(myPoints[0], myPoints[1], myPoints[2], 3, turtle); screen.bye(); return 0; }  Python Implementation #Recursive example of the Sierpinski Triangle. import turtle def drawTriangle(points,color,myTurtle): #Draws a triangle using the diven points and color. myTurtle.fillcolor(color) myTurtle.up() myTurtle.goto(points[0][0],points[0][1]) myTurtle.down() myTurtle.begin_fill() myTurtle.goto(points[1][0],points[1][1]) myTurtle.goto(points[2][0],points[2][1]) myTurtle.goto(points[0][0],points[0][1]) myTurtle.end_fill() def getMid(p1,p2): return ( (p1[0]+p2[0]) \/ 2, (p1[1] + p2[1]) \/ 2) def sierpinski(points,degree,myTurtle): colormap = ['blue','red','green','white','yellow', 'violet','orange'] drawTriangle(points,colormap[degree],myTurtle) if degree > 0: sierpinski([points[0], getMid(points[0], points[1]), getMid(points[0], points[2])], degree-1, myTurtle) #Recursive call sierpinski([points[1], getMid(points[0], points[1]), getMid(points[1], points[2])], degree-1, myTurtle) #Recursive call sierpinski([points[2], getMid(points[2], points[1]), getMid(points[0], points[2])], degree-1, myTurtle) #Recursive call def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() myPoints = [[-100,-50],[0,100],[100,-50]] sierpinski(myPoints,3,myTurtle) myWin.exitonclick() main()   The program in follows the ideas outlined above. The first thing sierpinski does is draw the outer triangle. Next, there are three recursive calls, one for each of the new corner triangles we get when we connect the midpoints. Once again we make use of the standard turtle module that comes with Python. You can learn all the details of the methods available in the turtle module by using help('turtle') from the Python prompt.  Look at the code and think about the order in which the triangles will be drawn. While the exact order of the corners depends upon how the initial set is specified, let's assume that the corners are ordered lower left, top, lower right. Because of the way the sierpinski function calls itself, sierpinski works its way to the smallest allowed triangle in the lower-left corner, and then begins to fill out the rest of the triangles working back. Then it fills in the triangles in the top corner by working toward the smallest, topmost triangle. Finally, it fills in the lower-right corner, working its way toward the smallest triangle in the lower right.  Sometimes it is helpful to think of a recursive algorithm in terms of a diagram of function calls. shows that the recursive calls are always made going to the left. The active functions are outlined in black, and the inactive function calls are in gray. The farther you go toward the bottom of , the smaller the triangles. The function finishes drawing one level at a time; once it is finished with the bottom left it moves to the bottom middle, and so on.   Building a Sierpinski Triangle.   Diagram showing the recursive construction of a Sierpinski Triangle using a tree structure. The diagram starts with a single top circle labeled 'top', branching out into three interconnected circles labeled 'left', 'top', and 'right'. Each of these circles further branches out in a similar pattern, with the process repeating for several iterations. The circles decrease in size from top to bottom, representing the fractal's recursive nature. The grayscale shading of the circles suggests depth or iteration levels.    The sierpinski function relies heavily on the middle function. middle takes as arguments two endpoints and returns the point halfway between them. In addition, has a function that draws a filled triangle using the begin_fill and end_fill turtle methods.  The above sierpinski triangle visualization utilizes C-Turtle, a C++ equivalent of Python's turtle library, and can be found on GitHub here: https:\/\/github.com\/walkerje\/C-Turtle\/  "
},
{
  "id": "fig-sierpinski",
  "level": "2",
  "url": "recursion_sierpinski-triangle.html#fig-sierpinski",
  "type": "Figure",
  "number": "5.8.1",
  "title": "",
  "body": " The Sierpinski Triangle.   Image of the Sierpinski Triangle, a fractal composed of colored triangles. The main triangle is outlined with progressively smaller triangles in alternating colors of red, green, and white, forming a pattern that repeats at smaller scales. The center of the triangle features a large inverted blue triangle, emphasizing the fractal's characteristic self-similarity.   "
},
{
  "id": "expl-lst-st-cpp",
  "level": "2",
  "url": "recursion_sierpinski-triangle.html#expl-lst-st-cpp",
  "type": "Exploration",
  "number": "5.8.1",
  "title": "Darawing the Sierpinski Triangle.",
  "body": " Darawing the Sierpinski Triangle  C++ Implementation #include <CTurtle.hpp> namespace ct = cturtle; void draw_triangle(ct::Point a, ct::Point b, ct::Point c, ct::Color color, ct::Turtle& myTurtle){ myTurtle.fillcolor(color); myTurtle.penup(); myTurtle.goTo(a); myTurtle.pendown(); myTurtle.begin_fill(); myTurtle.goTo(c); myTurtle.goTo(b); myTurtle.goTo(a); myTurtle.end_fill(); } \/\/getMid already defined as \"middle\" function in C-Turtle namespace :) void sierpinski(ct::Point a, ct::Point b, ct::Point c, int degree, ct::Turtle& myTurtle){ const std::string colormap[] = {\"blue\", \"red\", \"green\", \"white\", \"yellow\", \"violet\", \"orange\"}; draw_triangle(a,b,c, {colormap[degree]}, myTurtle); if(degree > 0){ sierpinski(a, ct::middle(a, b), ct::middle(a, c), degree - 1, myTurtle); sierpinski(b, ct::middle(a, b), ct::middle(b, c), degree - 1, myTurtle); sierpinski(c, ct::middle(c, b), ct::middle(a, c), degree - 1, myTurtle); } } int main() { ct::TurtleScreen screen; screen.tracer(3);\/\/Draw faster. ct::Turtle turtle(screen); ct::Point myPoints[] = { {-100, -50}, {0, 100}, {100, -50} }; sierpinski(myPoints[0], myPoints[1], myPoints[2], 3, turtle); screen.bye(); return 0; }  Python Implementation #Recursive example of the Sierpinski Triangle. import turtle def drawTriangle(points,color,myTurtle): #Draws a triangle using the diven points and color. myTurtle.fillcolor(color) myTurtle.up() myTurtle.goto(points[0][0],points[0][1]) myTurtle.down() myTurtle.begin_fill() myTurtle.goto(points[1][0],points[1][1]) myTurtle.goto(points[2][0],points[2][1]) myTurtle.goto(points[0][0],points[0][1]) myTurtle.end_fill() def getMid(p1,p2): return ( (p1[0]+p2[0]) \/ 2, (p1[1] + p2[1]) \/ 2) def sierpinski(points,degree,myTurtle): colormap = ['blue','red','green','white','yellow', 'violet','orange'] drawTriangle(points,colormap[degree],myTurtle) if degree > 0: sierpinski([points[0], getMid(points[0], points[1]), getMid(points[0], points[2])], degree-1, myTurtle) #Recursive call sierpinski([points[1], getMid(points[0], points[1]), getMid(points[1], points[2])], degree-1, myTurtle) #Recursive call sierpinski([points[2], getMid(points[2], points[1]), getMid(points[0], points[2])], degree-1, myTurtle) #Recursive call def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() myPoints = [[-100,-50],[0,100],[100,-50]] sierpinski(myPoints,3,myTurtle) myWin.exitonclick() main()  "
},
{
  "id": "fig-stcalltree",
  "level": "2",
  "url": "recursion_sierpinski-triangle.html#fig-stcalltree",
  "type": "Figure",
  "number": "5.8.2",
  "title": "",
  "body": " Building a Sierpinski Triangle.   Diagram showing the recursive construction of a Sierpinski Triangle using a tree structure. The diagram starts with a single top circle labeled 'top', branching out into three interconnected circles labeled 'left', 'top', and 'right'. Each of these circles further branches out in a similar pattern, with the process repeating for several iterations. The circles decrease in size from top to bottom, representing the fractal's recursive nature. The grayscale shading of the circles suggests depth or iteration levels.   "
},
{
  "id": "recursion_complex-recursive-problems",
  "level": "1",
  "url": "recursion_complex-recursive-problems.html",
  "type": "Section",
  "number": "5.9",
  "title": "Complex Recursive Problems",
  "body": " Complex Recursive Problems  In the previous sections we looked at some problems that are relatively easy to solve and some graphically interesting problems that can help us gain a mental model of what is happening in a recursive algorithm. In this section we will look at some problems that are really difficult to solve using an iterative programming style but are very elegant and easy to solve using recursion. We will finish up by looking at a deceptive problem that at first looks like it has an elegant recursive solution but in fact does not.  "
},
{
  "id": "recursion_tower-of-hanoi",
  "level": "1",
  "url": "recursion_tower-of-hanoi.html",
  "type": "Section",
  "number": "5.10",
  "title": "Tower of Hanoi",
  "body": " Tower of Hanoi  The Tower of Hanoi puzzle was invented by the French mathematician Edouard Lucas in 1883. He was inspired by a legend that tells of a Hindu temple where the puzzle was presented to young priests. At the beginning of time, the priests were given three poles and a stack of 64 gold disks, each disk a little smaller than the one beneath it. Their assignment was to transfer all 64 disks from one of the three poles to another, with two important constraints. They could only move one disk at a time, and they could never place a larger disk on top of a smaller one. The priests worked very efficiently, day and night, moving one disk every second. When they finished their work, the legend said, the temple would crumble into dust and the world would vanish.  Although the legend is interesting, you need not worry about the world ending any time soon. The number of moves required to correctly move a tower of 64 disks is . At a rate of one move per second, that is years! Clearly there is more to this puzzle than meets the eye.  shows an example of a configuration of disks in the middle of a move from the first peg to the third. Notice that, as the rules specify, the disks on each peg are stacked so that smaller disks are always on top of the larger disks. If you have not tried to solve this puzzle before, you should try it now. You do not need fancy disks and poles–a pile of books or pieces of paper will work.   An Example Arrangement of Disks for the Tower of Hanoi.   Image depicting the initial setup of the Tower of Hanoi puzzle. It shows three vertical poles labeled 'fromPole', 'withPole', and 'toPole' on a horizontal base. The 'fromPole' has three disks stacked on it, with the largest at the bottom and the smallest at the top, while the other two poles are empty. This is a classic configuration for the start of the puzzle, which involves moving the disks to another pole under certain rules.    How do we go about solving this problem recursively? How would you go about solving this problem at all? What is our base case? Let's think about this problem from the bottom up. Suppose you have a tower of five disks, originally on peg one. If you already knew how to move a tower of four disks to peg two, you could then easily move the bottom disk to peg three, and then move the tower of four from peg two to peg three. But what if you do not know how to move a tower of height four? Suppose that you knew how to move a tower of height three to peg three; then it would be easy to move the fourth disk to peg two and move the three from peg three on top of it. But what if you do not know how to move a tower of three? How about moving a tower of two disks to peg two and then moving the third disk to peg three, and then moving the tower of height two on top of it? But what if you still do not know how to do this? Surely you would agree that moving a single disk to peg three is easy enough, trivial you might even say. This sounds like a base case in the making.  Here is a high-level outline of how to move a tower from the starting pole, to the goal pole, using an intermediate pole:    Move a tower of height-1 to an intermediate pole, using the final pole.    Move the remaining disk to the final pole.    Move the tower of height-1 from the intermediate pole to the final pole using the original pole.    As long as we always obey the rule that the larger disks remain on the bottom of the stack, we can use the three steps above recursively, treating any larger disks as though they were not even there. The only thing missing from the outline above is the identification of a base case. The simplest Tower of Hanoi problem is a tower of one disk. In this case, we need move only a single disk to its final destination. A tower of one disk will be our base case. In addition, the steps outlined above move us toward the base case by reducing the height of the tower in steps 1 and 3. shows the Python code to solve the Tower of Hanoi puzzle.   moveTower Function  int moveTower(int height, char fromPole, char toPole, char withPole){ if (height >= 1){ moveTower(height-1, fromPole, withPole, toPole); moveDisk(fromPole, toPole); moveTower(height-1, withPole, toPole, fromPole); } }   Notice that the code in is almost identical to the English description. The key to the simplicity of the algorithm is that we make two different recursive calls, one on line 3 and a second on line 5. On line 3 we move all but the bottom disk on the initial tower to an intermediate pole. The next line simply moves the bottom disk to its final resting place. Then on line 5 we move the tower from the intermediate pole to the top of the largest disk. The base case is detected when the tower height is 0; in this case there is nothing to do, so the moveTower function simply returns. The important thing to remember about handling the base case this way is that simply returning from moveTower is what finally allows the moveDisk function to be called.  The function moveDisk , shown in , is very simple. All it does is print out that it is moving a disk from one pole to another. If you type in and run the moveTower program (in ) you can see that it gives you a very efficient solution to the puzzle.   Towers of Hanoi  C++ Implementation of moveDisk int moveDisk(char fp, char tp){ cout << \"moving disk from \" << fp << \" to \" << tp << endl; }  C++ Solution to Towers of Hanoi \/\/Simulation of the tower of hanoi. #include <iostream> using namespace std; void moveDisk(char fp, char tp){ cout << \"moving disk from \" << fp << \" to \" << tp << endl; } void moveTower(int height, char fromPole, char toPole, char withPole){ if (height >= 1){ moveTower(height-1, fromPole, withPole, toPole); \/\/Recursive call moveDisk(fromPole, toPole); moveTower(height-1, withPole, toPole, fromPole); \/\/Recursive call } } int main() { moveTower(3, 'A', 'B', 'C'); }  Python Solution to Towers of Hanoi #Simulation of the tower of hanoi. def moveTower(height,fromPole, toPole, withPole): if height >= 1: moveTower(height-1,fromPole,withPole,toPole) #Recursive call moveDisk(fromPole,toPole) moveTower(height-1,withPole,toPole,fromPole) #Recursive call def moveDisk(fp,tp): print(\"moving disk from\",fp,\"to\",tp) def main(): moveTower(3,\"A\",\"B\",\"C\") main()   Now that you have seen the code for both moveTower and moveDisk , you may be wondering why we do not have a data structure that explicitly keeps track of what disks are on what poles. Here is a hint: if you were going to explicitly keep track of the disks, you would probably use three Stack objects, one for each pole. The answer is that C++ provides the stacks that we need implicitly through the call stack.    If you change the tower height in Line 17 from 3 to 6, how many moves must you make to complete the Hanoi tower? (Hint, try implementing a counter to return the correct number.)     Correct, you can make a global counter at line 3, and then cout the increasing total under line 11.    Technically you are correct but, you are off by one.    Please try again you need to add a statement at line 3, and under line 11.     "
},
{
  "id": "fig-hanoicpp",
  "level": "2",
  "url": "recursion_tower-of-hanoi.html#fig-hanoicpp",
  "type": "Figure",
  "number": "5.10.1",
  "title": "",
  "body": " An Example Arrangement of Disks for the Tower of Hanoi.   Image depicting the initial setup of the Tower of Hanoi puzzle. It shows three vertical poles labeled 'fromPole', 'withPole', and 'toPole' on a horizontal base. The 'fromPole' has three disks stacked on it, with the largest at the bottom and the smallest at the top, while the other two poles are empty. This is a classic configuration for the start of the puzzle, which involves moving the disks to another pole under certain rules.   "
},
{
  "id": "lst-movetower",
  "level": "2",
  "url": "recursion_tower-of-hanoi.html#lst-movetower",
  "type": "Listing",
  "number": "5.10.2",
  "title": "",
  "body": " moveTower Function  int moveTower(int height, char fromPole, char toPole, char withPole){ if (height >= 1){ moveTower(height-1, fromPole, withPole, toPole); moveDisk(fromPole, toPole); moveTower(height-1, withPole, toPole, fromPole); } }  "
},
{
  "id": "expl-hanoi",
  "level": "2",
  "url": "recursion_tower-of-hanoi.html#expl-hanoi",
  "type": "Exploration",
  "number": "5.10.1",
  "title": "Towers of Hanoi.",
  "body": " Towers of Hanoi  C++ Implementation of moveDisk int moveDisk(char fp, char tp){ cout << \"moving disk from \" << fp << \" to \" << tp << endl; }  C++ Solution to Towers of Hanoi \/\/Simulation of the tower of hanoi. #include <iostream> using namespace std; void moveDisk(char fp, char tp){ cout << \"moving disk from \" << fp << \" to \" << tp << endl; } void moveTower(int height, char fromPole, char toPole, char withPole){ if (height >= 1){ moveTower(height-1, fromPole, withPole, toPole); \/\/Recursive call moveDisk(fromPole, toPole); moveTower(height-1, withPole, toPole, fromPole); \/\/Recursive call } } int main() { moveTower(3, 'A', 'B', 'C'); }  Python Solution to Towers of Hanoi #Simulation of the tower of hanoi. def moveTower(height,fromPole, toPole, withPole): if height >= 1: moveTower(height-1,fromPole,withPole,toPole) #Recursive call moveDisk(fromPole,toPole) moveTower(height-1,withPole,toPole,fromPole) #Recursive call def moveDisk(fp,tp): print(\"moving disk from\",fp,\"to\",tp) def main(): moveTower(3,\"A\",\"B\",\"C\") main()  "
},
{
  "id": "ex-hanoi",
  "level": "2",
  "url": "recursion_tower-of-hanoi.html#ex-hanoi",
  "type": "Reading Question",
  "number": "5.10.1",
  "title": "",
  "body": " If you change the tower height in Line 17 from 3 to 6, how many moves must you make to complete the Hanoi tower? (Hint, try implementing a counter to return the correct number.)     Correct, you can make a global counter at line 3, and then cout the increasing total under line 11.    Technically you are correct but, you are off by one.    Please try again you need to add a statement at line 3, and under line 11.   "
},
{
  "id": "recursion_exploring-a-maze",
  "level": "1",
  "url": "recursion_exploring-a-maze.html",
  "type": "Section",
  "number": "5.11",
  "title": "Exploring a Maze",
  "body": " Exploring a Maze  In this section we will look at a problem that has relevance to the expanding world of robotics: How do you find your way out of a maze? If you have a Roomba vacuum cleaner for your dorm room (don't all college students?) you will wish that you could reprogram it using what you have learned in this section. The problem we want to solve is to find an exit to a virtual maze when starting at a pre-defined location. The maze problem has roots as deep as the Greek myth about Theseus who was sent into a maze to kill the minotaur. Theseus used a ball of thread to help him find his way back out again once he had finished off the beast. In our problem we will assume that our starting position is dropped down somewhere into the middle of the maze, a fair distance from any exit. Look at to get an idea of where we are going in this section.   Exploring the maze.    To make it easier for us we will assume that our maze is divided up into squares. Each square of the maze is either open or occupied by a section of wall. We can only pass through the open squares of the maze. If we bump into a wall, we must try a different direction. We will require a systematic procedure to find our way out of the maze. Here is the procedure:    From our starting position we will first try going North one square and then recursively try our procedure from there.    If we are not successful by trying a Northern path as the first step then we will take a step to the South and recursively repeat our procedure.    If South does not work then we will try a step to the West as our first step and recursively apply our procedure.    If North, South, and West have not been successful then apply the procedure recursively from a position one step to our East.    If none of these directions works then there is no way to get out of the maze and we fail.    Now, that sounds pretty easy, but there are a couple of details to talk about first. Suppose we take our first recursive step by going North. By following our procedure our next step would also be to the North. But if the North is blocked by a wall we must look at the next step of the procedure and try going to the South. Unfortunately that step to the south brings us right back to our original starting place. If we apply the recursive procedure from there we will just go back one step to the North and be in an infinite loop. So, we must have a strategy to remember where we have been. In this case we will assume that we have a bag of bread crumbs we can drop along our way. If we take a step in a certain direction and find that there is a bread crumb already on that square, we know that we should immediately back up and try the next direction in our procedure. As we will see when we look at the code for this algorithm, backing up is as simple as returning from a recursive function call.  As we do for all recursive algorithms let us review the base cases. Some of them you may already have guessed based on the description in the previous paragraph. In this algorithm, there are four base cases to consider:    We have run into a wall. Since the square is occupied by a wall no further exploration can take place.    We have found a square that has already been explored. We do not want to continue exploring from this position or we will get into a loop.    We have found an outside edge, not occupied by a wall. In other words we have found an exit from the maze.    We have explored a square unsuccessfully in all four directions.    For our program to work we will need to have a way to represent the maze. In this instance, we will stick to a text-only representation (ASCII).    __init__ Initializes basic variables to default values, and calls readMazeFile .    readMazeFile Reads the text of the maze text file, and calls findStartPosition .    findStartPosition Finds the row and column of the starting position.    isOnEdge Checks to see if the current position is on the edge, and therefore an exit.    print Prints the text of the maze to the screen.    The Maze class also overloads the index operator [] so that our algorithm can easily access the status of any particular square.  Let's examine the code for the search function which we call searchFrom . The code is shown in . Notice that this function takes three parameters: a maze object, the starting row, and the starting column. This is important because as a recursive function the search logically starts again with each recursive call.   searchFrom Function  def searchFrom(maze, startRow, startColumn): # Check for base cases (Steps 1, 2, and 3): # 1. We have run into an obstacle, return false if maze[startRow][startColumn] == MAZE_OBSTACLE: return False # 2. We have found a square that has already been explored if maze[startRow][startColumn] == MAZE_TRIED: return False # 3. Success, an outside edge not occupied by an obstacle if maze.isOnEdge(startRow, startColumn): maze[startRow][startColumn] = MAZE_PATH return True # 4. Indicate that the currently visited space has been tried. # Refer to step two. maze[startRow][startColumn] = MAZE_TRIED # 5. Otherwise, check each cardinal direction (North, south, east, and west). # We are checking one space in each direction, thus the plus or minus one below. found = searchFrom(maze, startRow - 1, startColumn) or \\ searchFrom(maze, startRow + 1, startColumn) or \\ searchFrom(maze, startRow, startColumn - 1) or \\ searchFrom(maze, startRow, startColumn + 1) # 6. Mark the location as either part of the path or a dead end, # depending on whether or not an exit has been found. if found: maze[startRow][startColumn] = MAZE_PATH else: maze[startRow][startColumn] = MAZE_DEAD_END return found   As you look through the algorithm you will see that the first thing the code does (steps 1 and 2) is determine if the space should be visited . This is done by checking if the spot is an obstacle ( MAZE_OBSTACLE ), or has already been visited ( MAZE_TRIED ). The algorithm then determines if it has found an exit (step 3). If none of these cases are true, it continues the search recursively.  You will notice that in the recursive step there are four recursive calls to searchFrom . It is hard to predict how many of these recursive calls will be used since they are all connected by or statements. If the first call to searchFrom returns True then none of the last three calls would be needed. You can interpret this as meaning that a step to (row-1,column) (or North if you want to think geographically) is on the path leading out of the maze. If there is not a good path leading out of the maze to the North then the next recursive call is tried, this one to the South. If South fails then try West, and finally East. If all four recursive calls return false then we have found a dead end. You should download or type in the whole program and experiment with it by changing the order of these calls.  The code for the Maze class is shown in and . The __init__ method takes the name of a file as its only parameter. This file is a text file that represents a maze by using + characters for walls, spaces for open squares, and the letter S to indicate the starting position. is an example of a maze data file. The internal representation of the maze is a list of lists. Each row of the mazeList instance variable is also a list. This secondary list contains one character per square using the characters described above. For the data file in the internal representation looks like the following:   Example Maze  [['+','+','+','+',...,'+','+','+','+','+','+','+'], ['+',' ',' ',' ',...,' ',' ',' ','+',' ',' ',' '], ['+',' ','+',' ',...,'+','+',' ','+',' ','+','+'], ['+',' ','+',' ',...,' ',' ',' ','+',' ','+','+'], ['+','+','+',' ',...,'+','+',' ','+',' ',' ','+'], ['+',' ',' ',' ',...,'+','+',' ',' ',' ',' ','+'], ['+','+','+','+',...,'+','+','+','+','+',' ','+'], ['+',' ',' ',' ',...,'+','+',' ',' ','+',' ','+'], ['+',' ','+','+',...,' ',' ','+',' ',' ',' ','+'], ['+',' ',' ',' ',...,' ',' ','+',' ','+','+','+'], ['+','+','+','+',...,'+','+','+',' ','+','+','+']]   The searchFrom method uses this internal representation to traverse throughout the maze.   Example Maze File  Some data about this data  ++++++++++++++++++++++ + + ++ ++ + + + + +++ + ++ + + + ++ ++++ + ++ +++ ++++++ +++ + + + ++ ++ + +++++ ++++++ +++++ + + + +++++++ + + + +++++++ S + + + + +++ ++++++++++++++++++ +++   Finally, the isOnEdge method uses our current position to test for an exit condition. An exit condition occurs whenever we have navigated to the edge of the maze, either row zero or column zero, or the far right column or the bottom row.   Maze Class  MAZE_OBSTACLE = '+' MAZE_START = 'S' MAZE_PATH = 'O' MAZE_DEAD_END = '-' MAZE_TRIED = '.' class Maze: def __init__(self, mazeFileName): # Initialize all of our default variables. self.mazeList = [] self.totalRows = 0 self.totalColumns = 0 self.startRow = 0 self.startColumn = 0 # And read the maze file. self.readMazeFile(mazeFileName) def readMazeFile(self, mazeFileName): # The maze list is a list of strings. # Components of the maze are indicated by specific characters. # These characters are listed at the top of the file. # The line below says the following: # For every line of text in our maze text file, add every single character to a list. # The final result is a list of lists, where each element is a single character. self.mazeList = [[char for char in line] for line in open(mazeFileName).read().split(\"\\n\")] # The total number of rows is the total number of strings in the list. self.totalRows = len(self.mazeList) # The total number of columns is the length of a single line. # We can assume all lines of text for the maze are the same length. self.totalColumns = len(self.mazeList[0]) # Lastly, find the start position. self.findStartPosition() def findStartPosition(self): # Iterate through every individual character in the maze list. # If we come across the MAZE_START character ('S'), # we save the row and column of where it was found, and stop looking. # enumerate(...) is very much like using a typical list, # except it gives you two pieces of information instead of one. # It assumes the format of (index_of_item, item). for (row, text) in enumerate(self.mazeList): for(column, component) in enumerate(text): if component == MAZE_START: self.startRow = row self.startColumn = column return def isOnEdge(self, row, column): return (row == 0 or row == self.totalRows - 1 or column == 0 or column == self.totalColumns - 1) # This allows us to use the Maze class like a list, e.g, maze[index] def __getitem__(self, index): return self.mazeList[index]  The complete program is shown in . This program uses the data file maze1.txt shown above. Feel free to also attempt to use maze2.txt from up above. Note that it is a much more simple example file in that the exit is very close to the starting position.     Complete Maze Code  MAZE_OBSTACLE = '+' MAZE_START = 'S' MAZE_PATH = 'O' MAZE_DEAD_END = '-' MAZE_TRIED = '.' class Maze: def __init__(self, mazeFileName): # Initialize all of our default variables. self.mazeList = [] self.totalRows = 0 self.totalColumns = 0 self.startRow = 0 self.startColumn = 0 # And read the maze file. self.readMazeFile(mazeFileName) def readMazeFile(self, mazeFileName): # The maze list is a list of strings. # Components of the maze are indicated by specific characters. # These characters are listed at the top of the file. # The line below says the following: # For every line of text in our maze text file, add every single character to a list. # The final result is a list of lists, where each element is a single character. self.mazeList = [[char for char in line] for line in open(mazeFileName).read().split(\"\\n\")] # The total number of rows is the total number of strings in the list. self.totalRows = len(self.mazeList) # The total number of columns is the length of a single line. # We can assume all lines of text for the maze are the same length. self.totalColumns = len(self.mazeList[0]) # Lastly, find the start position. self.findStartPosition() def findStartPosition(self): # Iterate through every individual character in the maze list. # If we come across the MAZE_START character ('S'), # we save the row and column of where it was found, and stop looking. # enumerate(...) is very much like using a typical list, # except it gives you two pieces of information instead of one. # It assumes the format of (index_of_item, item). for (row, text) in enumerate(self.mazeList): for(column, component) in enumerate(text): if component == MAZE_START: self.startRow = row self.startColumn = column return def isOnEdge(self, row, column): return (row == 0 or row == self.totalRows - 1 or column == 0 or column == self.totalColumns - 1) def print(self): for row in self.mazeList: # \"join\" every character in the row into a single string. rowText = \"\".join(row) print(rowText) # This allows us to use the Maze class like a list, e.g, maze[index] def __getitem__(self, index): return self.mazeList[index] def searchFrom(maze, startRow, startColumn): # Check for base cases: # 1. We have run into an obstacle, return false if maze[startRow][startColumn] == MAZE_OBSTACLE: return False # 2. We have found a square that has already been explored if maze[startRow][startColumn] == MAZE_TRIED: return False # 3. Success, an outside edge not occupied by an obstacle if maze.isOnEdge(startRow, startColumn): maze[startRow][startColumn] = MAZE_PATH return True maze[startRow][startColumn] = MAZE_TRIED # Otherwise, check each cardinal direction (North, south, east, and west). # We are checking one space in each direction, thus the plus or minus one below. found = searchFrom(maze, startRow - 1, startColumn) or \\ searchFrom(maze, startRow + 1, startColumn) or \\ searchFrom(maze, startRow, startColumn - 1) or \\ searchFrom(maze, startRow, startColumn + 1) if found: maze[startRow][startColumn] = MAZE_PATH else: maze[startRow][startColumn] = MAZE_DEAD_END return found def main(): maze = Maze(\"maze1.txt\") print(\"Before:\") maze.print() searchFrom(maze, maze.startRow, maze.startColumn) print(\"After:\") maze.print() main()   Self Check  Now that you're familiar with this simple maze exploring algorithm, use what you've learned about file handling, classes, and IO to implement this in C++! To visualize the exploration, print out the characters using cout to create an ASCII representation of your cave. For example, your program should be able to read and operate from a file formatted as follows: You can also use CTurtle to visualize the traversal throughout the maze.   7 5 +++++++ + + S+ + + + ++ +++++++  "
},
{
  "id": "recursion-fig-maze",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#recursion-fig-maze",
  "type": "Figure",
  "number": "5.11.1",
  "title": "",
  "body": " Exploring the maze.   "
},
{
  "id": "lst-mazesearch",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#lst-mazesearch",
  "type": "Listing",
  "number": "5.11.2",
  "title": "",
  "body": " searchFrom Function  def searchFrom(maze, startRow, startColumn): # Check for base cases (Steps 1, 2, and 3): # 1. We have run into an obstacle, return false if maze[startRow][startColumn] == MAZE_OBSTACLE: return False # 2. We have found a square that has already been explored if maze[startRow][startColumn] == MAZE_TRIED: return False # 3. Success, an outside edge not occupied by an obstacle if maze.isOnEdge(startRow, startColumn): maze[startRow][startColumn] = MAZE_PATH return True # 4. Indicate that the currently visited space has been tried. # Refer to step two. maze[startRow][startColumn] = MAZE_TRIED # 5. Otherwise, check each cardinal direction (North, south, east, and west). # We are checking one space in each direction, thus the plus or minus one below. found = searchFrom(maze, startRow - 1, startColumn) or \\ searchFrom(maze, startRow + 1, startColumn) or \\ searchFrom(maze, startRow, startColumn - 1) or \\ searchFrom(maze, startRow, startColumn + 1) # 6. Mark the location as either part of the path or a dead end, # depending on whether or not an exit has been found. if found: maze[startRow][startColumn] = MAZE_PATH else: maze[startRow][startColumn] = MAZE_DEAD_END return found  "
},
{
  "id": "lst-exmaze",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#lst-exmaze",
  "type": "Listing",
  "number": "5.11.3",
  "title": "",
  "body": " Example Maze  [['+','+','+','+',...,'+','+','+','+','+','+','+'], ['+',' ',' ',' ',...,' ',' ',' ','+',' ',' ',' '], ['+',' ','+',' ',...,'+','+',' ','+',' ','+','+'], ['+',' ','+',' ',...,' ',' ',' ','+',' ','+','+'], ['+','+','+',' ',...,'+','+',' ','+',' ',' ','+'], ['+',' ',' ',' ',...,'+','+',' ',' ',' ',' ','+'], ['+','+','+','+',...,'+','+','+','+','+',' ','+'], ['+',' ',' ',' ',...,'+','+',' ',' ','+',' ','+'], ['+',' ','+','+',...,' ',' ','+',' ',' ',' ','+'], ['+',' ',' ',' ',...,' ',' ','+',' ','+','+','+'], ['+','+','+','+',...,'+','+','+',' ','+','+','+']]  "
},
{
  "id": "fig-exmaze",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#fig-exmaze",
  "type": "Data",
  "number": "5.11.4",
  "title": "Example Maze File.",
  "body": " Example Maze File  Some data about this data  ++++++++++++++++++++++ + + ++ ++ + + + + +++ + ++ + + + ++ ++++ + ++ +++ ++++++ +++ + + + ++ ++ + +++++ ++++++ +++++ + + + +++++++ + + + +++++++ S + + + + +++ ++++++++++++++++++ +++  "
},
{
  "id": "lst-maze",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#lst-maze",
  "type": "Listing",
  "number": "5.11.5",
  "title": "",
  "body": " Maze Class  MAZE_OBSTACLE = '+' MAZE_START = 'S' MAZE_PATH = 'O' MAZE_DEAD_END = '-' MAZE_TRIED = '.' class Maze: def __init__(self, mazeFileName): # Initialize all of our default variables. self.mazeList = [] self.totalRows = 0 self.totalColumns = 0 self.startRow = 0 self.startColumn = 0 # And read the maze file. self.readMazeFile(mazeFileName) def readMazeFile(self, mazeFileName): # The maze list is a list of strings. # Components of the maze are indicated by specific characters. # These characters are listed at the top of the file. # The line below says the following: # For every line of text in our maze text file, add every single character to a list. # The final result is a list of lists, where each element is a single character. self.mazeList = [[char for char in line] for line in open(mazeFileName).read().split(\"\\n\")] # The total number of rows is the total number of strings in the list. self.totalRows = len(self.mazeList) # The total number of columns is the length of a single line. # We can assume all lines of text for the maze are the same length. self.totalColumns = len(self.mazeList[0]) # Lastly, find the start position. self.findStartPosition() def findStartPosition(self): # Iterate through every individual character in the maze list. # If we come across the MAZE_START character ('S'), # we save the row and column of where it was found, and stop looking. # enumerate(...) is very much like using a typical list, # except it gives you two pieces of information instead of one. # It assumes the format of (index_of_item, item). for (row, text) in enumerate(self.mazeList): for(column, component) in enumerate(text): if component == MAZE_START: self.startRow = row self.startColumn = column return def isOnEdge(self, row, column): return (row == 0 or row == self.totalRows - 1 or column == 0 or column == self.totalColumns - 1) # This allows us to use the Maze class like a list, e.g, maze[index] def __getitem__(self, index): return self.mazeList[index] "
},
{
  "id": "completemaze",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#completemaze",
  "type": "Listing",
  "number": "5.11.6",
  "title": "",
  "body": " Complete Maze Code  MAZE_OBSTACLE = '+' MAZE_START = 'S' MAZE_PATH = 'O' MAZE_DEAD_END = '-' MAZE_TRIED = '.' class Maze: def __init__(self, mazeFileName): # Initialize all of our default variables. self.mazeList = [] self.totalRows = 0 self.totalColumns = 0 self.startRow = 0 self.startColumn = 0 # And read the maze file. self.readMazeFile(mazeFileName) def readMazeFile(self, mazeFileName): # The maze list is a list of strings. # Components of the maze are indicated by specific characters. # These characters are listed at the top of the file. # The line below says the following: # For every line of text in our maze text file, add every single character to a list. # The final result is a list of lists, where each element is a single character. self.mazeList = [[char for char in line] for line in open(mazeFileName).read().split(\"\\n\")] # The total number of rows is the total number of strings in the list. self.totalRows = len(self.mazeList) # The total number of columns is the length of a single line. # We can assume all lines of text for the maze are the same length. self.totalColumns = len(self.mazeList[0]) # Lastly, find the start position. self.findStartPosition() def findStartPosition(self): # Iterate through every individual character in the maze list. # If we come across the MAZE_START character ('S'), # we save the row and column of where it was found, and stop looking. # enumerate(...) is very much like using a typical list, # except it gives you two pieces of information instead of one. # It assumes the format of (index_of_item, item). for (row, text) in enumerate(self.mazeList): for(column, component) in enumerate(text): if component == MAZE_START: self.startRow = row self.startColumn = column return def isOnEdge(self, row, column): return (row == 0 or row == self.totalRows - 1 or column == 0 or column == self.totalColumns - 1) def print(self): for row in self.mazeList: # \"join\" every character in the row into a single string. rowText = \"\".join(row) print(rowText) # This allows us to use the Maze class like a list, e.g, maze[index] def __getitem__(self, index): return self.mazeList[index] def searchFrom(maze, startRow, startColumn): # Check for base cases: # 1. We have run into an obstacle, return false if maze[startRow][startColumn] == MAZE_OBSTACLE: return False # 2. We have found a square that has already been explored if maze[startRow][startColumn] == MAZE_TRIED: return False # 3. Success, an outside edge not occupied by an obstacle if maze.isOnEdge(startRow, startColumn): maze[startRow][startColumn] = MAZE_PATH return True maze[startRow][startColumn] = MAZE_TRIED # Otherwise, check each cardinal direction (North, south, east, and west). # We are checking one space in each direction, thus the plus or minus one below. found = searchFrom(maze, startRow - 1, startColumn) or \\ searchFrom(maze, startRow + 1, startColumn) or \\ searchFrom(maze, startRow, startColumn - 1) or \\ searchFrom(maze, startRow, startColumn + 1) if found: maze[startRow][startColumn] = MAZE_PATH else: maze[startRow][startColumn] = MAZE_DEAD_END return found def main(): maze = Maze(\"maze1.txt\") print(\"Before:\") maze.print() searchFrom(maze, maze.startRow, maze.startColumn) print(\"After:\") maze.print() main() "
},
{
  "id": "recursion_exploring-a-maze-25",
  "level": "2",
  "url": "recursion_exploring-a-maze.html#recursion_exploring-a-maze-25",
  "type": "Note",
  "number": "5.11.7",
  "title": "Self Check.",
  "body": " Self Check  Now that you're familiar with this simple maze exploring algorithm, use what you've learned about file handling, classes, and IO to implement this in C++! To visualize the exploration, print out the characters using cout to create an ASCII representation of your cave. For example, your program should be able to read and operate from a file formatted as follows: You can also use CTurtle to visualize the traversal throughout the maze.  "
},
{
  "id": "recursion_dynamic-programming",
  "level": "1",
  "url": "recursion_dynamic-programming.html",
  "type": "Section",
  "number": "5.12",
  "title": "Dynamic Programming",
  "body": " Dynamic Programming   dynamic programming  Dynamic programming is a technique of breaking the main problem into smaller subproblems and then using those subproblems to construct the answer to the main problem.  Many programs in computer science are written to optimize some value; for example, find the shortest path between two points, find the line that best fits a set of points, or find the smallest set of objects that satisfies some criteria. There are many strategies that computer scientists use to solve these problems. One of the goals of this book is to expose you to several different problem solving strategies. Dynamic programming is one strategy for these types of optimization problems.  A classic example of an optimization problem involves making change using the fewest coins. Suppose you are a programmer for a vending machine manufacturer. Your company wants to streamline effort by giving out the fewest possible coins in change for each transaction. Suppose a customer puts in a dollar bill and purchases an item for 37 cents. What is the smallest number of coins you can use to make change? The answer is six coins: two quarters, one dime, and three pennies. How did we arrive at the answer of six coins? We start with the largest coin in our arsenal (a quarter) and use as many of those as possible, then we go to the next lowest coin value and use as many of those as possible. This first approach is called a greedy method because we try to solve as big a piece of the problem as possible right away.  The greedy method works fine when we are using U.S. coins, but suppose that your company decides to deploy its vending machines in Lower Elbonia where, in addition to the usual 1, 5, 10, and 25 cent coins they also have a 21 cent coin. In this instance our greedy method fails to find the optimal solution for 63 cents in change. With the addition of the 21 cent coin the greedy method would still find the solution to be six coins. However, the optimal answer is three 21 cent pieces.  Let's look at a method where we could be sure that we would find the optimal answer to the problem. Since this section is about recursion, you may have guessed that we will use a recursive solution. Let's start with identifying the base case. If we are trying to make change for the same amount as the value of one of our coins, the answer is easy, one coin.  If the amount does not match we have several options. What we want is the minimum of a penny plus the number of coins needed to make change for the original amount minus a penny, or a nickel plus the number of coins needed to make change for the original amount minus five cents, or a dime plus the number of coins needed to make change for the original amount minus ten cents, and so on. So the number of coins needed to make change for the original amount can be computed according to the following:   The algorithm for doing what we have just described is shown in . In line 7 we are checking our base case; that is, we are trying to make change in the exact amount of one of our coins. If we do not have a coin equal to the amount of change, we make recursive calls for each different coin value less than the amount of change we are trying to make. Line 6 shows how we filter the list of coins to those less than the current value of change using a list comprehension. The recursive call also reduces the total amount of change we need to make by the value of the coin selected. The recursive call is made in line 14. Notice that on that same line we add 1 to our number of coins to account for the fact that we are using a coin. Just adding 1 is the same as if we had made a recursive call asking where we satisfy the base case condition immediately.   Recursive Change Calculator  C++ Implementation \/\/Recursive example of trying to get the least amount of coins to make up an amount of change. #include <iostream> #include <vector> #include <algorithm> using namespace std; int recMC_greedy(vector<int> coinValueList, int change){ if (change == 0){ \/\/base case if, change is 0, then the number of coins have been finalized return 0; } else{ int cur_max =* max_element(coinValueList.begin(), coinValueList.end());\/\/use the maximum in the list to see how many of these can be used to form the sum int count=int(change\/cur_max); \/\/find how many of the max is needed to make the change so that the number of coins used is minimum coinValueList.erase(std::remove(coinValueList.begin(), coinValueList.end(), cur_max), coinValueList.end()); \/\/erasing the current max so that a different max can be \/\/used in next recursion and continue the greedy process return count + recMC_greedy(coinValueList, change-cur_max * count); \/\/returns the counts of the coins using recursion } } int main() { int arr2[] = {1, 5, 10, 21, 25}; vector<int> coinValueList(arr2, arr2 + (sizeof(arr2)\/ sizeof(arr2[0]))); \/\/Initializing vector cout<<recMC_greedy(coinValueList, 63)<<endl; \/\/using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21 return 0; \/\/but greedy algorithm gives 6 coins which is not the most optimum solution }  Python Implementation #Recursive example of trying to get the least amount of coins to make up an amount of change. def recMC_greedy(coinValueList,change): if change == 0: #base case if, change is 0, then the number of coins have been finalized return 0 else: cur_max = max(coinValueList) #use the maximum in the list to see how many of these can be used to form the sum count = change\/\/cur_max #find how many of the max is needed to make the change so that the number of coins used is minimum index = coinValueList.index(cur_max) del coinValueList[index] #erasing the current max so that a different max can be #used in next recursion and continue the greedy process return count + recMC_greedy(coinValueList, change-cur_max * count) #returns the counts of the coins using recursion def main(): print(recMC_greedy([1, 5, 10, 21, 25], 63)) #using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21 #but greedy algorithm gives 6 coins which is not the most optimum solution main()   The trouble with the algorithm in is that it is extremely inefficient. In fact, it takes 67,716,925 recursive calls to find the optimal solution to the 4 coins, 63 cents problem! To understand the fatal flaw in our approach look at , which illustrates a small fraction of the 377 function calls needed to find the optimal set of coins to make change for 26 cents.  Each node in the graph corresponds to a call to recMC . The label on the node indicates the amount of change for which we are computing the number of coins. The label on the arrow indicates the coin that we just used. By following the graph we can see the combination of coins that got us to any point in the graph. The main problem is that we are re-doing too many calculations. For example, the graph shows that the algorithm would recalculate the optimal number of coins to make change for 15 cents at least three times. Each of these computations to find the optimal number of coins for 15 cents itself takes 52 function calls. Clearly we are wasting a lot of time and effort recalculating old results.   Call Tree for   Diagram of a call tree for a recursive process, as seen in . The tree starts at the top with the root node labeled '26', branching down to nodes labeled '25' and '1'. Each node further branches out, with the left branch subtracting '1' and the right branch subtracting '5'. The pattern continues until reaching the leaf nodes, which are either '1' or a number that can no longer be reduced by five. Arrows indicate the direction of the call flow, starting from '26' and moving down through the levels of the tree.    The key to cutting down on the amount of work we do is to remember some of the past results so we can avoid recomputing results we already know. A simple solution is to store the results for the minimum number of coins in a table when we find them. Then before we compute a new minimum, we first check the table to see if a result is already known. If there is already a result in the table, we use the value from the table rather than recomputing. This technique is called memorization memoization and is a very useful method for speeding up frequent yet hardware-demanding function calls. shows a modified algorithm to incorporate our table lookup scheme.   Change Calculation With Memoization  C++ Implementation \/\/A different attempt at making the change algorithm. #include <iostream> #include <vector> using namespace std; int recDC(vector<int> coinValueList, int change, int knownResults[]){ int minCoins, numCoins; minCoins = change; for (unsigned int i = 0; i< coinValueList.size(); i++){ \/\/this loop contains the base case, \/\/as it returns items that are not \/\/returning a call to the recDC function. if (coinValueList[i] == change){ knownResults[change] = 1; return 1; } else if(knownResults[change] > 0){ return knownResults[change]; } } for (unsigned int y=0; y<coinValueList.size(); y++){ if (coinValueList[y] <= change){ numCoins = 1 + recDC(coinValueList, change - coinValueList[y], knownResults); \/\/Recursive call if (numCoins < minCoins){ minCoins = numCoins; knownResults[change] = minCoins; } } } return minCoins; } int main(){ vector<int> coinValueList = {1, 5, 10, 21, 25}; int change = 63; int knownResults[64] = {0}; cout<<recDC(coinValueList, change, knownResults)<<endl; return 0; }  Python Implementation #A different attempt at making the change algorithm. def recDC(coinValueList, change, knownResults): minCoins = change if change in coinValueList: #base case knownResults[change] = 1 return 1 elif knownResults[change] > 0: #base case return knownResults[change] else: for i in [c for c in coinValueList if c <= change]: numCoins = 1 + recDC(coinValueList, change - i, knownResults) #Recursive call. if numCoins < minCoins: minCoins = numCoins knownResults[change] = minCoins return minCoins def main(): print(recDC([1, 5, 10, 21, 25], 63, [0]*64)) main()   Notice that in line 15 we have added a test to see if our table contains the minimum number of coins for a certain amount of change. If it does not, we compute the minimum recursively and store the computed minimum in the table. Using this modified algorithm reduces the number of recursive calls we need to make for the four coin, 63 cent problem to 221 calls!  Although the algorithm in is correct, it looks and feels like a bit of a hack. Also, if we look at the knownResults lists we can see that there are some holes in the table. In fact the term for what we have done is not dynamic programming but rather we have improved the performance of our program by using a technique known as memoization, or more commonly called caching. Memoization uses what is sometimes called an opportunistic top-down approach. When you need the result of a computation, you check to see if you have already computed it, otherwise you do the new calculation and store the result.  A truly dynamic programming algorithm will take a more systematic bottom-up approach to the problem. Memoization and dynamic programming are both code optimization techniques that avoid recalculating duplicate work. Our dynamic programming solution is going to start with making change for one cent and systematically work its way up to the amount of change we require. This guarantees us that at each step of the algorithm we already know the minimum number of coins needed to make change for any smaller amount.  This is often called dynamic programming with tabulation. Let's look at how we would fill in a table of minimum coins to use in making change for 11 cents. illustrates the process. We start with one cent. The only solution possible is one coin (a penny). The next row shows the minimum for one cent and two cents. Again, the only solution is two pennies. The fifth row is where things get interesting. Now we have two options to consider, five pennies or one nickel. How do we decide which is best? We consult the table and see that the number of coins needed to make change for four cents is four, plus one more penny to make five, equals five coins. Or we can look at zero cents plus one more nickel to make five cents equals 1 coin. Since the minimum of one and five is one we store 1 in the table. Fast forward again to the end of the table and consider 11 cents. shows the three options that we have to consider:    A penny plus the minimum number of coins to make change for cents (1)    A nickel plus the minimum number of coins to make change for cents (2)    A dime plus the minimum number of coins to make change for cent (1)    Either option 1 or 3 will give us a total of two coins which is the minimum number of coins for 11 cents.   Minimum Number of Coins Needed to Make.   Image of a table representing the minimum number of coins needed to make change. The columns are labeled with the 'Change to Make' values from 1 to 11. The rows correspond to 'Steps of the Algorithm', with each cell filled with the minimum number of coins needed at that step for the corresponding amount of change. Initial rows are partially filled with increasing sequences of numbers, indicating the progression of the algorithm. The bottom rows are blurred and continue with an ellipsis, suggesting the continuation of the process beyond what is shown.     Three Options to Consider for the Minimum Number of Coins for Eleven Cents.   Image of a curved numerical table representing three options to calculate the minimum number of coins for eleven cents. The table is labeled with numbers from 1 to 5 corresponding to the counts of coins used. Below the table, there are three curved arrows pointing to the number '11' from '11-1', '11-5', and '11-10', indicating the subtraction of 1, 5, and 10 cents from 11 cents to determine the next step in the calculation. The last cell under '11' is labeled with '??' to indicate the unknown minimum number of coins needed.    is a dynamic programming algorithm to solve our change-making problem. dpMakeChange takes three parameters: a list of valid coin values, the amount of change we want to make, and a list of the minimum number of coins needed to make each value. When the function is done minCoins will contain the solution for all values from 0 to the value of change .   Change Calculator Using Dynamic Programming  C++ Implementation \/\/Program that stores the solution for all possible amounts of change up to a given integer. #include <iostream> #include <vector> using namespace std; int dpMakeChange(vector<int> coinValueList, int change, vector<int> minCoins){ for (int cents = 0 ; cents < change + 1; cents++){ \/\/loop finds solution for all sets of change from 0 to int change. int coinCount = cents; for (int j : coinValueList){ if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins that is used to make the change. } } } minCoins[cents] = coinCount; } return minCoins[change]; } int main(){ vector<int> coinValueList = {1, 5, 10, 21, 25}; int change = 63; vector<int> minCoins(64, 0); cout << dpMakeChange(coinValueList, change, minCoins) << endl; return 0; }  Python Implementation #Program that stores the solution for all possible amounts of change up to a given integer. def dpMakeChange(coinValueList,change,minCoins): for cents in range(change+1): #loops finds solution for all sets of change from 0 to change parameter. coinCount = cents for j in [c for c in coinValueList if c <= cents]: if minCoins[cents-j] + 1 < coinCount: coinCount = minCoins[cents-j] + 1 #assigns the number of coins that will be used to make the sum. minCoins[cents] = coinCount return minCoins[change] def main(): print(dpMakeChange([1, 5, 10, 21, 25], 63, [0]*64)) main()   Note that dpMakeChange is not a recursive function, even though we started with a recursive solution to this problem. It is important to realize that just because you can write a recursive solution to a problem does not mean it is the best or most efficient solution. The bulk of the work in this function is done by the loop that starts on line 4. In this loop we consider using all possible coins to make change for the amount specified by cents . Like we did for the 11 cent example above, we remember the minimum value and store it in our minCoins list.  Although our making change algorithm does a good job of figuring out the minimum number of coins, it does not help us make change since we do not keep track of the coins we use. We can easily extend dpMakeChange to keep track of the coins used by simply remembering the last coin we add for each entry in the minCoins table. If we know the last coin added, we can simply subtract the value of the coin to find a previous entry in the table that tells us the last coin we added to make that amount. We can keep tracing back through the table until we get to the beginning.  shows the dpMakeChange algorithm modified to keep track of the coins used, along with a function printCoins that walks backward through the table to print out the value of each coin used. This shows the algorithm in action solving the problem for our friends in Lower Elbonia. The first two lines of main set the amount to be converted and create the list of coins used. The next two lines create the lists we need to store the results. coinsUsed is a list of the coins used to make change, and coinCount is the minimum number of coins used to make change for the amount corresponding to the position in the list.  Notice that the coins we print out come directly from the coinsUsed array. For the first call we start at array position 63 and print 21. Then we take and look at the 42nd element of the list. Once again we find a 21 stored there. Finally, element 21 of the array also contains 21, giving us the three 21 cent pieces.   Dynamic Programming With Coin Tracking  C++ Implementation \/\/Addition to the precious program that finds the types of coins used and the process of doing it. #include <iostream> #include <vector> using namespace std; int dpMakeChange(vector<int> coinValueList, int change, vector<int> minCoins, vector<int> coinsUsed){ \/\/This function keeps track of the number of coins needed to create the change. for (int cents = 0 ; cents < change+1; cents++){ int coinCount = cents; int newCoin = 1; for (int j : coinValueList){ \/\/loop finds solution for all sets of change from 0 to int change. if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins used to make the sum. newCoin = j; \/\/assigns the type of coins that is used to find the sum. } } } minCoins[cents] = coinCount; coinsUsed[cents] = newCoin; } return minCoins[change]; } vector<int> dpMakeChange2(vector<int> coinValueList, int change, vector<int> minCoins, vector<int> coinsUsed){ \/\/This function keeps track of the exact coins used to make the change. for (int cents = 0; cents < change + 1; cents++){ int coinCount = cents; int newCoin = 1; for (int j : coinValueList){ if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins that have been used to make the sum. newCoin = j; \/\/assigns the current type of coin that will be used to make the sum. } } } minCoins[cents] = coinCount; coinsUsed[cents] = newCoin; } return coinsUsed; } void printCoins(vector<int> coinsUsed, int change){ int coin = change; while (coin > 0){ int thisCoin = coinsUsed[coin]; cout << thisCoin << endl; coin = coin - thisCoin; } } int main(){ vector<int> clist = {1, 5, 10, 21, 25}; int amnt = 63; vector<int> minCoins(amnt + 1, 0); vector<int> coinsUsed(amnt + 1, 0); vector<int> coinCount(amnt + 1, 0); cout << \"Making change for \" << amnt << \" requires\" << endl; cout << dpMakeChange(clist, amnt, minCoins, coinsUsed)<< \" coins\" << endl; cout << \"They are: \" << endl; printCoins(dpMakeChange2(clist, amnt, minCoins, coinsUsed), amnt); cout << \"The used list is as follows: \" << endl; vector<int> coinsUsed2 = dpMakeChange2(clist, amnt, minCoins, coinsUsed); cout << \"[\"; for (unsigned int i = 0; i<coinsUsed2.size(); i++){ cout << coinsUsed2[i] << \", \"; } cout << \"]\" << endl; return 0; }  Python Implementation #Addition to the precious program that finds the types of coins used and the process of doing it. def dpMakeChange(coinValueList,change,minCoins,coinsUsed): for cents in range(change+1): coinCount = cents newCoin = 1 for j in [c for c in coinValueList if c <= cents]: if minCoins[cents-j] + 1 < coinCount: coinCount = minCoins[cents-j] + 1 #assigns the amount of coins used. newCoin = j #assigns the type of coin used. minCoins[cents] = coinCount coinsUsed[cents] = newCoin return minCoins[change] def printCoins(coinsUsed,change): coin = change while coin > 0: thisCoin = coinsUsed[coin] print(thisCoin) coin = coin - thisCoin def main(): amnt = 63 clist = [1, 5, 10, 21, 25] coinsUsed = [0]*(amnt+1) coinCount = [0]*(amnt+1) print(\"Making change for\",amnt,\"requires\") print(dpMakeChange(clist,amnt,coinCount,coinsUsed),\"coins\") print(\"They are:\") printCoins(coinsUsed,amnt) print(\"The used list is as follows:\") print(coinsUsed) main()   "
},
{
  "id": "recursion_dynamic-programming-2",
  "level": "2",
  "url": "recursion_dynamic-programming.html#recursion_dynamic-programming-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Dynamic programming "
},
{
  "id": "expl-lst-change1-cpp",
  "level": "2",
  "url": "recursion_dynamic-programming.html#expl-lst-change1-cpp",
  "type": "Exploration",
  "number": "5.12.1",
  "title": "Recursive Change Calculator.",
  "body": " Recursive Change Calculator  C++ Implementation \/\/Recursive example of trying to get the least amount of coins to make up an amount of change. #include <iostream> #include <vector> #include <algorithm> using namespace std; int recMC_greedy(vector<int> coinValueList, int change){ if (change == 0){ \/\/base case if, change is 0, then the number of coins have been finalized return 0; } else{ int cur_max =* max_element(coinValueList.begin(), coinValueList.end());\/\/use the maximum in the list to see how many of these can be used to form the sum int count=int(change\/cur_max); \/\/find how many of the max is needed to make the change so that the number of coins used is minimum coinValueList.erase(std::remove(coinValueList.begin(), coinValueList.end(), cur_max), coinValueList.end()); \/\/erasing the current max so that a different max can be \/\/used in next recursion and continue the greedy process return count + recMC_greedy(coinValueList, change-cur_max * count); \/\/returns the counts of the coins using recursion } } int main() { int arr2[] = {1, 5, 10, 21, 25}; vector<int> coinValueList(arr2, arr2 + (sizeof(arr2)\/ sizeof(arr2[0]))); \/\/Initializing vector cout<<recMC_greedy(coinValueList, 63)<<endl; \/\/using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21 return 0; \/\/but greedy algorithm gives 6 coins which is not the most optimum solution }  Python Implementation #Recursive example of trying to get the least amount of coins to make up an amount of change. def recMC_greedy(coinValueList,change): if change == 0: #base case if, change is 0, then the number of coins have been finalized return 0 else: cur_max = max(coinValueList) #use the maximum in the list to see how many of these can be used to form the sum count = change\/\/cur_max #find how many of the max is needed to make the change so that the number of coins used is minimum index = coinValueList.index(cur_max) del coinValueList[index] #erasing the current max so that a different max can be #used in next recursion and continue the greedy process return count + recMC_greedy(coinValueList, change-cur_max * count) #returns the counts of the coins using recursion def main(): print(recMC_greedy([1, 5, 10, 21, 25], 63)) #using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21 #but greedy algorithm gives 6 coins which is not the most optimum solution main()  "
},
{
  "id": "fig-c1ctcpp",
  "level": "2",
  "url": "recursion_dynamic-programming.html#fig-c1ctcpp",
  "type": "Figure",
  "number": "5.12.1",
  "title": "",
  "body": " Call Tree for   Diagram of a call tree for a recursive process, as seen in . The tree starts at the top with the root node labeled '26', branching down to nodes labeled '25' and '1'. Each node further branches out, with the left branch subtracting '1' and the right branch subtracting '5'. The pattern continues until reaching the leaf nodes, which are either '1' or a number that can no longer be reduced by five. Arrows indicate the direction of the call flow, starting from '26' and moving down through the levels of the tree.   "
},
{
  "id": "recursion_dynamic-programming-14",
  "level": "2",
  "url": "recursion_dynamic-programming.html#recursion_dynamic-programming-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "memoization "
},
{
  "id": "expl-lst-change2-cpp",
  "level": "2",
  "url": "recursion_dynamic-programming.html#expl-lst-change2-cpp",
  "type": "Exploration",
  "number": "5.12.2",
  "title": "Change Calculation With Memoization.",
  "body": " Change Calculation With Memoization  C++ Implementation \/\/A different attempt at making the change algorithm. #include <iostream> #include <vector> using namespace std; int recDC(vector<int> coinValueList, int change, int knownResults[]){ int minCoins, numCoins; minCoins = change; for (unsigned int i = 0; i< coinValueList.size(); i++){ \/\/this loop contains the base case, \/\/as it returns items that are not \/\/returning a call to the recDC function. if (coinValueList[i] == change){ knownResults[change] = 1; return 1; } else if(knownResults[change] > 0){ return knownResults[change]; } } for (unsigned int y=0; y<coinValueList.size(); y++){ if (coinValueList[y] <= change){ numCoins = 1 + recDC(coinValueList, change - coinValueList[y], knownResults); \/\/Recursive call if (numCoins < minCoins){ minCoins = numCoins; knownResults[change] = minCoins; } } } return minCoins; } int main(){ vector<int> coinValueList = {1, 5, 10, 21, 25}; int change = 63; int knownResults[64] = {0}; cout<<recDC(coinValueList, change, knownResults)<<endl; return 0; }  Python Implementation #A different attempt at making the change algorithm. def recDC(coinValueList, change, knownResults): minCoins = change if change in coinValueList: #base case knownResults[change] = 1 return 1 elif knownResults[change] > 0: #base case return knownResults[change] else: for i in [c for c in coinValueList if c <= change]: numCoins = 1 + recDC(coinValueList, change - i, knownResults) #Recursive call. if numCoins < minCoins: minCoins = numCoins knownResults[change] = minCoins return minCoins def main(): print(recDC([1, 5, 10, 21, 25], 63, [0]*64)) main()  "
},
{
  "id": "fig-dpcoins",
  "level": "2",
  "url": "recursion_dynamic-programming.html#fig-dpcoins",
  "type": "Figure",
  "number": "5.12.2",
  "title": "",
  "body": " Minimum Number of Coins Needed to Make.   Image of a table representing the minimum number of coins needed to make change. The columns are labeled with the 'Change to Make' values from 1 to 11. The rows correspond to 'Steps of the Algorithm', with each cell filled with the minimum number of coins needed at that step for the corresponding amount of change. Initial rows are partially filled with increasing sequences of numbers, indicating the progression of the algorithm. The bottom rows are blurred and continue with an ellipsis, suggesting the continuation of the process beyond what is shown.   "
},
{
  "id": "fig-eleven",
  "level": "2",
  "url": "recursion_dynamic-programming.html#fig-eleven",
  "type": "Figure",
  "number": "5.12.3",
  "title": "",
  "body": " Three Options to Consider for the Minimum Number of Coins for Eleven Cents.   Image of a curved numerical table representing three options to calculate the minimum number of coins for eleven cents. The table is labeled with numbers from 1 to 5 corresponding to the counts of coins used. Below the table, there are three curved arrows pointing to the number '11' from '11-1', '11-5', and '11-10', indicating the subtraction of 1, 5, and 10 cents from 11 cents to determine the next step in the calculation. The last cell under '11' is labeled with '??' to indicate the unknown minimum number of coins needed.   "
},
{
  "id": "expl-lst-dpchange-cpp",
  "level": "2",
  "url": "recursion_dynamic-programming.html#expl-lst-dpchange-cpp",
  "type": "Exploration",
  "number": "5.12.3",
  "title": "Change Calculator Using Dynamic Programming.",
  "body": " Change Calculator Using Dynamic Programming  C++ Implementation \/\/Program that stores the solution for all possible amounts of change up to a given integer. #include <iostream> #include <vector> using namespace std; int dpMakeChange(vector<int> coinValueList, int change, vector<int> minCoins){ for (int cents = 0 ; cents < change + 1; cents++){ \/\/loop finds solution for all sets of change from 0 to int change. int coinCount = cents; for (int j : coinValueList){ if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins that is used to make the change. } } } minCoins[cents] = coinCount; } return minCoins[change]; } int main(){ vector<int> coinValueList = {1, 5, 10, 21, 25}; int change = 63; vector<int> minCoins(64, 0); cout << dpMakeChange(coinValueList, change, minCoins) << endl; return 0; }  Python Implementation #Program that stores the solution for all possible amounts of change up to a given integer. def dpMakeChange(coinValueList,change,minCoins): for cents in range(change+1): #loops finds solution for all sets of change from 0 to change parameter. coinCount = cents for j in [c for c in coinValueList if c <= cents]: if minCoins[cents-j] + 1 < coinCount: coinCount = minCoins[cents-j] + 1 #assigns the number of coins that will be used to make the sum. minCoins[cents] = coinCount return minCoins[change] def main(): print(dpMakeChange([1, 5, 10, 21, 25], 63, [0]*64)) main()  "
},
{
  "id": "expl-lst-dpremember-cpp",
  "level": "2",
  "url": "recursion_dynamic-programming.html#expl-lst-dpremember-cpp",
  "type": "Exploration",
  "number": "5.12.4",
  "title": "Dynamic Programming With Coin Tracking.",
  "body": " Dynamic Programming With Coin Tracking  C++ Implementation \/\/Addition to the precious program that finds the types of coins used and the process of doing it. #include <iostream> #include <vector> using namespace std; int dpMakeChange(vector<int> coinValueList, int change, vector<int> minCoins, vector<int> coinsUsed){ \/\/This function keeps track of the number of coins needed to create the change. for (int cents = 0 ; cents < change+1; cents++){ int coinCount = cents; int newCoin = 1; for (int j : coinValueList){ \/\/loop finds solution for all sets of change from 0 to int change. if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins used to make the sum. newCoin = j; \/\/assigns the type of coins that is used to find the sum. } } } minCoins[cents] = coinCount; coinsUsed[cents] = newCoin; } return minCoins[change]; } vector<int> dpMakeChange2(vector<int> coinValueList, int change, vector<int> minCoins, vector<int> coinsUsed){ \/\/This function keeps track of the exact coins used to make the change. for (int cents = 0; cents < change + 1; cents++){ int coinCount = cents; int newCoin = 1; for (int j : coinValueList){ if (j <= cents){ if (minCoins[cents-j] + 1 < coinCount){ coinCount = minCoins[cents-j] + 1; \/\/assigns the number of coins that have been used to make the sum. newCoin = j; \/\/assigns the current type of coin that will be used to make the sum. } } } minCoins[cents] = coinCount; coinsUsed[cents] = newCoin; } return coinsUsed; } void printCoins(vector<int> coinsUsed, int change){ int coin = change; while (coin > 0){ int thisCoin = coinsUsed[coin]; cout << thisCoin << endl; coin = coin - thisCoin; } } int main(){ vector<int> clist = {1, 5, 10, 21, 25}; int amnt = 63; vector<int> minCoins(amnt + 1, 0); vector<int> coinsUsed(amnt + 1, 0); vector<int> coinCount(amnt + 1, 0); cout << \"Making change for \" << amnt << \" requires\" << endl; cout << dpMakeChange(clist, amnt, minCoins, coinsUsed)<< \" coins\" << endl; cout << \"They are: \" << endl; printCoins(dpMakeChange2(clist, amnt, minCoins, coinsUsed), amnt); cout << \"The used list is as follows: \" << endl; vector<int> coinsUsed2 = dpMakeChange2(clist, amnt, minCoins, coinsUsed); cout << \"[\"; for (unsigned int i = 0; i<coinsUsed2.size(); i++){ cout << coinsUsed2[i] << \", \"; } cout << \"]\" << endl; return 0; }  Python Implementation #Addition to the precious program that finds the types of coins used and the process of doing it. def dpMakeChange(coinValueList,change,minCoins,coinsUsed): for cents in range(change+1): coinCount = cents newCoin = 1 for j in [c for c in coinValueList if c <= cents]: if minCoins[cents-j] + 1 < coinCount: coinCount = minCoins[cents-j] + 1 #assigns the amount of coins used. newCoin = j #assigns the type of coin used. minCoins[cents] = coinCount coinsUsed[cents] = newCoin return minCoins[change] def printCoins(coinsUsed,change): coin = change while coin > 0: thisCoin = coinsUsed[coin] print(thisCoin) coin = coin - thisCoin def main(): amnt = 63 clist = [1, 5, 10, 21, 25] coinsUsed = [0]*(amnt+1) coinCount = [0]*(amnt+1) print(\"Making change for\",amnt,\"requires\") print(dpMakeChange(clist,amnt,coinCount,coinsUsed),\"coins\") print(\"They are:\") printCoins(coinsUsed,amnt) print(\"The used list is as follows:\") print(coinsUsed) main()  "
},
{
  "id": "recursion_recursion_summary",
  "level": "1",
  "url": "recursion_recursion_summary.html",
  "type": "Section",
  "number": "5.13",
  "title": "Summary",
  "body": " Summary  In this chapter we have looked at examples of several recursive algorithms. These algorithms were chosen to expose you to several different problems where recursion is an effective problem-solving technique. The key points to remember from this chapter are as follows:     All recursive algorithms must have a base case.    A recursive algorithm must change its state and make progress toward the base case.    A recursive algorithm must call itself (recursively).    Recursion can take the place of iteration in some cases.    Recursive algorithms often map very naturally to a formal expression of the problem you are trying to solve.    Recursion is not always the answer. Sometimes a recursive solution may be more computationally expensive than an alternative algorithm.     "
},
{
  "id": "recursion_recursion_self-check",
  "level": "1",
  "url": "recursion_recursion_self-check.html",
  "type": "Section",
  "number": "5.14",
  "title": "Self-check",
  "body": " Self-check   Q-1: What are the three laws of recursion for an algorithm? (choose all that are correct)     It must progress from the base case    If it starts at the base case, then when would it stop?      It must move towards the base case    Correct. The base case is your endpoint.      It must have a base case    Correct. The base case is essential if you want a stopping point      It must call itself    Correct. If it doesn't call itself then it won't repeat      Which implementation would be ideal for each problem.   Consider what would make you stop the process for each one.    Counting the number of items in a list  Iteration    Going through an entire tree  Recursion     Q-3: Sometimes recursion can be more computationally expensive than an alternative, True or False?     True    Correct! Sometimes simple problems only need simple solutions, like a loop      False    Incorrect. Recursion is not always the ideal solution.     "
},
{
  "id": "laws",
  "level": "2",
  "url": "recursion_recursion_self-check.html#laws",
  "type": "Checkpoint",
  "number": "5.14.1",
  "title": "",
  "body": " Q-1: What are the three laws of recursion for an algorithm? (choose all that are correct)     It must progress from the base case    If it starts at the base case, then when would it stop?      It must move towards the base case    Correct. The base case is your endpoint.      It must have a base case    Correct. The base case is essential if you want a stopping point      It must call itself    Correct. If it doesn't call itself then it won't repeat    "
},
{
  "id": "whenToRecurse",
  "level": "2",
  "url": "recursion_recursion_self-check.html#whenToRecurse",
  "type": "Checkpoint",
  "number": "5.14.2",
  "title": "",
  "body": " Which implementation would be ideal for each problem.   Consider what would make you stop the process for each one.    Counting the number of items in a list  Iteration    Going through an entire tree  Recursion   "
},
{
  "id": "recursionefficiencyq",
  "level": "2",
  "url": "recursion_recursion_self-check.html#recursionefficiencyq",
  "type": "Checkpoint",
  "number": "5.14.3",
  "title": "",
  "body": " Q-3: Sometimes recursion can be more computationally expensive than an alternative, True or False?     True    Correct! Sometimes simple problems only need simple solutions, like a loop      False    Incorrect. Recursion is not always the ideal solution.    "
},
{
  "id": "recursion_discussion-questions",
  "level": "1",
  "url": "recursion_discussion-questions.html",
  "type": "Section",
  "number": "5.15",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Draw a call stack for the Tower of Hanoi problem. Assume that you start with a stack of three disks.    Using the recursive rules as described, draw a Sierpinski triangle using paper and pencil.    Using the dynamic programming algorithm for making change, find the smallest number of coins that you can use to make 33 cents in change. In addition to the usual coins assume that you have an 8 cent coin.    "
},
{
  "id": "recursion_programming-exercises",
  "level": "1",
  "url": "recursion_programming-exercises.html",
  "type": "Section",
  "number": "5.16",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Write a recursive function to compute the factorial of a number.    Write a recursive function to reverse a list.    Modify the recursive tree program using one or all of the following ideas:    Modify the thickness of the branches so that as the branchLen gets smaller, the line gets thinner.    Modify the color of the branches so that as the branchLen gets very short it is colored like a leaf.    Modify the angle used in turning the turtle so that at each branch point the angle is selected at random in some range. For example choose the angle between 15 and 45 degrees. Play around to see what looks good.    Modify the branchLen recursively so that instead of always subtracting the same amount you subtract a random amount in some range.    If you implement all of the above ideas you will have a very realistic looking tree.    Find or invent an algorithm for drawing a fractal mountain. Hint: One approach to this uses triangles again.    Write a recursive function to compute the Fibonacci sequence. How does the performance of the recursive function compare to that of an iterative version?    Implement a solution to the Tower of Hanoi using three stacks to keep track of the disks.    Using the turtle graphics module, write a recursive program to display a Hilbert curve.    Using the turtle graphics module, write a recursive program to display a Koch snowflake.    Write a program to solve the following problem: You have two jugs: a 4-gallon jug and a 3-gallon jug. Neither of the jugs have markings on them. There is a pump that can be used to fill the jugs with water. How can you get exactly two gallons of water in the 4-gallon jug?    Generalize the problem above so that the parameters to your solution include the sizes of each jug and the final amount of water to be left in the larger jug.    Write a program that solves the following problem: Three missionaries and three cannibals come to a river and find a boat that holds two people. Everyone must get across the river to continue on the journey. However, if the cannibals ever outnumber the missionaries on either bank, the missionaries will be eaten. Find a series of crossings that will get everyone safely to the other side of the river.    Modify the Tower of Hanoi program using turtle graphics to animate the movement of the disks. Hint: You can make multiple turtles and have them shaped like rectangles.    Pascal's triangle is a number triangle with numbers arranged in staggered rows such that   This equation is the equation for a binomial coefficient. You can build Pascal's triangle by adding the two numbers that are diagonally above a number in the triangle. An example of Pascal's triangle is shown below.  1 1 1 1 2 1 1 3 3 1 1 4 6 4 1  Write a program that prints out Pascal's triangle. Your program should accept a parameter that tells how many rows of the triangle to print.    Suppose you are a computer scientist\/art thief who has broken into a major art gallery. All you have with you to haul out your stolen art is your knapsack which only holds pounds of art, but for every piece of art you know its value and its weight. Write a dynamic programming function to help you maximize your profit. Here is a sample problem for you to use to get started: Suppose your knapsack can hold a total weight of 20. You have 5 items as follows:  item weight value 1 2 3 2 3 4 3 4 8 4 5 8 5 9 10    This problem is called the string edit distance problem, and is quite useful in many areas of research. Suppose that you want to transform the word algorithm into the word alligator. For each letter you can either copy the letter from one word to another at a cost of 5, you can delete a letter at cost of 20, or insert a letter at a cost of 20. The total cost to transform one word into another is used by spell check programs to provide suggestions for words that are close to one another. Use dynamic programming techniques to develop an algorithm that gives you the smallest edit distance between any two words.    "
},
{
  "id": "recursion_glossary",
  "level": "1",
  "url": "recursion_glossary.html",
  "type": "Section",
  "number": "5.17",
  "title": "Glossary",
  "body": " Glossary    base case  A branch of the conditional statement in a recursive function that does not give rise to further recursive calls.    data structure  An organization of data for the purpose of making it easier to use.    dynamic programming  a way to solve complex problems by breaking it up, solving the smaller portions, and storing the results to avoid re-calculating them.    exception  An error that occurs at runtime.    handle an exception  To prevent an exception from terminating a program by wrapping the block of code in a try \/ except construct.    immutable data type  A data type which cannot be modified. Assignments to elements or slices of immutable types cause a runtime error.    infinite recursion  A function that calls itself recursively without ever reaching the base case. Eventually, an infinite recursion causes a runtime error.    mutable data type  A data type which can be modified. All mutable types are compound types. Lists and dictionaries (see next chapter) are mutable data types; strings and tuples are not.    raise  To cause an exception by using the raise statement.    recursion  The process of calling the function that is already executing.    recursive call  The statement that calls an already executing function. Recursion can even be indirect — function f can call g which calls h , and h could make a call back to f .    recursive definition  A definition which defines something in terms of itself. To be useful it must include base cases which are not recursive. In this way it differs from a circular definition . Recursive definitions often provide an elegant way to express complex data structures.    stack frame  a stack that contains a frame or group of data. For a call stack, this would be a function and its arguments.    tuple  A data type that contains a sequence of elements of any type, like a list, but is immutable. Tuples can be used wherever an immutable type is required, such as a key in a dictionary (see next chapter).    tuple assignment  An assignment to all of the elements in a tuple using a single assignment statement. Tuple assignment occurs in parallel rather than in sequence, making it useful for swapping values.    "
},
{
  "id": "recursion_recursion_matching",
  "level": "1",
  "url": "recursion_recursion_matching.html",
  "type": "Section",
  "number": "5.18",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition   incorrect    base case  branch of the conditional statement in a recursive function that does not give rise to further recursive calls.    recursion  The process of calling the function that is already executing.    recursive call  The statement that calls an already executing function.    recursive definition  A definition which defines something in terms of itself.    stack frame  A stack that contains a group of data.    tuple  Data type that contains a sequence of elements of any type, like alist, but is immutable.    tuple assignment  An assignment to all of the elements in a tuple using a single assignment statement.    data structure  An organization of data for the purpose of making it easier to use.    dynamic programming  To solve complex problems by breaking them up, solving the smaller portions, and storing the results to avoid re-calculating them.    exception  An error that occurs at runtime.    handle an exception  To prevent an exception from terminating a program by wrapping the block of code in a try \/ except construct.    immutable data type  A data type which cannot be modified.    infinite recursion  Function that calls itself recursively without ever reaching the base case, and will cause a runtime error.    mutable data type  A data type which can be modified.    raise  To cause an exception by using the raise statement.    "
},
{
  "id": "matching_recur",
  "level": "2",
  "url": "recursion_recursion_matching.html#matching_recur",
  "type": "Checkpoint",
  "number": "5.18.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition   incorrect    base case  branch of the conditional statement in a recursive function that does not give rise to further recursive calls.    recursion  The process of calling the function that is already executing.    recursive call  The statement that calls an already executing function.    recursive definition  A definition which defines something in terms of itself.    stack frame  A stack that contains a group of data.    tuple  Data type that contains a sequence of elements of any type, like alist, but is immutable.    tuple assignment  An assignment to all of the elements in a tuple using a single assignment statement.    data structure  An organization of data for the purpose of making it easier to use.    dynamic programming  To solve complex problems by breaking them up, solving the smaller portions, and storing the results to avoid re-calculating them.    exception  An error that occurs at runtime.    handle an exception  To prevent an exception from terminating a program by wrapping the block of code in a try \/ except construct.    immutable data type  A data type which cannot be modified.    infinite recursion  Function that calls itself recursively without ever reaching the base case, and will cause a runtime error.    mutable data type  A data type which can be modified.    raise  To cause an exception by using the raise statement.   "
},
{
  "id": "search-hash_objectives",
  "level": "1",
  "url": "search-hash_objectives.html",
  "type": "Section",
  "number": "6.1",
  "title": "Objectives",
  "body": " Objectives    To understand what search is and when it is appropriate.    To be able to explain and to implement sequential search and binary search.    To understand the idea of hashing as a search technique.    To introduce the unordered map abstract data type.    To implement a map abstract data type using hashing.    "
},
{
  "id": "search-hash_searching",
  "level": "1",
  "url": "search-hash_searching.html",
  "type": "Section",
  "number": "6.2",
  "title": "Searching",
  "body": " Searching  In the next two chapters we will turn our attention to some of the most common problems that arise in computing: searching and sorting. In this chapter we will study searching and return to sorting in the next chapter.  searching Searching is the algorithmic process of finding a particular item in a collection of items. A search typically answers either True or False as to whether the item is present. On occasion it may be modified to return where the item is found. For our purposes here, we will simply concern ourselves with the question of membership.  In many languages, libraries provide very easy ways to ask whether an item is in a container of items. In Python one uses the in operator on a list:  >>> 15 in [3,5,2,4,1] False >>> 3 in [3,5,2,4,1] True >>>  In C++, the STD vector library provides the find command which works on vectors and even on arrays (although much more awkwardly.) Here is an example using a vector:  >>> #include <vector> >>> int myints<int> = {3, 5, 2, 4, 1}; >>> cout << find(myints.begin(), myints.end(), 15); false >>> cout << find(myints.begin(), myints.end(), 3); true  How does this work? Even though this is easy to write, an underlying process must be carried out to do the search.  A function can be created for C++ arrays by passing in the array, the size of the array, and the value to search for as arguments.  bool isIn(int alist[], int size, int value) { for (unsigned i=0; i<size; i++) { if (alist[i] == value) { return true; } } return false; } int main() { int myarr[] = {3, 5, 2, 4, 1}; cout<<isIn(myarr, 5, 15)<<endl; cout<<isIn(myarr, 5, 3)<<endl; return 0; }  This works, but it is not the only way to search! It turns out that there are multiple different ways to search for the item. What we are interested in here is how these algorithms work and how they compare to one another.  "
},
{
  "id": "search-hash_searching-3",
  "level": "2",
  "url": "search-hash_searching.html#search-hash_searching-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Searching "
},
{
  "id": "search-hash_the-sequential-search",
  "level": "1",
  "url": "search-hash_the-sequential-search.html",
  "type": "Section",
  "number": "6.3",
  "title": "The Sequential Search",
  "body": " The Sequential Search   When data items are stored in a container type such as a Python list or a C++ array\/vector, we say that they have a linear or sequential relationship. Each data item is stored in a position relative to the others. In Python lists, these relative positions are the index values of the individual items. In C++ arrays, these are simply adjacent memory locations each equally sized to fit the data type of the container. Since these index values are ordered, it is possible for us to visit them in sequence. sequential search This process gives rise to our first searching technique, the sequential search .  shows how this search works. Starting at the first item in the list, we simply move from item to item, following the underlying sequential ordering until we either find what we are looking for or run out of items. If we run out of items, we have discovered that the item we were searching for was not present.   Sequential Search of a List of Integers.   Diagram showing a horizontal sequence of connected boxes containing integers, illustrating a sequential search algorithm. Each box contains a unique number, with values visible in the image including '54', '26', '93', '17', '77', '31', '44', '55', '20', and '65'. A curved arrow labeled 'Start' points to the first box '54', indicating the beginning of the search process. The arrangement suggests that the search will proceed through the list of numbers from left to right.    Both the Python and C++ implementations for this algorithm are shown in and respectively. The function needs the list and the item we are looking for and returns a boolean value as to whether it is present. The boolean variable found is initialized to False and is assigned the value True if we discover the item in the list (or vector, in the case of C++).    # Python implementation of sequential search def sequential_search(lst, item): found = False for i in range(len(lst)): if lst[i] == item: found = True break return found if __name__ == \"__main__\": lst = [1, 2, 3, 4, 5] item = 3 if sequential_search(lst, item): print(\"Item found!\") else: print(\"Item not found.\")      #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using sequential Search bool sequentialSearch(vector<int> avector, int item) { unsigned int pos = 0; bool found = false; while (pos < avector.size() && !found) { if (avector[pos] == item) { found = true; } else { pos++; } } return found; } int main() { \/\/ Vector initialized using an array int arr[] = {1, 2, 32, 8, 17, 19, 42, 13, 0}; vector<int> testvector(arr, arr + (sizeof(arr) \/ sizeof(arr[0]))); cout << sequentialSearch(testvector, 3) << endl; cout << sequentialSearch(testvector, 13) << endl; return 0; }      Analysis of Sequential Search  To analyze searching algorithms, we need to decide on a basic unit of computation. Recall that this is typically the common step that must be repeated in order to solve the problem. For searching, it makes sense to count the number of comparisons performed. Each comparison may or may not discover the item we are looking for. In addition, we make another assumption here: the list of items is not ordered in any way. The items have been placed randomly into the list. In other words, the probability that the item we are looking for is in any particular position is exactly the same for each position of the list.  If the item is not in the list, the only way to know it is to compare it against every item present. If there are items, then the sequential search requires comparisons to discover that the item is not there. In the case where the item is in the list, the analysis is not so straightforward. There are actually three different scenarios that can occur. In the best case we will find the item in the first place we look, at the beginning of the list. We will need only one comparison. In the worst case, we will not discover the item until the very last comparison, the nth comparison.  What about the average case? On average, we will find the item about halfway into the list; that is, we will compare against items. Recall, however, that as n gets large, the coefficients, no matter what they are, become insignificant in our approximation, so the complexity of the sequential search, is . summarizes these results.   Comparisons Used in a Sequential Search of an Unordered List    Case    Best Case    Worst Case    Average Case     item is present             item is not present             We assumed earlier that the items in our collection had been randomly placed so that there is no relative order between the items. What would happen to the sequential search if the items were ordered in some way? Would we be able to gain any efficiency in our search technique?  Assume that the list of items was constructed so that the items were in ascending order, from low to high. If the item we are looking for is present in the list, the chance of it being in any one of the n positions is still the same as before. We will still have the same number of comparisons to find the item. However, if the item is not present there is a slight advantage. shows this process as the algorithm looks for the item 50. Notice that items are still compared in sequence until 54. At this point, however, we know something extra. Not only is 54 not the item we are looking for, but no other elements beyond 54 can work either since the list is sorted. In this case, the algorithm does not have to continue looking through all of the items to report that the item was not found. It can stop immediately. shows this variation of the sequential search function.   Sequential Search of an Ordered List of Integers.   Image of a sequence of connected boxes in a horizontal line, each containing a number, representing a sequential search on an ordered list of integers. The numbers, displayed in ascending order, are '17', '20', '26', '31', '44', '54', '55', '65', '77', and '93'. A curved arrow labeled 'Start' points to the first box with '17', indicating the point where the search begins. The sequence suggests a methodical approach to searching, where each element is checked in order until the desired number is found.     Ordered Sequential Search  #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using ordered sequential Search bool orderedSequentialSearch(vector<int> avector, int item) { unsigned int pos = 0; bool found = false; bool stop = false; while (pos < avector.size() && !found && !stop) { if (avector[pos] == item) { found = true; } else { if (avector[pos] > item) { stop = true; } else { pos++; } } } return found; } int main() { \/\/ Vector initialized using an array int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> testvector(arr,arr+(sizeof(arr)\/sizeof(arr[0]))); cout << orderedSequentialSearch(testvector, 3) << endl; cout << orderedSequentialSearch(testvector, 13) << endl; return 0; }   summarizes these results. Note that in the best case we might discover that the item is not in the vector by looking at only one item. On average, we will know after looking through only items. However, this technique is still . In summary, a sequential search is improved by ordering the vector only in the case where we do not find the item.   Comparisons Used in Sequential Search of an Ordered List             item is present             item not present               For the following unordered sequential list: {0, 1, 2, 13, 8, 19, 17, 32, 42}, searching for  would produce the best case scenario, and searching for  would produce the worst case scenario. Correct! 0 is at the beginning of the list wich would provide the best case of O(1) No! try again, only one value place in this list will produce the best case. Correct! 42 is at the end of the list wich would provide the worst case of O(n) No! try again, only one value in this list will produce the worst case.   Suppose you are doing a sequential search of the list [15, 18, 2, 19, 18, 0, 8, 14, 19, 14]. How many comparisons would you need to do in order to find the key 18?     5    Five comparisons would get the second 18 in the list.      10    You do not need to search the entire list, only until you find the key you are looking for.      4    No, remember in a sequential search you start at the beginning and check each key until you find what you are looking for or exhaust the list.      2    In this case only 2 comparisons were needed to find the key.      Suppose you are doing a sequential search using a program that is enhanced to handle ordered lists more efficiently. When passing the list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] as a parameter, how many comparisons would you need to do in order to find the key 13?     10    You do not need to search the entire list, since it is ordered you can stop searching when you have compared with a value larger than the key.      5    Since 11 is less than the key value 13 you need to keep searching.      7    Since 14 is greater than the key value 13 you can stop.      6    Because 12 is less than the key value 13 you need to keep going.       "
},
{
  "id": "search-hash_the-sequential-search-2-1",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#search-hash_the-sequential-search-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "sequential search "
},
{
  "id": "fig-seqsearch",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#fig-seqsearch",
  "type": "Figure",
  "number": "6.3.1",
  "title": "",
  "body": " Sequential Search of a List of Integers.   Diagram showing a horizontal sequence of connected boxes containing integers, illustrating a sequential search algorithm. Each box contains a unique number, with values visible in the image including '54', '26', '93', '17', '77', '31', '44', '55', '20', and '65'. A curved arrow labeled 'Start' points to the first box '54', indicating the beginning of the search process. The arrangement suggests that the search will proceed through the list of numbers from left to right.   "
},
{
  "id": "seqsearchonepy",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#seqsearchonepy",
  "type": "Listing",
  "number": "6.3.2",
  "title": "",
  "body": "  # Python implementation of sequential search def sequential_search(lst, item): found = False for i in range(len(lst)): if lst[i] == item: found = True break return found if __name__ == \"__main__\": lst = [1, 2, 3, 4, 5] item = 3 if sequential_search(lst, item): print(\"Item found!\") else: print(\"Item not found.\")   "
},
{
  "id": "seqsearchonecpp",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#seqsearchonecpp",
  "type": "Listing",
  "number": "6.3.3",
  "title": "",
  "body": "  #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using sequential Search bool sequentialSearch(vector<int> avector, int item) { unsigned int pos = 0; bool found = false; while (pos < avector.size() && !found) { if (avector[pos] == item) { found = true; } else { pos++; } } return found; } int main() { \/\/ Vector initialized using an array int arr[] = {1, 2, 32, 8, 17, 19, 42, 13, 0}; vector<int> testvector(arr, arr + (sizeof(arr) \/ sizeof(arr[0]))); cout << sequentialSearch(testvector, 3) << endl; cout << sequentialSearch(testvector, 13) << endl; return 0; }   "
},
{
  "id": "search-hash_tbl-seqsearchtable",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#search-hash_tbl-seqsearchtable",
  "type": "Table",
  "number": "6.3.4",
  "title": "",
  "body": " Comparisons Used in a Sequential Search of an Unordered List    Case    Best Case    Worst Case    Average Case     item is present             item is not present            "
},
{
  "id": "fig-seqsearch2",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#fig-seqsearch2",
  "type": "Figure",
  "number": "6.3.5",
  "title": "",
  "body": " Sequential Search of an Ordered List of Integers.   Image of a sequence of connected boxes in a horizontal line, each containing a number, representing a sequential search on an ordered list of integers. The numbers, displayed in ascending order, are '17', '20', '26', '31', '44', '54', '55', '65', '77', and '93'. A curved arrow labeled 'Start' points to the first box with '17', indicating the point where the search begins. The sequence suggests a methodical approach to searching, where each element is checked in order until the desired number is found.   "
},
{
  "id": "lst-orderedseq",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#lst-orderedseq",
  "type": "Listing",
  "number": "6.3.6",
  "title": "",
  "body": " Ordered Sequential Search  #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using ordered sequential Search bool orderedSequentialSearch(vector<int> avector, int item) { unsigned int pos = 0; bool found = false; bool stop = false; while (pos < avector.size() && !found && !stop) { if (avector[pos] == item) { found = true; } else { if (avector[pos] > item) { stop = true; } else { pos++; } } } return found; } int main() { \/\/ Vector initialized using an array int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> testvector(arr,arr+(sizeof(arr)\/sizeof(arr[0]))); cout << orderedSequentialSearch(testvector, 3) << endl; cout << orderedSequentialSearch(testvector, 13) << endl; return 0; }  "
},
{
  "id": "search-hash_search-hash_tbl-seqsearchtable2",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#search-hash_search-hash_tbl-seqsearchtable2",
  "type": "Table",
  "number": "6.3.7",
  "title": "",
  "body": " Comparisons Used in Sequential Search of an Ordered List             item is present             item not present            "
},
{
  "id": "question_SRCH_0",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#question_SRCH_0",
  "type": "Reading Question",
  "number": "6.3.1.1",
  "title": "",
  "body": " For the following unordered sequential list: {0, 1, 2, 13, 8, 19, 17, 32, 42}, searching for  would produce the best case scenario, and searching for  would produce the worst case scenario. Correct! 0 is at the beginning of the list wich would provide the best case of O(1) No! try again, only one value place in this list will produce the best case. Correct! 42 is at the end of the list wich would provide the worst case of O(n) No! try again, only one value in this list will produce the worst case. "
},
{
  "id": "question_SRCH_1",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#question_SRCH_1",
  "type": "Reading Question",
  "number": "6.3.1.2",
  "title": "",
  "body": " Suppose you are doing a sequential search of the list [15, 18, 2, 19, 18, 0, 8, 14, 19, 14]. How many comparisons would you need to do in order to find the key 18?     5    Five comparisons would get the second 18 in the list.      10    You do not need to search the entire list, only until you find the key you are looking for.      4    No, remember in a sequential search you start at the beginning and check each key until you find what you are looking for or exhaust the list.      2    In this case only 2 comparisons were needed to find the key.    "
},
{
  "id": "question_SRCH_2",
  "level": "2",
  "url": "search-hash_the-sequential-search.html#question_SRCH_2",
  "type": "Reading Question",
  "number": "6.3.1.3",
  "title": "",
  "body": " Suppose you are doing a sequential search using a program that is enhanced to handle ordered lists more efficiently. When passing the list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] as a parameter, how many comparisons would you need to do in order to find the key 13?     10    You do not need to search the entire list, since it is ordered you can stop searching when you have compared with a value larger than the key.      5    Since 11 is less than the key value 13 you need to keep searching.      7    Since 14 is greater than the key value 13 you can stop.      6    Because 12 is less than the key value 13 you need to keep going.    "
},
{
  "id": "search-hash_the-binary-search",
  "level": "1",
  "url": "search-hash_the-binary-search.html",
  "type": "Section",
  "number": "6.4",
  "title": "The Binary Search",
  "body": " The Binary Search   It is possible to take greater advantage of the ordered vector if we are clever with our comparisons. In the sequential search, when we compare against the first item, there are at most more items to look through if the first item is not what we are looking for. binary search Instead of searching the vector in sequence, a binary search will start by examining the middle item. If that item is the one we are searching for, we are done. If it is not the correct item, we can use the ordered nature of the vector to eliminate half of the remaining items. If the item we are searching for is greater than the middle item, we know that the entire lower half of the vector as well as the middle item can be eliminated from further consideration. The item, if it is in the vector, must be in the upper half.  We can then repeat the process with the upper half. Start at the middle item and compare it against what we are looking for. Again, we either find it or split the vector in half, therefore eliminating another large part of our possible search space. shows how this algorithm can quickly find the value 54. The complete function is shown in .   Binary Search of an Ordered vector of Integers.   Diagram of an ordered sequence of boxes containing integers, indicative of a binary search algorithm. The numbers in the boxes are '17', '20', '26', '31', '44', '54', '55', '65', '77', and '93', arranged in ascending order. An arrow labeled 'Start' splits into two, pointing to the middle of the sequence, suggesting the initial step in binary search where the middle element is first compared with the target value.    A similar implementation can be carried out using vectors in C++.    #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using binary Search bool binarySearch(vector<int> avector, int item) { int first = 0; int last = avector.size() - 1; bool found = false; while (first <= last && !found) { int midpoint = (first + last) \/ 2; if (avector[midpoint] == item) { found = true; } else { if (item < avector[midpoint]) { last = midpoint - 1; } else { first = midpoint + 1; } } } return found; } int main() { \/\/ Using static array to initialize a vector static const int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> avector(arr, arr + sizeof(arr) \/ sizeof(arr[0])); cout << binarySearch(avector, 3) << endl; cout << binarySearch(avector, 13) << endl; return 0; }    Before we move on to the analysis, we should note that this algorithm is a great example of a divide and conquer strategy. Divide and conquer means that we divide the problem into smaller pieces, solve the smaller pieces in some way, and then reassemble the whole problem to get the result. When we perform a binary search of a list, we first check the middle item. If the item we are searching for is less than the middle item, we can simply perform a binary search of the left half of the original list. Likewise, if the item is greater, we can perform a binary search of the right half. Either way, this is a recursive call to the binary search function passing a smaller list. shows this recursive version.  There is a vector initializer within C++ that can be used much like python slices, however this can only be used when new vectors are created.    #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using binary Search and \/\/ seperating the vector in halves bool binarySearch(vector<int> alist, int item) { if (alist.size() == 0) { return false; } else { int midpoint = alist.size() \/ 2; if (alist[midpoint] == item) { return true; } else { if (item < alist[midpoint]) { vector<int> lefthalf(alist.begin(), alist.begin() + midpoint); return binarySearch(lefthalf, item); } else { vector<int> righthalf( alist.begin() + midpoint + 1, alist.end()); return binarySearch(righthalf, item); } } } } int main() { \/\/ Using static array to initialize a vector static const int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> alist(arr, arr + sizeof(arr) \/ sizeof(arr[0])); cout << binarySearch(alist, 3) << endl; cout << binarySearch(alist, 13) << endl; return 0; }      Analysis of Binary Search  To analyze the binary search algorithm, we need to recall that each comparison eliminates about half of the remaining items from consideration. What is the maximum number of comparisons this algorithm will require to check the entire list? If we start with n items, about items will be left after the first comparison. After the second comparison, there will be about . Then , , and so on. How many times can we split the list? helps us to see the answer.   Table 3: Tabular Analysis for a Binary Search    Comparisons    Approximate Number of Items Left     1       2       3       …      i       When we split the list enough times, we end up with a list that has just one item. Either that is the item we are looking for or it is not. Either way, we are done. The number of comparisons necessary to get to this point is i where . Solving for i gives us . The maximum number of comparisons is logarithmic with respect to the number of items in the list. Therefore, the binary search is .  One additional analysis issue needs to be addressed. In the recursive solution shown above, the recursive call,  binarySearch(alist[:midpoint],item)  uses the slice operator to create the left half of the list that is then passed to the next invocation (similarly for the right half as well). The analysis that we did above assumed that the slice operator takes constant time. This means that the binary search using slice will not perform in strict logarithmic time. Luckily this can be remedied by passing the list along with the starting and ending indices. The indices can be calculated as we did in . This is especially relevant in C++, where we are initializing a new vector for each split of our list. To truly optimize this algorithm, we could use an array and manually keep track of start and end indices of our array. shows such an implementation.   Binary Search Using Array Optimization  #include <iostream> using namespace std; \/\/Checks to see if item is in a vector \/\/returns true or false (1 or 0) \/\/using binary Search and \/\/uses start and end indices bool binarySearch(int arr[], int item, int start, int end) { if (end >= start) { int mid = start + (end - start) \/ 2; if (arr[mid] == item) return true; if (arr[mid] > item) return binarySearch(arr, item, start, mid - 1); else { return binarySearch(arr, item, mid + 1, end); } } return false; } bool binarySearchHelper(int arr[], int size, int item) { return binarySearch(arr, item, 0, size - 1); } int main(void) { int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; int arrLength = sizeof(arr) \/ sizeof(arr[0]); cout << binarySearchHelper(arr, arrLength, 3) << endl; cout << binarySearchHelper(arr, arrLength, 13) << endl; return 0; }  '''Checks to see if item is in a list returns true or false (1 or 0) using binary Search and uses start and end indices''' def binarySearch(array, item, start, end): if end >= start: mid = start + (end - start) \/\/ 2 if array[mid] == item: return True if array[mid] > item: return binarySearch(array, item, start, mid - 1) else: return binarySearch(array, item, mid + 1, end) return False def main(): array = [0, 1, 2, 8, 13, 17, 19, 32, 42] a = binarySearch(array, 17, 0 , len(array)-1) print(\"answer is \", a) b = binarySearch(array, 99, 0, len(array)-1) print(\"answer is\", b) main()   Even though a binary search is generally better than a sequential search, it is important to note that for small values of n , the additional cost of sorting is probably not worth it. In fact, we should always consider whether it is cost effective to take on the extra work of sorting to gain searching benefits. If we can sort once and then search many times, the cost of the sort is not so significant. However, for large lists, sorting even once can be so expensive that simply performing a sequential search from the start may be the best choice.    Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm. Which group of numbers correctly shows the sequence of comparisons used to find the key 8.     11, 5, 8    Looks like you might be guilty of an off-by-one error. Remember the first position is index 0.      11, 5, 6, 8    Binary search starts at the midpoint and halves the list each time.      3, 5, 6, 8    Binary search does not start at the beginning and search sequentially, its starts in the middle and halves the list after each compare.      18, 12, 8    It appears that you are starting from the end and halving the list each time.      Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm. Which group of numbers correctly shows the sequence of comparisons used to search for the key 16?     12, 15, 17    Looks like you might be guilty of an off-by-one error. Remember the first position is index 0.      18, 17, 14    Remember binary search starts in the middle and halves the list.      14, 12, 17    Looks like you might be off by one, be careful that you are calculating the midpoint using integer arithmetic.      11, 15, 17    Binary search starts at the midpoint and halves the list each time. It is done when the start index is greater than the end index.       "
},
{
  "id": "search-hash_the-binary-search-2-1",
  "level": "2",
  "url": "search-hash_the-binary-search.html#search-hash_the-binary-search-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "binary search "
},
{
  "id": "fig-binsearch",
  "level": "2",
  "url": "search-hash_the-binary-search.html#fig-binsearch",
  "type": "Figure",
  "number": "6.4.1",
  "title": "",
  "body": " Binary Search of an Ordered vector of Integers.   Diagram of an ordered sequence of boxes containing integers, indicative of a binary search algorithm. The numbers in the boxes are '17', '20', '26', '31', '44', '54', '55', '65', '77', and '93', arranged in ascending order. An arrow labeled 'Start' splits into two, pointing to the middle of the sequence, suggesting the initial step in binary search where the middle element is first compared with the target value.   "
},
{
  "id": "lst-binary_search_cpp",
  "level": "2",
  "url": "search-hash_the-binary-search.html#lst-binary_search_cpp",
  "type": "Listing",
  "number": "6.4.2",
  "title": "",
  "body": "  #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using binary Search bool binarySearch(vector<int> avector, int item) { int first = 0; int last = avector.size() - 1; bool found = false; while (first <= last && !found) { int midpoint = (first + last) \/ 2; if (avector[midpoint] == item) { found = true; } else { if (item < avector[midpoint]) { last = midpoint - 1; } else { first = midpoint + 1; } } } return found; } int main() { \/\/ Using static array to initialize a vector static const int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> avector(arr, arr + sizeof(arr) \/ sizeof(arr[0])); cout << binarySearch(avector, 3) << endl; cout << binarySearch(avector, 13) << endl; return 0; }   "
},
{
  "id": "binarysearch-1",
  "level": "2",
  "url": "search-hash_the-binary-search.html#binarysearch-1",
  "type": "Listing",
  "number": "6.4.3",
  "title": "",
  "body": "  #include <iostream> #include <vector> using namespace std; \/\/ Checks to see if item is in a vector \/\/ returns true or false (1 or 0) \/\/ using binary Search and \/\/ seperating the vector in halves bool binarySearch(vector<int> alist, int item) { if (alist.size() == 0) { return false; } else { int midpoint = alist.size() \/ 2; if (alist[midpoint] == item) { return true; } else { if (item < alist[midpoint]) { vector<int> lefthalf(alist.begin(), alist.begin() + midpoint); return binarySearch(lefthalf, item); } else { vector<int> righthalf( alist.begin() + midpoint + 1, alist.end()); return binarySearch(righthalf, item); } } } } int main() { \/\/ Using static array to initialize a vector static const int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; vector<int> alist(arr, arr + sizeof(arr) \/ sizeof(arr[0])); cout << binarySearch(alist, 3) << endl; cout << binarySearch(alist, 13) << endl; return 0; }   "
},
{
  "id": "search-hash_tbl-binaryanalysis",
  "level": "2",
  "url": "search-hash_the-binary-search.html#search-hash_tbl-binaryanalysis",
  "type": "Table",
  "number": "6.4.4",
  "title": "",
  "body": " Table 3: Tabular Analysis for a Binary Search    Comparisons    Approximate Number of Items Left     1       2       3       …      i      "
},
{
  "id": "expl-binary_search_cpp_array",
  "level": "2",
  "url": "search-hash_the-binary-search.html#expl-binary_search_cpp_array",
  "type": "Exploration",
  "number": "6.4.1",
  "title": "Binary Search Using Array Optimization.",
  "body": " Binary Search Using Array Optimization  #include <iostream> using namespace std; \/\/Checks to see if item is in a vector \/\/returns true or false (1 or 0) \/\/using binary Search and \/\/uses start and end indices bool binarySearch(int arr[], int item, int start, int end) { if (end >= start) { int mid = start + (end - start) \/ 2; if (arr[mid] == item) return true; if (arr[mid] > item) return binarySearch(arr, item, start, mid - 1); else { return binarySearch(arr, item, mid + 1, end); } } return false; } bool binarySearchHelper(int arr[], int size, int item) { return binarySearch(arr, item, 0, size - 1); } int main(void) { int arr[] = {0, 1, 2, 8, 13, 17, 19, 32, 42}; int arrLength = sizeof(arr) \/ sizeof(arr[0]); cout << binarySearchHelper(arr, arrLength, 3) << endl; cout << binarySearchHelper(arr, arrLength, 13) << endl; return 0; }  '''Checks to see if item is in a list returns true or false (1 or 0) using binary Search and uses start and end indices''' def binarySearch(array, item, start, end): if end >= start: mid = start + (end - start) \/\/ 2 if array[mid] == item: return True if array[mid] > item: return binarySearch(array, item, start, mid - 1) else: return binarySearch(array, item, mid + 1, end) return False def main(): array = [0, 1, 2, 8, 13, 17, 19, 32, 42] a = binarySearch(array, 17, 0 , len(array)-1) print(\"answer is \", a) b = binarySearch(array, 99, 0, len(array)-1) print(\"answer is\", b) main()  "
},
{
  "id": "BSRCH_1",
  "level": "2",
  "url": "search-hash_the-binary-search.html#BSRCH_1",
  "type": "Reading Question",
  "number": "6.4.1.1",
  "title": "",
  "body": " Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm. Which group of numbers correctly shows the sequence of comparisons used to find the key 8.     11, 5, 8    Looks like you might be guilty of an off-by-one error. Remember the first position is index 0.      11, 5, 6, 8    Binary search starts at the midpoint and halves the list each time.      3, 5, 6, 8    Binary search does not start at the beginning and search sequentially, its starts in the middle and halves the list after each compare.      18, 12, 8    It appears that you are starting from the end and halving the list each time.    "
},
{
  "id": "BSRCH_2",
  "level": "2",
  "url": "search-hash_the-binary-search.html#BSRCH_2",
  "type": "Reading Question",
  "number": "6.4.1.2",
  "title": "",
  "body": " Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm. Which group of numbers correctly shows the sequence of comparisons used to search for the key 16?     12, 15, 17    Looks like you might be guilty of an off-by-one error. Remember the first position is index 0.      18, 17, 14    Remember binary search starts in the middle and halves the list.      14, 12, 17    Looks like you might be off by one, be careful that you are calculating the midpoint using integer arithmetic.      11, 15, 17    Binary search starts at the midpoint and halves the list each time. It is done when the start index is greater than the end index.    "
},
{
  "id": "search-hash_hashing",
  "level": "1",
  "url": "search-hash_hashing.html",
  "type": "Section",
  "number": "6.5",
  "title": "Hashing",
  "body": " Hashing   In previous sections we were able to make improvements on our search algorithms by taking advantage of information about where items are stored in the collection with respect to one another. For example, by knowing that a list was ordered, we could search in logarithmic time using a binary search. In this section we will attempt to go one step further by building a data structure that can be searched in by using hashing . hashing  In order to do this, we will need to know even more about where the items might be when we go to look for them in the collection. If every item is where it should be, then the search can use a single comparison to discover the presence of an item. We will see, however, that this is typically not the case.  A hash table is a collection of items which are stored in such a way as to make it easy to find them later. Each position of the hash table, often called a slot , can hold an item and is named by an integer value starting at 0. hash table For example, we will have a slot named 0, a slot named 1, a slot named 2, and so on. slot Initially, the hash table contains no items so every slot is empty. We can implement a hash table by using a list with each value initialized to an empty string. shows a hash table of size . In other words, there are m slots in the table, named 0 through 10.    Hash Table with 11 Empty Slots.   Image depicting a hash table data structure with eleven empty slots. The slots are numbered from 0 to 10 and each contains the word 'None', indicating that they are unoccupied. The table is presented in a horizontal format, with clear delineation between each slot.     In a hash table, the mapping between an item and the slot where that item belongs in the hash table is called the hash function . hash function The hash function will take any item in the collection and return an integer in the range of slot names, between 0 and m -1. Assume that we have the set of integer items 54, 26, 93, 17, 77, and 31. Our first hash function, sometimes referred to as the remainder method, simply takes an item and divides it by the table size, returning the remainder as its hash value ( ). gives all of the hash values for our example items. Note that this remainder method (modulo arithmetic) will typically be present in some form in all hash functions, since the result must be in the range of slot names.   Simple Hash Function Using Remainders    Item    Hash Value     54  10    26  4    93  5    17  6    77  0    31  9    Once the hash values have been computed, we can insert each item into the hash table at the designated position as shown in . Note that 6 of the 11 slots are now occupied. This is referred to as the load factor , and is commonly denoted by . For this example, . load factor   Hash Table with Six Items.   Image showing a hash table with eleven slots, numbered from 0 to 10. Some slots contain integers while others are empty. Starting from the left, slot 0 contains '77', slot 4 contains '26', slot 5 contains '93', slot 6 contains '17', slot 9 contains '31', and slot 10 contains '54'. Slots 1, 2, 3, 7, and 8 are labeled 'None', indicating they are unoccupied.    Now when we want to search for an item, we simply use the hash function to compute the slot name for the item and then check the hash table to see if it is present. This searching operation is , since a constant amount of time is required to compute the hash value and then index the hash table at that location. If everything is where it should be, we have found a constant time search algorithm.  You can probably already see that this technique is going to work only if each item maps to a unique location in the hash table. For example, if the item 44 had been the next item in our collection, it would have a hash value of 0 ( ). Since 77 also had a hash value of 0, we would have a problem. According to the hash function, two or more items would need to be in the same slot.This is referred to as a collision (it may also be called a clash ). collision Clearly, collisions create a problem for the hashing technique. We will discuss them in detail later.    Hash Functions  Given a collection of items, a hash function that maps each item into a unique slot is referred to as a perfect hash function . perfect hash function If we know the items and the collection will never change, then it is possible to construct a perfect hash function (refer to the exercises for more about perfect hash functions). Unfortunately, given an arbitrary collection of items, there is no systematic way to construct a perfect hash function. Luckily, we do not need the hash function to be perfect to still gain performance efficiency.  One way to always have a perfect hash function is to increase the size of the hash table so that each possible value in the item range can be accommodated. This guarantees that each item will have a unique slot. Although this is practical for small numbers of items, it is not feasible when the number of possible items is large. For example, if the items were nine-digit Social Security numbers, this method would require almost one billion slots. If we only want to store data for a class of 25 students, we will be wasting an enormous amount of memory.  Our goal is to create a hash function that minimizes the number of collisions, is easy to compute, and evenly distributes the items in the hash table. There are a number of common ways to extend the simple remainder method. We will consider a few of them here.  The folding method for constructing hash functions begins by dividing the item into equal-size pieces (the last piece may not be of equal size). folding method These pieces are then added together to give the resulting hash value. For example, if our item was the phone number 436-555-4601, we would take the digits and divide them into groups of 2 (43,65,55,46,01). After the addition, , we get 210. If we assume our hash table has 11 slots, then we need to perform the extra step of dividing by 11 and keeping the remainder. In this case is 1, so the phone number 436-555-4601 hashes to slot 1. Some folding methods go one step further and reverse every other piece before the addition. For the above example, we get which gives .  Another numerical technique for constructing a hash function is called the mid-square method . mid-square method We first square the item, and then extract some portion of the resulting digits. For example, if the item were 44, we would first compute . By extracting the middle two digits, 93, and performing the remainder step, we get 5 ( ). shows items under both the remainder method and the mid-square method. You should verify that you understand how these values were computed.   Comparison of Remainder and Mid-Square Methods    Item    Remainder    Mid-Square     54  10  3    26  4  7    93  5  9    17  6  8    77  0  4    31  9  6    We can also create hash functions for character-based items such as strings. The word cat can be thought of as a sequence of int values. The corresponding int value can be found by declaring an int and using it to store a char. You can also cast the value as an int using int()  string h = \"hello\"; char c = h[0]; int i = c; cout<<h<<endl; cout<<c<<endl; cout<<i<<endl; >>hello >>h >>104  We can then take these three ordinal values, add them up, and use the remainder method to get a hash value (see ). shows a function called hash that takes a string and a table size and returns the hash value in the range from 0 to tablesize -1.   Hashing a String Using Ordinal Values.   Diagram illustrating the process of hashing a string using ordinal values. Three characters 'c', 'a', and 't' are shown at the top with arrows pointing down to their respective ordinal values: '99', '97', and '116'. These values are summed to equal '312'. An arrow then points from this sum to an operation '312 % 11', which results in '4'. This demonstrates a simple hash function where the sum of the character ordinals is divided by 11 to get a remainder, which serves as the hash value.     hash function   #include <iostream> #include <string> using namespace std; \/\/ uses ordinal values, of strings and using positional values to weight them \/\/to generate A hash value int hashfunc(string a, int tablesize) { int sum=0; for (unsigned int pos=0; pos<a.length(); pos++) { sum += int(a[pos]); \/\/ getting ordinal values, and using positional values to weight them \/\/adding them up, and using the remainder method to get a hash value. } return sum%tablesize; } int main() { cout<<hashfunc(\"First!\" , 10)<<endl; cout<<hashfunc(\"Second!\", 10)<<endl; cout<<hashfunc(\"Third!\" , 10)<<endl; return 0; }    It is interesting to note that when using this hash function, anagrams will always be given the same hash value. To remedy this, we could use the position of the character as a weight. shows one possible way to use the positional value as a weighting factor. The modification to the hash function is left as an exercise.   Hashing a String Using Ordinal Values with Weighting.   Image depicting a hashing algorithm that uses ordinal values of characters with weighting by their positions. The character 'c' in position 1 is multiplied by its ordinal value '99' and added to 1, 'a' in position 2 is multiplied by '97' and added to 2, and 't' in position 3 is multiplied by '116' and added to 3. The resulting sums are combined to total '641'. This sum is then divided by 11, as shown by the operation '641 % 11', resulting in a hash value of '3'.    You may be able to think of a number of additional ways to compute hash values for items in a collection. The important thing to remember is that the hash function has to be efficient so that it does not become the dominant part of the storage and search process. If the hash function is too complex, then it becomes more work to compute the slot name than it would be to simply do a basic sequential or binary search as described earlier. This would quickly defeat the purpose of hashing.    Collision Resolution  We now return to the problem of collisions. When two items hash to the same slot, we must have a systematic method for placing the second item in the hash table. This process is called collision resolution . collision resolution As we stated earlier, if the hash function is perfect, collisions will never occur. However, since this is often not possible, collision resolution becomes a very important part of hashing.  One method for resolving collisions looks into the hash table and tries to find another open slot to hold the item that caused the collision. A simple way to do this is to start at the original hash value position and then move in a sequential manner through the slots until we encounter the first slot that is empty. Note that we may need to go back to the first slot (circularly) to cover the entire hash table. This collision resolution process is referred to as open addressing in that it tries to find the next open slot or address in the hash table. open addressing By systematically visiting each slot one at a time, we are performing an open addressing technique called linear probing . linear probing  shows an extended set of integer items under the simple remainder method hash function (54,26,93,17,77,31,44,55,20). above shows the hash values for the original items. shows the original contents. When we attempt to place 44 into slot 0, a collision occurs. Under linear probing, we look sequentially, slot by slot, until we find an open position. In this case, we find slot 1.  Again, 55 should go in slot 0 but must be placed in slot 2 since it is the next open position. The final value of 20 hashes to slot 9. Since slot 9 is full, we begin to do linear probing. We visit slots 10, 0, 1, and 2, and finally find an empty slot at position 3.   Collision Resolution with Linear Probing.   Image of a hash table illustrating collision resolution with linear probing. The table has eleven slots numbered from 0 to 10. Filled slots contain the following integers: '77' in slot 0, '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '31' in slot 9, and '54' in slot 10. Slots 7 and 8 are labeled 'None', indicating they are empty. This setup suggests that when a collision occurs, the algorithm probes sequentially through the table to find the next available slot.    Once we have built a hash table using open addressing and linear probing, it is essential that we utilize the same methods to search for items. Assume we want to look up the item 93. When we compute the hash value, we get 5. Looking in slot 5 reveals 93, and we can return True . What if we are looking for 20? Now the hash value is 9, and slot 9 is currently holding 31. We cannot simply return False since we know that there could have been collisions. We are now forced to do a sequential search, starting at position 10, looking until either we find the item 20 or we find an empty slot.  A disadvantage to linear probing is the tendency for clustering ; items become clustered in the table. clustering This means that if many collisions occur at the same hash value, a number of surrounding slots will be filled by the linear probing resolution. This will have an impact on other items that are being inserted, as we saw when we tried to add the item 20 above. A cluster of values hashing to 0 had to be skipped to finally find an open position. This cluster is shown in .   A Cluster of Items for Slot 0.   Image of a hash table with a series of filled and empty slots. The slots are numbered from 0 to 10. Slot 0 contains the number '77', followed by '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, and '17' in slot 6. Slots 7 and 8 are empty and labeled 'None'. Slot 9 contains the number '31', and slot 10 contains '54'. This demonstrates a clustering effect where a sequence of items are hashed to neighboring slots starting from slot 0.    One way to deal with clustering is to extend the linear probing technique so that instead of looking sequentially for the next open slot, we skip slots, thereby more evenly distributing the items that have caused collisions. This will potentially reduce the clustering that occurs. shows the items when collision resolution is done with a plus 3 probe. This means that once a collision occurs, we will look at every third slot until we find one that is empty.   Collision Resolution Using Plus 3 .   Image of a hash table with eleven slots, demonstrating collision resolution using the 'Plus 3' strategy. The slots are numbered from 0 to 10, with '77' in slot 0, '55' in slot 1, 'None' in slot 2, '44' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '20' in slot 7, 'None' in slot 8, '31' in slot 9, and '54' in slot 10. The 'None' slots indicate empty positions where no value has been hashed to. The placement of numbers suggests that when a collision occurs, the item is placed in the next available slot that is three positions away.    The general name for this process of looking for another slot after a collision is rehashing . rehashing With simple linear probing, the rehash function is where . The plus 3 rehash can be defined as . In general, . It is important to note that the size of the skip must be such that all the slots in the table will eventually be visited. Otherwise, part of the table will be unused. To ensure this, it is often suggested that the table size be a prime number. This is the reason we have been using 11 in our examples.  A variation of the linear probing idea is called quadratic probing . quadratic probing Instead of using a constant skip value, we use a rehash function that increments the hash value by 1, 3, 5, 7, 9, and so on. This means that if the first hash value is h , the successive values are , , , , and so on. In other words, quadratic probing uses a skip consisting of successive perfect squares. shows our example values after they are placed using this technique.   Collision Resolution with Quadratic Probing.   Image of a hash table with eleven numbered slots, illustrating collision resolution with quadratic probing. The hash table contains the numbers '77' in slot 0, '44' in slot 1, '20' in slot 2, '55' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, and slots 7 and 8 are empty, labeled 'None'. The table ends with '31' in slot 9 and '54' in slot 10. The 'None' slots indicate that no items have been placed there, and the distribution of numbers shows that quadratic probing has been used to resolve collisions by placing items in slots that are a quadratic function of the distance from the original hashed slot.    An alternative method for handling the collision problem is to allow each slot to hold a reference to a collection (or chain) of items. Chaining allows many items to exist at the same location in the hash table. When collisions happen, the item is still placed in the proper slot of the hash table. chaining As more and more items hash to the same location, the difficulty of searching for the item in the collection increases. shows the items as they are added to a hash table that uses chaining to resolve collisions.   Collision Resolution with Chaining.   Image of a hash table with eleven slots numbered from 0 to 10, demonstrating collision resolution with chaining. Each slot is either empty, labeled 'None', or contains a vertical list of numbers, representing a chain of items that have been hashed to the same slot. Slot 0 has a chain of '77', followed by '44' and '55'. Slot 4 has '26' and '93', slot 6 has '17', slot 9 has '31' and '54', and slot 10 has '20'. The chains are represented by numbers in boxes with arrows pointing downwards to the next number in the chain, depicting how collisions are resolved by linking items within the same slot.    When we want to search for an item, we use the hash function to generate the slot where it should reside. Since each slot holds a collection, we use a searching technique to decide whether the item is present. The advantage is that on the average there are likely to be many fewer items in each slot, so the search is perhaps more efficient. We will look at the analysis for hashing at the end of this section.    Implementing the Map Abstract Data Type  One of the most useful C++ data structures is the map . Recall that a map is an associative data type where you can store key–data pairs. map In a map data structure, the key plays a crucial role as it is used to look up and retrieve the associated data value. By providing a key, you can quickly access the specific data element stored within the map.  The map abstract data type is defined as follows. The structure is an unordered collection of associations between a key and a data value. The keys in a map are all unique so that there is a one-to-one relationship between a key and a value. The operations are given below.   Map Operations    Map Operation    Description      m.Map()   Create a new, empty map. It returns an empty map collection     m.put(key,val)   Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value     m.get(key)   Given a key, return the value stored in the map or None otherwise     del m[key]   Delete the key-value pair from the map     len(m)   Return the number of key-value pairs stored in the map     in   Return True for a statement of the form key in map , if the given is in the map and False otherwise    One of the great benefits of a map is the fact that given a key, we can look up the associated data value very quickly. In order to provide this fast look up capability, we need an implementation that supports an efficient search. We could use a list with sequential or binary search but it would be even better to use a hash table as described above since looking up an item in a hash table can approach performance.  In we use two lists to create a HashTable class that implements the Map abstract data type. One list, called slots , will hold the key items and a parallel list, called data , will hold the data values. When we look up a key, the corresponding position in the data list will hold the associated data value. We will treat the key list as a hash table using the ideas presented earlier. Note that the initial size for the hash table has been chosen to be 11. Although this is arbitrary, it is important that the size be a prime number so that the collision resolution algorithm can be as efficient as possible.   class HashTable{ public: static const int size=11; int slots[size]; string data[size];   In , hashfunction implements the simple remainder method. The collision resolution technique is linear probing with a plus 1 rehash function. The put function assumes that there will eventually be an empty slot unless the key is already present in the self.slots . It computes the original hash value and if that slot is not empty, iterates the rehash function until an empty slot occurs. If a nonempty slot already contains the key, the old data value is replaced with the new data value. Dealing with the situation where there are no empty slots left is an exercise.   def put(self,key,data): hashvalue = self.hashfunction(key,len(self.slots)) if self.slots[hashvalue] == None: self.slots[hashvalue] = key self.data[hashvalue] = data else: if self.slots[hashvalue] == key: self.data[hashvalue] = data #replace else: nextslot = self.rehash(hashvalue,len(self.slots)) while self.slots[nextslot] != None and self.slots[nextslot] != key: nextslot = self.rehash(nextslot,len(self.slots)) if self.slots[nextslot] == None: self.slots[nextslot] = key self.data[nextslot] = data else: self.data[nextslot] = data #replace def hashfunction(self,key,size): return key%size def rehash(self,oldhash,size): return (oldhash+1)%size  int hashfunction(int key) { return key%size; } int rehash(int oldhash) { return (oldhash+1)%size; } void put(int key, string val){ int hashvalue = hashfunction(key); int count = 0; if (data[hashvalue]==\"\") { slots[hashvalue] = key; data[hashvalue] = val; } else { if (slots[hashvalue] == key) { data[hashvalue] = val; } else { int nextslot = rehash(hashvalue); while (data[nextslot]!=\"\" && slots[nextslot] != key) { nextslot = rehash(nextslot); count++; if (count>size) { cout<<\"TABLE FULL\"<<endl; return; } } if (data[nextslot]==\"\") { slots[nextslot]=key; data[nextslot]=val; } else { data[nextslot] = val; } } } }   Likewise, the get function (see ) begins by computing the initial hash value. If the value is not in the initial slot, rehash is used to locate the next possible position. Notice that line 15 guarantees that the search will terminate by checking to make sure that we have not returned to the initial slot. If that happens, we have exhausted all possible slots and the item must not be present.  The final methods of the HashTable class provide additional map functionality. We overload the __getitem__ and __setitem__ methods to allow access using``[]``. This means that once a HashTable has been created, the familiar index operator will be available. We leave the remaining methods as exercises.   def get(self,key): startslot = self.hashfunction(key,len(self.slots)) data = None stop = False found = False position = startslot while self.slots[position] != None and not found and not stop: if self.slots[position] == key: found = True data = self.data[position] else: position=self.rehash(position,len(self.slots)) if position == startslot: stop = True return data def __getitem__(self,key): return self.get(key) def __setitem__(self,key,data): self.put(key,data)  string get(int key) { int startslot = hashfunction(key); string val; bool stop=false; bool found=false; int position = startslot; while(data[position]!=\"\" && !found && !stop) { if (slots[position]==key) { found = true; val = data[position]; } else { position=rehash(position); if (position==startslot) { stop=true; } } } return val; }   The following session shows the HashTable class in action. First we will create a hash table and store some items with integer keys and string data values.  int main() { HashTable h; h.put(54, \"cat\"); h.put(26, \"dog\"); h.put(93, \"lion\"); h.put(17, \"tiger\"); h.put(77, \"bird\"); h.put(31, \"cow\"); h.put(44, \"goat\"); h.put(55, \"pig\"); h.put(20, \"chicken\"); cout<<h<<endl; return 0; } >> Output: 77: bird 44: goat 55: pig 20: chicken 26: dog 93: lion 17: tiger 0: 0: 31: cow 54: cat  Next we will access and modify some items in the hash table. Note that the value for the key 20 is being replaced.  ... h.put(20,\"chicken\"); h.put(17,\"tiger\"); h.put(20,\"duck\"); cout<<h<<endl; ... >> Output: 77: bird 44: goat 55: pig 20: duck 26: dog 93: lion 17: tiger 65535: 0: 31: cow 54: cat  The complete hash table example can be found in ActiveCode 1.    #include <iostream> #include <string> using namespace std; class HashTable{ public: static const int size=11; \/\/ initial size of hash table is prime to help with collision resolution int slots[size]; \/\/ list to hold key items string data[size]; \/\/ list to hold data values int hashfunction(int key) { \/\/ implements remainder method return key%size; } \/\/ Computes original hashvalue, and if slot is \/\/ not empty iterates until empty slot is found int rehash(int oldhash) { return (oldhash+1)%size; } \/\/ Function that assumes there will eventually be \/\/ an empty slot unless the key is alread present in the slot void put(int key, string val){ int hashvalue = hashfunction(key); int count = 0; if (data[hashvalue]==\"\") { slots[hashvalue] = key; data[hashvalue] = val; } else { if (slots[hashvalue] == key) { data[hashvalue] = val; } else { int nextslot = rehash(hashvalue); while (data[nextslot]!=\"\" && slots[nextslot] != key) { nextslot = rehash(nextslot); count++; if (count>size) { cout<<\"TABLE FULL\"<<endl; return; } } if (data[nextslot]==\"\") { slots[nextslot]=key; data[nextslot]=val; } else { data[nextslot] = val; } } } } \/\/ computes the initial hash value \/\/ if value is not in the initial slot, uses \/\/ rehash to locate the next position string get(int key) { int startslot = hashfunction(key); string val; bool stop=false; bool found=false; int position = startslot; while(data[position]!=\"\" && !found && !stop) { if (slots[position]==key) { found = true; val = data[position]; } else { position=rehash(position); if (position==startslot) { stop=true; } } } return val; } friend ostream& operator<<(ostream& stream, HashTable& hash); }; ostream& operator<<(ostream& stream, HashTable& hash) { for (int i=0; i<hash.size; i++) { stream<<hash.slots[i]<<\": \"<<hash.data[i]<<endl; } return stream; } int main() { HashTable h; h.put(54, \"cat\"); h.put(26, \"dog\"); h.put(93, \"lion\"); h.put(17, \"tiger\"); h.put(77, \"bird\"); h.put(31, \"cow\"); h.put(44, \"goat\"); h.put(55, \"pig\"); h.put(20, \"chicken\"); cout<<h<<endl; h.put(20,\"chicken\"); h.put(17,\"tiger\"); h.put(20,\"duck\"); cout<<h.get(20)<<endl; cout<<h.get(99)<<endl; return 0; }     class HashTable: def __init__(self): self.size = 11 # initial size of hash table is prime to help with collision resolution self.slots = [None] * self.size # list to hold key items self.data = [None] * self.size # list to hold data values def put(self,key,data): hashvalue = self.hashfunction(key,len(self.slots)) if self.slots[hashvalue] == None: self.slots[hashvalue] = key self.data[hashvalue] = data else: if self.slots[hashvalue] == key: self.data[hashvalue] = data #replace else: nextslot = self.rehash(hashvalue,len(self.slots)) while self.slots[nextslot] != None and \\ self.slots[nextslot] != key: nextslot = self.rehash(nextslot,len(self.slots)) if self.slots[nextslot] == None: self.slots[nextslot]=key self.data[nextslot]=data else: self.data[nextslot] = data #replace # Function that assumes there will eventually be # an empty slot unless the key is alread present in the slot def hashfunction(self,key,size): # implements remainder method return key%size # Fomputes original hashvalue, and if slot is # not empty iterates until empty slot is found def rehash(self,oldhash,size): return (oldhash+1)%size # computes the initial hash value # if value is not in the initial slot, uses # rehash to locate the next position def get(self,key): startslot = self.hashfunction(key,len(self.slots)) data = None stop = False found = False position = startslot while self.slots[position] != None and \\ not found and not stop: if self.slots[position] == key: found = True data = self.data[position] else: position=self.rehash(position,len(self.slots)) if position == startslot: stop = True return data def __getitem__(self,key): return self.get(key) def __setitem__(self,key,data): self.put(key,data) H=HashTable() H[54]=\"cat\" H[26]=\"dog\" H[93]=\"lion\" H[17]=\"tiger\" H[77]=\"bird\" H[31]=\"cow\" H[44]=\"goat\" H[55]=\"pig\" H[20]=\"chicken\" print(H.slots) print(H.data) print(H[20]) print(H[17]) H[20]='duck' print(H[20]) print(H[99])      Analysis of Hashing  We stated earlier that in the best case hashing would provide a , constant time search technique. However, due to collisions, the number of comparisons is typically not so simple. Even though a complete analysis of hashing is beyond the scope of this text, we can state some well-known results that approximate the number of comparisons necessary to search for an item.  The most important piece of information we need to analyze the use of a hash table is the load factor, . Conceptually, if is small, then there is a lower chance of collisions, meaning that items are more likely to be in the slots where they belong. If is large, meaning that the table is filling up, then there are more and more collisions. This means that collision resolution is more difficult, requiring more comparisons to find an empty slot. With chaining, increased collisions means an increased number of items on each chain.  As before, we will have a result for both a successful and an unsuccessful search. For a successful search using open addressing with linear probing, the average number of comparisons is approximately and an unsuccessful search gives If we are using chaining, the average number of comparisons is for the successful case, and simply comparisons if the search is unsuccessful.    In a hash table of size 13 which index positions would the following two keys map to? 27, 130     1, 10    Be careful to use modulo not integer division      13, 0    Don't divide by two, use the modulo operator.      1, 0    27 % 13 == 1 and 130 % 13 == 0      2, 3    Use the modulo operator      Suppose you are given the following set of keys to insert into a hash table that holds exactly 11 values: 113 , 117 , 97 , 100 , 114 , 108 , 121 , 105 , 99 Which of the following best demonstrates the contents of the hash table after all the keys have been inserted using linear probing?     100, __, __, 113, 114, 105, 121, 117, 97, 108, 99    It looks like you may have been doing modulo 2 arithmentic. You need to use the hash table size as the modulo value.      121, 100, 99, 113, 114, __, 105, 117, __, 97, 108    Using modulo 11 arithmetic and linear probing gives these values      100, 113, 117, 97, 14, 108, 121, 105, 99, __, __    It looks like you are using modulo 10 arithmetic, use the table size.      117, 114, 108, 121, 105, 99, __, __, 97, 100, 113    Be careful to use modulo not integer division.       "
},
{
  "id": "search-hash_hashing-2-1",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hashing-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hashing "
},
{
  "id": "search-hash_hashing-2-3",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hashing-2-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hash table slot "
},
{
  "id": "search_hash-fig-hashtable1",
  "level": "2",
  "url": "search-hash_hashing.html#search_hash-fig-hashtable1",
  "type": "Figure",
  "number": "6.5.1",
  "title": "",
  "body": " Hash Table with 11 Empty Slots.   Image depicting a hash table data structure with eleven empty slots. The slots are numbered from 0 to 10 and each contains the word 'None', indicating that they are unoccupied. The table is presented in a horizontal format, with clear delineation between each slot.   "
},
{
  "id": "search-hash_hashing-2-5",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hashing-2-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hash function "
},
{
  "id": "search-hash_search-hash_tbl-hashvalues1",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_search-hash_tbl-hashvalues1",
  "type": "Table",
  "number": "6.5.2",
  "title": "",
  "body": " Simple Hash Function Using Remainders    Item    Hash Value     54  10    26  4    93  5    17  6    77  0    31  9   "
},
{
  "id": "search-hash_hashing-2-7",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hashing-2-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "load factor "
},
{
  "id": "fig-hashtable2",
  "level": "2",
  "url": "search-hash_hashing.html#fig-hashtable2",
  "type": "Figure",
  "number": "6.5.3",
  "title": "",
  "body": " Hash Table with Six Items.   Image showing a hash table with eleven slots, numbered from 0 to 10. Some slots contain integers while others are empty. Starting from the left, slot 0 contains '77', slot 4 contains '26', slot 5 contains '93', slot 6 contains '17', slot 9 contains '31', and slot 10 contains '54'. Slots 1, 2, 3, 7, and 8 are labeled 'None', indicating they are unoccupied.   "
},
{
  "id": "search-hash_hashing-2-10",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hashing-2-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "collision "
},
{
  "id": "search-hash_hash-functions-2",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hash-functions-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "perfect hash function "
},
{
  "id": "search-hash_hash-functions-5",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hash-functions-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "folding method "
},
{
  "id": "search-hash_hash-functions-6",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hash-functions-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "mid-square method "
},
{
  "id": "search-hash_tbl-hashvalues2",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_tbl-hashvalues2",
  "type": "Table",
  "number": "6.5.4",
  "title": "",
  "body": " Comparison of Remainder and Mid-Square Methods    Item    Remainder    Mid-Square     54  10  3    26  4  7    93  5  9    17  6  8    77  0  4    31  9  6   "
},
{
  "id": "search-hash_hash-functions-8",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_hash-functions-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "int() "
},
{
  "id": "fig-stringhash",
  "level": "2",
  "url": "search-hash_hashing.html#fig-stringhash",
  "type": "Figure",
  "number": "6.5.5",
  "title": "",
  "body": " Hashing a String Using Ordinal Values.   Diagram illustrating the process of hashing a string using ordinal values. Three characters 'c', 'a', and 't' are shown at the top with arrows pointing down to their respective ordinal values: '99', '97', and '116'. These values are summed to equal '312'. An arrow then points from this sum to an operation '312 % 11', which results in '4'. This demonstrates a simple hash function where the sum of the character ordinals is divided by 11 to get a remainder, which serves as the hash value.   "
},
{
  "id": "search-hash_lst-hashfunction1",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_lst-hashfunction1",
  "type": "Listing",
  "number": "6.5.6",
  "title": "",
  "body": " hash function   #include <iostream> #include <string> using namespace std; \/\/ uses ordinal values, of strings and using positional values to weight them \/\/to generate A hash value int hashfunc(string a, int tablesize) { int sum=0; for (unsigned int pos=0; pos<a.length(); pos++) { sum += int(a[pos]); \/\/ getting ordinal values, and using positional values to weight them \/\/adding them up, and using the remainder method to get a hash value. } return sum%tablesize; } int main() { cout<<hashfunc(\"First!\" , 10)<<endl; cout<<hashfunc(\"Second!\", 10)<<endl; cout<<hashfunc(\"Third!\" , 10)<<endl; return 0; }   "
},
{
  "id": "fig-stringhash2",
  "level": "2",
  "url": "search-hash_hashing.html#fig-stringhash2",
  "type": "Figure",
  "number": "6.5.7",
  "title": "",
  "body": " Hashing a String Using Ordinal Values with Weighting.   Image depicting a hashing algorithm that uses ordinal values of characters with weighting by their positions. The character 'c' in position 1 is multiplied by its ordinal value '99' and added to 1, 'a' in position 2 is multiplied by '97' and added to 2, and 't' in position 3 is multiplied by '116' and added to 3. The resulting sums are combined to total '641'. This sum is then divided by 11, as shown by the operation '641 % 11', resulting in a hash value of '3'.   "
},
{
  "id": "search-hash_collision-resolution-2",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "collision resolution "
},
{
  "id": "search-hash_collision-resolution-3",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "open addressing linear probing "
},
{
  "id": "fig-linearprobing1",
  "level": "2",
  "url": "search-hash_hashing.html#fig-linearprobing1",
  "type": "Figure",
  "number": "6.5.8",
  "title": "",
  "body": " Collision Resolution with Linear Probing.   Image of a hash table illustrating collision resolution with linear probing. The table has eleven slots numbered from 0 to 10. Filled slots contain the following integers: '77' in slot 0, '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '31' in slot 9, and '54' in slot 10. Slots 7 and 8 are labeled 'None', indicating they are empty. This setup suggests that when a collision occurs, the algorithm probes sequentially through the table to find the next available slot.   "
},
{
  "id": "search-hash_collision-resolution-8",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "clustering "
},
{
  "id": "fig-clustering",
  "level": "2",
  "url": "search-hash_hashing.html#fig-clustering",
  "type": "Figure",
  "number": "6.5.9",
  "title": "",
  "body": " A Cluster of Items for Slot 0.   Image of a hash table with a series of filled and empty slots. The slots are numbered from 0 to 10. Slot 0 contains the number '77', followed by '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, and '17' in slot 6. Slots 7 and 8 are empty and labeled 'None'. Slot 9 contains the number '31', and slot 10 contains '54'. This demonstrates a clustering effect where a sequence of items are hashed to neighboring slots starting from slot 0.   "
},
{
  "id": "fig-linearprobing2",
  "level": "2",
  "url": "search-hash_hashing.html#fig-linearprobing2",
  "type": "Figure",
  "number": "6.5.10",
  "title": "",
  "body": " Collision Resolution Using Plus 3 .   Image of a hash table with eleven slots, demonstrating collision resolution using the 'Plus 3' strategy. The slots are numbered from 0 to 10, with '77' in slot 0, '55' in slot 1, 'None' in slot 2, '44' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '20' in slot 7, 'None' in slot 8, '31' in slot 9, and '54' in slot 10. The 'None' slots indicate empty positions where no value has been hashed to. The placement of numbers suggests that when a collision occurs, the item is placed in the next available slot that is three positions away.   "
},
{
  "id": "search-hash_collision-resolution-12",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "rehashing "
},
{
  "id": "search-hash_collision-resolution-13",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "quadratic probing "
},
{
  "id": "fig-quadratic",
  "level": "2",
  "url": "search-hash_hashing.html#fig-quadratic",
  "type": "Figure",
  "number": "6.5.11",
  "title": "",
  "body": " Collision Resolution with Quadratic Probing.   Image of a hash table with eleven numbered slots, illustrating collision resolution with quadratic probing. The hash table contains the numbers '77' in slot 0, '44' in slot 1, '20' in slot 2, '55' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, and slots 7 and 8 are empty, labeled 'None'. The table ends with '31' in slot 9 and '54' in slot 10. The 'None' slots indicate that no items have been placed there, and the distribution of numbers shows that quadratic probing has been used to resolve collisions by placing items in slots that are a quadratic function of the distance from the original hashed slot.   "
},
{
  "id": "search-hash_collision-resolution-15",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_collision-resolution-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Chaining "
},
{
  "id": "fig-chaining",
  "level": "2",
  "url": "search-hash_hashing.html#fig-chaining",
  "type": "Figure",
  "number": "6.5.12",
  "title": "",
  "body": " Collision Resolution with Chaining.   Image of a hash table with eleven slots numbered from 0 to 10, demonstrating collision resolution with chaining. Each slot is either empty, labeled 'None', or contains a vertical list of numbers, representing a chain of items that have been hashed to the same slot. Slot 0 has a chain of '77', followed by '44' and '55'. Slot 4 has '26' and '93', slot 6 has '17', slot 9 has '31' and '54', and slot 10 has '20'. The chains are represented by numbers in boxes with arrows pointing downwards to the next number in the chain, depicting how collisions are resolved by linking items within the same slot.   "
},
{
  "id": "search-hash_implementing-the-map-abstract-data-type-2",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_implementing-the-map-abstract-data-type-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "map "
},
{
  "id": "search-hash_id12",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_id12",
  "type": "Table",
  "number": "6.5.13",
  "title": "",
  "body": " Map Operations    Map Operation    Description      m.Map()   Create a new, empty map. It returns an empty map collection     m.put(key,val)   Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value     m.get(key)   Given a key, return the value stored in the map or None otherwise     del m[key]   Delete the key-value pair from the map     len(m)   Return the number of key-value pairs stored in the map     in   Return True for a statement of the form key in map , if the given is in the map and False otherwise   "
},
{
  "id": "search-hash_lst-hashtablecodeconstructor",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_lst-hashtablecodeconstructor",
  "type": "Listing",
  "number": "6.5.14",
  "title": "",
  "body": " class HashTable{ public: static const int size=11; int slots[size]; string data[size];  "
},
{
  "id": "search-hash_lst-hashtablecodestore",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_lst-hashtablecodestore",
  "type": "Listing",
  "number": "6.5.15",
  "title": "",
  "body": " def put(self,key,data): hashvalue = self.hashfunction(key,len(self.slots)) if self.slots[hashvalue] == None: self.slots[hashvalue] = key self.data[hashvalue] = data else: if self.slots[hashvalue] == key: self.data[hashvalue] = data #replace else: nextslot = self.rehash(hashvalue,len(self.slots)) while self.slots[nextslot] != None and self.slots[nextslot] != key: nextslot = self.rehash(nextslot,len(self.slots)) if self.slots[nextslot] == None: self.slots[nextslot] = key self.data[nextslot] = data else: self.data[nextslot] = data #replace def hashfunction(self,key,size): return key%size def rehash(self,oldhash,size): return (oldhash+1)%size  int hashfunction(int key) { return key%size; } int rehash(int oldhash) { return (oldhash+1)%size; } void put(int key, string val){ int hashvalue = hashfunction(key); int count = 0; if (data[hashvalue]==\"\") { slots[hashvalue] = key; data[hashvalue] = val; } else { if (slots[hashvalue] == key) { data[hashvalue] = val; } else { int nextslot = rehash(hashvalue); while (data[nextslot]!=\"\" && slots[nextslot] != key) { nextslot = rehash(nextslot); count++; if (count>size) { cout<<\"TABLE FULL\"<<endl; return; } } if (data[nextslot]==\"\") { slots[nextslot]=key; data[nextslot]=val; } else { data[nextslot] = val; } } } }  "
},
{
  "id": "search-hash_lst-hashtablecodesearch",
  "level": "2",
  "url": "search-hash_hashing.html#search-hash_lst-hashtablecodesearch",
  "type": "Listing",
  "number": "6.5.16",
  "title": "",
  "body": " def get(self,key): startslot = self.hashfunction(key,len(self.slots)) data = None stop = False found = False position = startslot while self.slots[position] != None and not found and not stop: if self.slots[position] == key: found = True data = self.data[position] else: position=self.rehash(position,len(self.slots)) if position == startslot: stop = True return data def __getitem__(self,key): return self.get(key) def __setitem__(self,key,data): self.put(key,data)  string get(int key) { int startslot = hashfunction(key); string val; bool stop=false; bool found=false; int position = startslot; while(data[position]!=\"\" && !found && !stop) { if (slots[position]==key) { found = true; val = data[position]; } else { position=rehash(position); if (position==startslot) { stop=true; } } } return val; }  "
},
{
  "id": "HASH_1",
  "level": "2",
  "url": "search-hash_hashing.html#HASH_1",
  "type": "Reading Question",
  "number": "6.5.4.1",
  "title": "",
  "body": " In a hash table of size 13 which index positions would the following two keys map to? 27, 130     1, 10    Be careful to use modulo not integer division      13, 0    Don't divide by two, use the modulo operator.      1, 0    27 % 13 == 1 and 130 % 13 == 0      2, 3    Use the modulo operator    "
},
{
  "id": "HASH_2",
  "level": "2",
  "url": "search-hash_hashing.html#HASH_2",
  "type": "Reading Question",
  "number": "6.5.4.2",
  "title": "",
  "body": " Suppose you are given the following set of keys to insert into a hash table that holds exactly 11 values: 113 , 117 , 97 , 100 , 114 , 108 , 121 , 105 , 99 Which of the following best demonstrates the contents of the hash table after all the keys have been inserted using linear probing?     100, __, __, 113, 114, 105, 121, 117, 97, 108, 99    It looks like you may have been doing modulo 2 arithmentic. You need to use the hash table size as the modulo value.      121, 100, 99, 113, 114, __, 105, 117, __, 97, 108    Using modulo 11 arithmetic and linear probing gives these values      100, 113, 117, 97, 14, 108, 121, 105, 99, __, __    It looks like you are using modulo 10 arithmetic, use the table size.      117, 114, 108, 121, 105, 99, __, __, 97, 100, 113    Be careful to use modulo not integer division.    "
},
{
  "id": "sec-SelfCheck",
  "level": "1",
  "url": "sec-SelfCheck.html",
  "type": "Section",
  "number": "6.6",
  "title": "Self Check",
  "body": " Self Check  Match the method of finding data to its corresponding Big O. Review the analysis of each technique  Linear Search O(n)  Binary Search O(log n)  Hashing O(1)   Drag the search method to the type of data that it is more efficient for compared to the other search method. This is feedback.  Binary Search ordered data  Linear Search unordered data   What creates hash collisions?   when pairs of different hash values are mapped to the same key.  Think about what keys refer to and what hash values refer to    when pairs of different hash values do not share the same key.  Think about what keys refer to and what hash values refer to    when pairs of different keys are mapped to the same hash value.  Correct!    when pairs of different keys do not share the same hash value.  Think about what keys refer to and what hash values refer to    "
},
{
  "id": "bigOSH",
  "level": "2",
  "url": "sec-SelfCheck.html#bigOSH",
  "type": "Checkpoint",
  "number": "6.6.1",
  "title": "",
  "body": "Match the method of finding data to its corresponding Big O. Review the analysis of each technique  Linear Search O(n)  Binary Search O(log n)  Hashing O(1)  "
},
{
  "id": "searchBests",
  "level": "2",
  "url": "sec-SelfCheck.html#searchBests",
  "type": "Checkpoint",
  "number": "6.6.2",
  "title": "",
  "body": "Drag the search method to the type of data that it is more efficient for compared to the other search method. This is feedback.  Binary Search ordered data  Linear Search unordered data  "
},
{
  "id": "hashcollisions",
  "level": "2",
  "url": "sec-SelfCheck.html#hashcollisions",
  "type": "Checkpoint",
  "number": "6.6.3",
  "title": "",
  "body": "What creates hash collisions?   when pairs of different hash values are mapped to the same key.  Think about what keys refer to and what hash values refer to    when pairs of different hash values do not share the same key.  Think about what keys refer to and what hash values refer to    when pairs of different keys are mapped to the same hash value.  Correct!    when pairs of different keys do not share the same hash value.  Think about what keys refer to and what hash values refer to   "
},
{
  "id": "search-hash_summary",
  "level": "1",
  "url": "search-hash_summary.html",
  "type": "Section",
  "number": "6.7",
  "title": "Summary",
  "body": " Summary    A sequential search is for ordered and unordered lists.    A binary search of an ordered list is in the worst case.    Hash tables can provide constant time searching.    "
},
{
  "id": "search-hash_discussion-questions",
  "level": "1",
  "url": "search-hash_discussion-questions.html",
  "type": "Section",
  "number": "6.8",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Using the hash table performance formulas given in the chapter, compute the average number of comparisons necessary when the table is:    10% full    25% full    50% full    75% full    90% full    99% full    At what point do you think the hash table is too small? Explain.    Modify the hash function for strings to use positional weightings.    We used a hash function for strings that weighted the characters by position. Devise an alternative weighting scheme. What are the biases that exist with these functions?    Research perfect hash functions. Using a list of names (classmates, family members, etc.), generate the hash values using the perfect hash algorithm.    "
},
{
  "id": "search-hash_programming-exercises",
  "level": "1",
  "url": "search-hash_programming-exercises.html",
  "type": "Section",
  "number": "6.9",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Set up a random experiment to test the difference between a sequential search and a binary search on a list of integers.    Use the binary search functions given in the text (recursive and iterative). Generate a random, ordered list of integers and do a benchmark analysis for each one. What are your results? Can you explain them?    Implement the binary search using recursion without the slice operator. Recall that you will need to pass the list along with the starting and ending index values for the sublist. Generate a random, ordered list of integers and do a benchmark analysis.    Overload the cout operator (<<) for the hash table Map ADT implementation.    Overload the cin operator (>>) for the hash table Map ADT implementation.    How can you delete items from a hash table that uses chaining for collision resolution? How about if open addressing is used? What are the special circumstances that must be handled? Implement the del (~) operator for the HashTable class.    In the hash table map implementation, the hash table size was chosen to be 101. If the table gets full, this needs to be increased. Re-implement the put method so that the table will automatically resize itself when the loading factor reaches a predetermined value (you can decide the value based on your assessment of load versus performance).    Implement quadratic probing as a rehash technique.    Using a random number generator, create a list of 500 integers. Perform a benchmark analysis using some of the sorting algorithms from this chapter. What is the difference in execution speed?    Implement the bubble sort using simultaneous assignment.    A bubble sort can be modified to bubble in both directions. The first pass moves up the list, and the second pass moves down. This alternating pattern continues until no more passes are necessary. Implement this variation and describe under what circumstances it might be appropriate.    Implement the selection sort using simultaneous assignment.    Perform a benchmark analysis for a shell sort, using different increment sets on the same vector.    One way to improve the quick sort is to use an insertion sort on lists that have a small length (call it the partition limit ). Why does this make sense? Re-implement the quick sort and use it to sort a random list of integers. Perform an analysis using different list sizes for the partition limit.    Implement the median-of-three method for selecting a pivot value as a modification to quickSort . Run an experiment to compare the two techniques.    "
},
{
  "id": "search-hash_glossary",
  "level": "1",
  "url": "search-hash_glossary.html",
  "type": "Section",
  "number": "6.10",
  "title": "Glossary",
  "body": " Glossary    binary search  search method in which one repeatedly divides a sorted data structure in half and determines if the item is in one half of it until the item is found or deemed not in the data.    chaining  a method of collision resolution in which each slot in a hash table holds a reference to a collection of items.    collision  a conflict of having two or more items sharing the same slot in a hash table.    collision resolution  a systematic method for resolving hash table collisions.    clustering  items being mapped in a hash table near each other because of collisions and linear probing resulting in items with collisions being put together.    folding method  a method for constructing a hash function by dividing the item into equally sized pieces and then adding the pieces together to get a hash value. The value is then divided by the size of the hash table and the remainder becomes the slot for that item.    hashing  generating a value given an input that can be used to find the input by searching for the value.    hash function  the mapping between an item and its slot in a hash table.    hash table  a collection of items which are stored in such a away as to make it easy to find them.    linear probing  an open addressing technique in which each slot is visited one at a time systematically.    load factor  Represents how full a hash table is. Its the number of items in a hash table divided by the size of the table.    map  an associate data type that stores key-data pairs.    mid-square method  a method for constructing a hash function by squaring the item and then using some portion of the result.    open addressing  a collision resolution that tries to find the next open slot\/address in the hash table.    perfect hash function  a hash function that maps each item to a unique hash slot.    quadratic probing  a variation of linear probing in which rehashing is done using successive squared values.    rehashing  putting an item into a hash table after a collision.    searching  the algorithmic process of finding a particular item in a collection of items.    sequential search  search method in which one follows the underlying ordering of items in a collection of data to find a specific item.    slot  a position in a hash table.    "
},
{
  "id": "searchhash_search-hash_matching",
  "level": "1",
  "url": "searchhash_search-hash_matching.html",
  "type": "Section",
  "number": "6.11",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition   Review classes and their properties    binary search  One repeatedly divides a sorted data structure in half and determines if the item is in one half of it until the item is found or deemed not in the data.    load factor  Its the number of items in a hash table divided by the size of the table.    map  Associate data type that stores key-data pairs    mid-square method  Method for constructing a hash function by squaring the item and then using some portion of the result.    open addressing  Collision resolution that tries to find the next open slot\/address in the hash table.    perfect hash function  Hash function that maps each item to a unique hash slot.    quadratic probing  Variation of linear probing in which rehashing is done using successive squared values.    rehashing  Putting an item into a hash table after a collision.    searching  Algorithmic process of finding a particular item in a collection of items.    sequential search  Search method in which one follows the underlying ordering of items in a collection of data to find a specific item.    slot  Position in a hash table.    chaining  Collision resolution method, in which each slot in a hash table holds a reference to a collection of items.    collision  Having two or more items sharing the same slot in a hash table.    collision resolution  Systematic method for solving hash table collisions.    clustering  Items being mapped in a hash table near each other resulting in items with collisions being put together.    folding method  Constructing a hash function by dividing the item into equally sized pieces, adding the pieces together to get a hash value, dividing by the size of the hash table, and the remainder becomes the slot for that item.    hashing  Creating a value for an input that can be used to find the input by searching for the value.    hash function  Mapping between an item and its slot in a hash table    linear probing  Open addressing technique in which each slot is visited one at a time systematically.    "
},
{
  "id": "matching_searchhash",
  "level": "2",
  "url": "searchhash_search-hash_matching.html#matching_searchhash",
  "type": "Checkpoint",
  "number": "6.11.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition   Review classes and their properties    binary search  One repeatedly divides a sorted data structure in half and determines if the item is in one half of it until the item is found or deemed not in the data.    load factor  Its the number of items in a hash table divided by the size of the table.    map  Associate data type that stores key-data pairs    mid-square method  Method for constructing a hash function by squaring the item and then using some portion of the result.    open addressing  Collision resolution that tries to find the next open slot\/address in the hash table.    perfect hash function  Hash function that maps each item to a unique hash slot.    quadratic probing  Variation of linear probing in which rehashing is done using successive squared values.    rehashing  Putting an item into a hash table after a collision.    searching  Algorithmic process of finding a particular item in a collection of items.    sequential search  Search method in which one follows the underlying ordering of items in a collection of data to find a specific item.    slot  Position in a hash table.    chaining  Collision resolution method, in which each slot in a hash table holds a reference to a collection of items.    collision  Having two or more items sharing the same slot in a hash table.    collision resolution  Systematic method for solving hash table collisions.    clustering  Items being mapped in a hash table near each other resulting in items with collisions being put together.    folding method  Constructing a hash function by dividing the item into equally sized pieces, adding the pieces together to get a hash value, dividing by the size of the hash table, and the remainder becomes the slot for that item.    hashing  Creating a value for an input that can be used to find the input by searching for the value.    hash function  Mapping between an item and its slot in a hash table    linear probing  Open addressing technique in which each slot is visited one at a time systematically.   "
},
{
  "id": "sort_objectives",
  "level": "1",
  "url": "sort_objectives.html",
  "type": "Section",
  "number": "7.1",
  "title": "Objectives",
  "body": " Objectives    To be able to explain and implement selection sort, bubble sort, merge sort, quick sort, insertion sort, and shell sort.    "
},
{
  "id": "sort_sorting",
  "level": "1",
  "url": "sort_sorting.html",
  "type": "Section",
  "number": "7.2",
  "title": "Sorting",
  "body": " Sorting  sorting Sorting is the process of placing elements from a collection in some kind of order. For example, a list of words could be sorted alphabetically or by length. A list of cities could be sorted by population, by area, or by zip code. We have already seen a number of algorithms that were able to benefit from having a sorted list (recall the final anagram example and the binary search).  There are many, many sorting algorithms that have been developed and analyzed. This suggests that sorting is an important area of study in computer science. Sorting a large number of items can take a substantial amount of computing resources. Like searching, the efficiency of a sorting algorithm is related to the number of items being processed. For small collections, a complex sorting method may be more trouble than it's worth. The overhead may be too high. On the other hand, for larger collections, we want to take advantage of as many improvements as possible. In this section we will discuss several sorting techniques and compare them with respect to their running time.  Before getting into specific algorithms, we should think about the operations that can be used to analyze a sorting process. First, it will be necessary to compare two values to see which is smaller (or larger). In order to sort a collection, it will be necessary to have some systematic way to compare values to see if they are out of order. The total number of comparisons will be the most common way to measure a sort procedure. Second, when values are not in the correct position with respect to one another, it may be necessary to exchange them. This exchange is a costly operation and the total number of exchanges will also be important for evaluating the overall efficiency of the algorithm.  "
},
{
  "id": "sort_sorting-2",
  "level": "2",
  "url": "sort_sorting.html#sort_sorting-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Sorting "
},
{
  "id": "sort_the-bubble-sort",
  "level": "1",
  "url": "sort_the-bubble-sort.html",
  "type": "Section",
  "number": "7.3",
  "title": "The Bubble Sort",
  "body": " The Bubble Sort  The bubble sort makes multiple passes through an array. It compares adjacent items and exchanges those that are out of order. Each pass through the array places the next largest value in its proper place. In essence, each item bubbles up to the location where it belongs.  shows the first pass of a bubble sort. The shaded items are being compared to see if they are out of order. If there are n items in the array, then there are pairs of items that need to be compared on the first pass. It is important to note that once the largest value in the array is part of a pair, it will continually be moved along until the pass is complete.   BubbleSort The First Pass.   Illustration of bubble sort algorithm during the first pass. A series of arrays showing the step-by-step process of sorting numbers in ascending order. Starting with the array [54, 26, 93, 17, 77, 31, 44, 55, 20], subsequent arrays demonstrate swapping of elements, marked as 'Exchange', or retention of position, marked as 'No Exchange', to progressively move the highest number, 93, to the correct position at the end of the array after the first pass. The final array in the sequence is [26, 54, 17, 77, 31, 44, 55, 20, 93], with the note '93 in place after first pass' indicating the completion of this sorting stage.    At the start of the second pass, the largest value is now in place. There are items left to sort, meaning that there will be pairs. Since each pass places the next largest value in place, the total number of passes necessary will be . After completing the passes, the smallest item must be in the correct position with no further processing required. shows the complete bubbleSort function. It takes the array as a parameter, and modifies it by swapping items as necessary.  Typically, swapping two elements in an array requires a temporary storage location (an additional memory location). A code fragment such as  temp = alist[i]; alist[i] = alist[j]; alist[j] = temp;  will exchange the ith and jth items in the array. Without the temporary storage, one of the values would be overwritten.  Lines 5-7 in perform the exchange of the and items using the three–step procedure described earlier. Note that we could also have used the simultaneous assignment to swap the items.   Exchanging Two Values in Python.   A diagram explaining the process of exchanging two values in a programming language with an extra storage location, compared to Python where exchange can be done with two simultaneous assignments. The upper part of the image shows two array elements labeled 'i' and 'j' with values 93 and 44, and a 'temp' variable used for the 3-step swap process. The lower part shows the simplified Python method where the values 93 and 44 are swapped in place without needing a temporary storage variable.    The following activecode example shows the complete bubbleSort function working on the array shown above.   Bubble Sort Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function goes through list sorting adjacent values as it bubbles \/\/the largest value to the top. vector<int> bubbleSort(vector<int> avector) { \/\/the vector for bubble sort for (int passnum = avector.size()-1; passnum > 0; passnum -= 1) { for (int i = 0; i < passnum; i++) { if (avector[i] > avector[i+1]) { int temp = avector[i]; avector[i] = avector[i+1]; avector[i+1] = temp; } } } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54,26,93,17,77,31,44,55,20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); vector<int> bvector = bubbleSort(avector); for (unsigned int i = 0; i < bvector.size(); i++) { cout<<bvector[i]<< \" \"; } return 0; }  Python Implementation \"\"\"function goes through list sorting adjacent values as it bubbles the largest value to the top.\"\"\" def bubbleSort(alist): for passnum in range(len(alist)-1,0,-1): for i in range(passnum): if alist[i]>alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp def main(): alist = [54,26,93,17,77,31,44,55,20] bubbleSort(alist) print(alist) main()   The visualization in allows you to step through the algorithm. Red bars represent the elements being looked at.   Bubblesort animation.    The video in shows bubbleSort in action. The sort compares two items at a time (shown in blue). Once it finds two out of place blocks it will find the correct place for the smaller block and then reset for another pass.   Video of insertionSort in action.    To analyze the bubble sort, we should note that regardless of how the items are arranged in the initial array, passes will be made to sort an array of size n . shows the number of comparisons for each pass. The total number of comparisons is the sum of the first integers. Recall that the sum of the first n integers is . The sum of the first integers is , which is . This is still comparisons. In the best case, if the array is already ordered, no exchanges will be made. However, in the worst case, every comparison will cause an exchange. On average, we exchange half of the time.   Comparisons for Each Pass of Bubble Sort    Pass    Comparisons     1       2       3       …  …            A bubble sort is often considered the most inefficient sorting method since it must exchange items before the final location is known. These wasted exchange operations are very costly. However, because the bubble sort makes passes through the entire unsorted portion of the array, it has the capability to do something most sorting algorithms cannot. In particular, if during a pass there are no exchanges, then we know that the array must be sorted. A bubble sort can be modified to stop early if it finds that the array has become sorted. This means that for arrays that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted array and stop. shows this modification, which is often referred to as the short bubble .   Short Bubbles Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; vector<int> shortBubbleSort(vector<int> avector){ \/\/the vector for bubble sort bool exchanges = true; int passnum = avector.size(); \/\/while vector size is greater than 0 and exchanges = true while (passnum > 0 && exchanges) { exchanges = false; \/\/loops through vector, exchanging values until it reaches the end of vector. for(int i = 0; i < passnum; i++){ if(avector[i] > avector[i+1]){ exchanges = true; int temp = avector[i]; avector[i] = avector[i+1]; avector[i+1] = temp; } } \/\/subtracts from the passnum variable so that the next passthrough is one less \/\/than the previous, because the largest value has already 'bubbled' all the way up. passnum = passnum - 1; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {20,30,40,90,50,60,70,80,110,100}; vector<int> avector (arr, arr+ sizeof(arr)\/sizeof(arr[0])); \/\/intializes vector vector<int> bvector = shortBubbleSort(avector); for(unsigned int i = 0; i < bvector.size(); i++){ cout<< bvector[i] << \" \"; } return 0; }  Python Implementation def shortBubbleSort(alist): exchanges = True passnum = len(alist)-1 while passnum > 0 and exchanges: exchanges = False for i in range(passnum): if alist[i]>alist[i+1]: exchanges = True temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp \"\"\"subtracts from the passnum variable so that the next passthrough is one less than the previous, because the largest value has already 'bubbled' all the way up\"\"\" passnum = passnum-1 alist=[20,30,40,90,50,60,70,80,100,110] shortBubbleSort(alist) print(alist)                          Suppose you have the following array of numbers to sort: [19, 1, 9, 7, 3, 10, 13, 15, 8, 12]. Which array represents the partially sorted list after three complete passes of bubble sort?     [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]    This answer represents three swaps. A pass means that you continue swapping all the way to the end of the list.      [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]    Very Good      [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]    A bubble sort contines to swap numbers up to index position passnum. But remember that passnum starts at the length of the list - 1.      [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]    You have been doing an insertion sort, not a bubble sort.      "
},
{
  "id": "sort_the-bubble-sort-2",
  "level": "2",
  "url": "sort_the-bubble-sort.html#sort_the-bubble-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "bubble sort "
},
{
  "id": "fig-bubblepass",
  "level": "2",
  "url": "sort_the-bubble-sort.html#fig-bubblepass",
  "type": "Figure",
  "number": "7.3.1",
  "title": "",
  "body": " BubbleSort The First Pass.   Illustration of bubble sort algorithm during the first pass. A series of arrays showing the step-by-step process of sorting numbers in ascending order. Starting with the array [54, 26, 93, 17, 77, 31, 44, 55, 20], subsequent arrays demonstrate swapping of elements, marked as 'Exchange', or retention of position, marked as 'No Exchange', to progressively move the highest number, 93, to the correct position at the end of the array after the first pass. The final array in the sequence is [26, 54, 17, 77, 31, 44, 55, 20, 93], with the note '93 in place after first pass' indicating the completion of this sorting stage.   "
},
{
  "id": "fig-pythonswap",
  "level": "2",
  "url": "sort_the-bubble-sort.html#fig-pythonswap",
  "type": "Figure",
  "number": "7.3.2",
  "title": "",
  "body": " Exchanging Two Values in Python.   A diagram explaining the process of exchanging two values in a programming language with an extra storage location, compared to Python where exchange can be done with two simultaneous assignments. The upper part of the image shows two array elements labeled 'i' and 'j' with values 93 and 44, and a 'temp' variable used for the 3-step swap process. The lower part shows the simplified Python method where the values 93 and 44 are swapped in place without needing a temporary storage variable.   "
},
{
  "id": "expl-lst-bubble",
  "level": "2",
  "url": "sort_the-bubble-sort.html#expl-lst-bubble",
  "type": "Exploration",
  "number": "7.3.1",
  "title": "Bubble Sort Implementation.",
  "body": " Bubble Sort Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function goes through list sorting adjacent values as it bubbles \/\/the largest value to the top. vector<int> bubbleSort(vector<int> avector) { \/\/the vector for bubble sort for (int passnum = avector.size()-1; passnum > 0; passnum -= 1) { for (int i = 0; i < passnum; i++) { if (avector[i] > avector[i+1]) { int temp = avector[i]; avector[i] = avector[i+1]; avector[i+1] = temp; } } } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54,26,93,17,77,31,44,55,20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); vector<int> bvector = bubbleSort(avector); for (unsigned int i = 0; i < bvector.size(); i++) { cout<<bvector[i]<< \" \"; } return 0; }  Python Implementation \"\"\"function goes through list sorting adjacent values as it bubbles the largest value to the top.\"\"\" def bubbleSort(alist): for passnum in range(len(alist)-1,0,-1): for i in range(passnum): if alist[i]>alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp def main(): alist = [54,26,93,17,77,31,44,55,20] bubbleSort(alist) print(alist) main()  "
},
{
  "id": "sort_bubblesort-animation",
  "level": "2",
  "url": "sort_the-bubble-sort.html#sort_bubblesort-animation",
  "type": "Figure",
  "number": "7.3.3",
  "title": "",
  "body": " Bubblesort animation.   "
},
{
  "id": "sort_bubble-video",
  "level": "2",
  "url": "sort_the-bubble-sort.html#sort_bubble-video",
  "type": "Figure",
  "number": "7.3.4",
  "title": "",
  "body": " Video of insertionSort in action.   "
},
{
  "id": "sort_tbl-bubbleanalysis",
  "level": "2",
  "url": "sort_the-bubble-sort.html#sort_tbl-bubbleanalysis",
  "type": "Table",
  "number": "7.3.5",
  "title": "",
  "body": " Comparisons for Each Pass of Bubble Sort    Pass    Comparisons     1       2       3       …  …           "
},
{
  "id": "sort_the-bubble-sort-19",
  "level": "2",
  "url": "sort_the-bubble-sort.html#sort_the-bubble-sort-19",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "short bubble "
},
{
  "id": "expl-shortbubbles",
  "level": "2",
  "url": "sort_the-bubble-sort.html#expl-shortbubbles",
  "type": "Exploration",
  "number": "7.3.2",
  "title": "Short Bubbles Implementation.",
  "body": " Short Bubbles Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; vector<int> shortBubbleSort(vector<int> avector){ \/\/the vector for bubble sort bool exchanges = true; int passnum = avector.size(); \/\/while vector size is greater than 0 and exchanges = true while (passnum > 0 && exchanges) { exchanges = false; \/\/loops through vector, exchanging values until it reaches the end of vector. for(int i = 0; i < passnum; i++){ if(avector[i] > avector[i+1]){ exchanges = true; int temp = avector[i]; avector[i] = avector[i+1]; avector[i+1] = temp; } } \/\/subtracts from the passnum variable so that the next passthrough is one less \/\/than the previous, because the largest value has already 'bubbled' all the way up. passnum = passnum - 1; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {20,30,40,90,50,60,70,80,110,100}; vector<int> avector (arr, arr+ sizeof(arr)\/sizeof(arr[0])); \/\/intializes vector vector<int> bvector = shortBubbleSort(avector); for(unsigned int i = 0; i < bvector.size(); i++){ cout<< bvector[i] << \" \"; } return 0; }  Python Implementation def shortBubbleSort(alist): exchanges = True passnum = len(alist)-1 while passnum > 0 and exchanges: exchanges = False for i in range(passnum): if alist[i]>alist[i+1]: exchanges = True temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp \"\"\"subtracts from the passnum variable so that the next passthrough is one less than the previous, because the largest value has already 'bubbled' all the way up\"\"\" passnum = passnum-1 alist=[20,30,40,90,50,60,70,80,100,110] shortBubbleSort(alist) print(alist)  "
},
{
  "id": "question_sort_1",
  "level": "2",
  "url": "sort_the-bubble-sort.html#question_sort_1",
  "type": "Reading Question",
  "number": "7.3.1",
  "title": "",
  "body": " Suppose you have the following array of numbers to sort: [19, 1, 9, 7, 3, 10, 13, 15, 8, 12]. Which array represents the partially sorted list after three complete passes of bubble sort?     [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]    This answer represents three swaps. A pass means that you continue swapping all the way to the end of the list.      [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]    Very Good      [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]    A bubble sort contines to swap numbers up to index position passnum. But remember that passnum starts at the length of the list - 1.      [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]    You have been doing an insertion sort, not a bubble sort.    "
},
{
  "id": "sort_the-selection-sort",
  "level": "1",
  "url": "sort_the-selection-sort.html",
  "type": "Section",
  "number": "7.4",
  "title": "The Selection Sort",
  "body": " The Selection Sort  selection sort The selection sort improves on the bubble sort by making only one exchange for every pass through the first part of the vector. We will call this a step. In order to do this, a selection sort looks for the largest value as it makes a partial pass and, after completing the partial pass, places it in the proper location, ending the step. As with a bubble sort, after the first step, the largest item is in the correct place. After the second step, the next largest is in place. This process continues and requires steps to sort n items, since the final item must be in place after the step.  On each step, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. The function is shown in .   Selection Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function that sorts through values in vector through selection sort vector<int> selectionSort(vector<int> avector) { for (int fillslot = (avector.size() - 1); fillslot >= 0; fillslot--) { int positionOfMax = 0; for (int location = 1; location < fillslot + 1; location++) { if (avector[location] > avector[positionOfMax]) { positionOfMax = location; } } int temp = avector[fillslot]; avector[fillslot] = avector[positionOfMax]; avector[positionOfMax] = temp; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); \/\/ Call to the selectionSort function vector<int> updatedAvector = selectionSort(avector); \/\/ print the vector for (unsigned int i = 0; i < updatedAvector.size(); i++) { cout << updatedAvector[i] << \" \"; } cout << endl; return 0; }  Python Implementation #function sorts through values in list using selection sort def selectionSort(alist): for fillslot in range(len(alist)-1,0,-1): positionOfMax=0 for location in range(1,fillslot+1): if alist[location]>alist[positionOfMax]: positionOfMax = location temp = alist[fillslot] alist[fillslot] = alist[positionOfMax] alist[positionOfMax] = temp def main(): alist = [54,26,93,17,77,31,44,55,20] selectionSort(alist) print(alist) main()   The visualization in allows you to step through the algorithm. Yellow bars represent the current element, red represents the element being looked at, and blue represents the last element to look at during a step.   Selection esort animation.    The video in shows selection sort in action. Each pass compares the bars in sequential order. The smallest bar is selected on each pass and is set as the minimum, represented in orange. Every remaining bar is then compared to the minimum. If the bar is larger, it is represented in blue, if it is smaller, it becomes the new orange bar. After each pass, a counter will increment which bar in our container will start with. This increment is representedby a thin black line falling before the bar to be started at.   Video of selectionSort in action.    You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also . However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies.    Suppose you have the following vector of numbers to sort: [11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which vector represents the partially sorted (ascending) vector after three steps of selection sort?     [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]    Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps      [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]    This looks like an insertion sort.      [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]    This one looks similar to the correct answer, however, it is not how selection sort works. With this answer, instead of swapping values through each sweep, the values have been shifted to the left to make room for the correct numbers.      [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]    Selection sort improves upon bubble sort by making fewer swaps.      "
},
{
  "id": "sort_the-selection-sort-2",
  "level": "2",
  "url": "sort_the-selection-sort.html#sort_the-selection-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "selection sort "
},
{
  "id": "expl-selectionsort",
  "level": "2",
  "url": "sort_the-selection-sort.html#expl-selectionsort",
  "type": "Exploration",
  "number": "7.4.1",
  "title": "Selection Sort.",
  "body": " Selection Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function that sorts through values in vector through selection sort vector<int> selectionSort(vector<int> avector) { for (int fillslot = (avector.size() - 1); fillslot >= 0; fillslot--) { int positionOfMax = 0; for (int location = 1; location < fillslot + 1; location++) { if (avector[location] > avector[positionOfMax]) { positionOfMax = location; } } int temp = avector[fillslot]; avector[fillslot] = avector[positionOfMax]; avector[positionOfMax] = temp; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); \/\/ Call to the selectionSort function vector<int> updatedAvector = selectionSort(avector); \/\/ print the vector for (unsigned int i = 0; i < updatedAvector.size(); i++) { cout << updatedAvector[i] << \" \"; } cout << endl; return 0; }  Python Implementation #function sorts through values in list using selection sort def selectionSort(alist): for fillslot in range(len(alist)-1,0,-1): positionOfMax=0 for location in range(1,fillslot+1): if alist[location]>alist[positionOfMax]: positionOfMax = location temp = alist[fillslot] alist[fillslot] = alist[positionOfMax] alist[positionOfMax] = temp def main(): alist = [54,26,93,17,77,31,44,55,20] selectionSort(alist) print(alist) main()  "
},
{
  "id": "sort_selectionsort-animation",
  "level": "2",
  "url": "sort_the-selection-sort.html#sort_selectionsort-animation",
  "type": "Figure",
  "number": "7.4.1",
  "title": "",
  "body": " Selection esort animation.   "
},
{
  "id": "sort_selection-video",
  "level": "2",
  "url": "sort_the-selection-sort.html#sort_selection-video",
  "type": "Figure",
  "number": "7.4.2",
  "title": "",
  "body": " Video of selectionSort in action.   "
},
{
  "id": "question_sort_2",
  "level": "2",
  "url": "sort_the-selection-sort.html#question_sort_2",
  "type": "Reading Question",
  "number": "7.4.1",
  "title": "",
  "body": " Suppose you have the following vector of numbers to sort: [11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which vector represents the partially sorted (ascending) vector after three steps of selection sort?     [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]    Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps      [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]    This looks like an insertion sort.      [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]    This one looks similar to the correct answer, however, it is not how selection sort works. With this answer, instead of swapping values through each sweep, the values have been shifted to the left to make room for the correct numbers.      [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]    Selection sort improves upon bubble sort by making fewer swaps.    "
},
{
  "id": "sort_the-insertion-sort",
  "level": "1",
  "url": "sort_the-insertion-sort.html",
  "type": "Section",
  "number": "7.5",
  "title": "The Insertion Sort",
  "body": " The Insertion Sort  insertion sort The insertion sort , although still , works in a slightly different way. It always maintains a sorted subvector in the lower positions of the vector. Each new item is then inserted back into the previous subvector such that the sorted subvector is one item larger. shows the insertion sorting process. The shaded items represent the ordered subvectors as the algorithm makes each pass.   InsertionSort.   A step-by-step visual representation of the insertion sort algorithm. The image shows a series of rows with numbers in boxes, illustrating the process of sorting the numbers in ascending order. Each row represents a step in the algorithm, with the text on the right indicating the action taken, such as 'inserted 26' or 'inserted 93'. The sequence begins with the numbers 54, 26, 93, and so on, and gradually transforms into a sorted sequence from left to right as the algorithm progresses. The caption 'Figure 7.5.1. insertionSort' is placed below the image.    We begin by assuming that a vector with one item (position ) is already sorted. On each pass, one for each item 1 through , the current item is checked against those in the already sorted subvector. As we look back into the already sorted subvector, we shift those items that are greater to the right. When we reach a smaller item or the end of the subvector, the current item can be inserted.  shows the fifth pass in detail. At this point in the algorithm, a sorted subvector of five items consisting of 17, 26, 54, 77, and 93 exists. We want to insert 31 back into the already sorted items. The first comparison against 93 causes 93 to be shifted to the right. 77 and 54 are also shifted. When the item 26 is encountered, the shifting process stops and 31 is placed in the open position. Now we have a sorted subvector of six items.   InsertionSort : Fifth Pass of the Sort.   An educational illustration depicting the fifth pass of the insertion sort algorithm. The diagram shows a series of rows with numerical values in boxes, each row representing a step in the sorting process. Arrows indicate the shifting of numbers to make space for the correctly positioned value. Descriptive text accompanies each step explaining the movement required, such as '93>31 so shift it to the right' and 'Need to insert 31 back into the sorted list'. The final row shows the number 31 being inserted into its correct position in the sequence.    The implementation of insertionSort ( ) shows that there are again passes to sort n items. The iteration starts at position 1 and moves through position , as these are the items that need to be inserted back into the sorted subvectors. Line 8 performs the shift operation that moves a value up one position in the vector, making room behind it for the insertion. Remember that this is not a complete exchange as was performed in the previous algorithms.  The maximum number of comparisons for an insertion sort is the sum of the first integers. Again, this is . However, in the best case, only one comparison needs to be done on each pass. This would be the case for an already sorted vector.  One note about shifting versus exchanging is also important. In general, a shift operation requires approximately a third of the processing work of an exchange since only one assignment is performed. In benchmark studies, insertion sort will show very good performance.   Insertion Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; vector<int> insertionSort(vector<int> avector) { for (unsigned int index=1; index<avector.size(); index++) { int currentvalue = avector[index]; int position = index; while (position>0 && avector[position-1]>currentvalue) { avector[position] = avector[position-1]; position--; } avector[position] = currentvalue; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); avector = insertionSort(avector); \/\/prints the sorted vector for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \";; } cout << endl; return 0; }  Python Implementation def insertionSort(alist): #function that insertsorts through the list for index in range(1,len(alist)): currentvalue = alist[index] position = index while position>0 and alist[position-1]>currentvalue: alist[position]=alist[position-1] position = position-1 alist[position]=currentvalue def main(): alist = [54,26,93,17,77,31,44,55,20] insertionSort(alist) print(alist) main()   The visualization in allows you to step through the algorithm. Red bars represent the element being looked at and blue represents the last element to look at during a pass.   Insertion animation.    The video in allows you to examine the individual steps of the algorithm at a slower pace. Bars that are orange indicate that it is being compared to items to the left. Bars that are blue indicate that it is one of the items currently being compared against the orange bar.   Video of insertionSort in action.      Suppose you have the following list of numbers to sort:[15, 5, 4, 18, 12, 19, 14, 10, 8, 20] which list represents the partially sorted list after three complete passes of insertion sort?     [4, 5, 12, 15, 14, 10, 8, 18, 19, 20]    This is the result of bubble sort.      [15, 5, 4, 10, 12, 8, 14, 18, 19, 20]    This is the result of selection sort.      [4, 5, 15, 18, 12, 19, 14, 10, 8, 20]    Insertion sort works at the start of the list. Each pass produces a longer sorted list.      [15, 5, 4, 18, 12, 19, 14, 8, 10, 20]    Insertion sort works on the front of the list not the end.      "
},
{
  "id": "sort_the-insertion-sort-2",
  "level": "2",
  "url": "sort_the-insertion-sort.html#sort_the-insertion-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "insertion sort "
},
{
  "id": "fig-insertionsort",
  "level": "2",
  "url": "sort_the-insertion-sort.html#fig-insertionsort",
  "type": "Figure",
  "number": "7.5.1",
  "title": "",
  "body": " InsertionSort.   A step-by-step visual representation of the insertion sort algorithm. The image shows a series of rows with numbers in boxes, illustrating the process of sorting the numbers in ascending order. Each row represents a step in the algorithm, with the text on the right indicating the action taken, such as 'inserted 26' or 'inserted 93'. The sequence begins with the numbers 54, 26, 93, and so on, and gradually transforms into a sorted sequence from left to right as the algorithm progresses. The caption 'Figure 7.5.1. insertionSort' is placed below the image.   "
},
{
  "id": "fig-insertionpass",
  "level": "2",
  "url": "sort_the-insertion-sort.html#fig-insertionpass",
  "type": "Figure",
  "number": "7.5.2",
  "title": "",
  "body": " InsertionSort : Fifth Pass of the Sort.   An educational illustration depicting the fifth pass of the insertion sort algorithm. The diagram shows a series of rows with numerical values in boxes, each row representing a step in the sorting process. Arrows indicate the shifting of numbers to make space for the correctly positioned value. Descriptive text accompanies each step explaining the movement required, such as '93>31 so shift it to the right' and 'Need to insert 31 back into the sorted list'. The final row shows the number 31 being inserted into its correct position in the sequence.   "
},
{
  "id": "expl-insertionsort",
  "level": "2",
  "url": "sort_the-insertion-sort.html#expl-insertionsort",
  "type": "Exploration",
  "number": "7.5.1",
  "title": "Insertion Sort.",
  "body": " Insertion Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; vector<int> insertionSort(vector<int> avector) { for (unsigned int index=1; index<avector.size(); index++) { int currentvalue = avector[index]; int position = index; while (position>0 && avector[position-1]>currentvalue) { avector[position] = avector[position-1]; position--; } avector[position] = currentvalue; } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); avector = insertionSort(avector); \/\/prints the sorted vector for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \";; } cout << endl; return 0; }  Python Implementation def insertionSort(alist): #function that insertsorts through the list for index in range(1,len(alist)): currentvalue = alist[index] position = index while position>0 and alist[position-1]>currentvalue: alist[position]=alist[position-1] position = position-1 alist[position]=currentvalue def main(): alist = [54,26,93,17,77,31,44,55,20] insertionSort(alist) print(alist) main()  "
},
{
  "id": "sort_insertionsort-animation",
  "level": "2",
  "url": "sort_the-insertion-sort.html#sort_insertionsort-animation",
  "type": "Figure",
  "number": "7.5.3",
  "title": "",
  "body": " Insertion animation.   "
},
{
  "id": "sort_insertion-video",
  "level": "2",
  "url": "sort_the-insertion-sort.html#sort_insertion-video",
  "type": "Figure",
  "number": "7.5.4",
  "title": "",
  "body": " Video of insertionSort in action.   "
},
{
  "id": "question_sort_3",
  "level": "2",
  "url": "sort_the-insertion-sort.html#question_sort_3",
  "type": "Reading Question",
  "number": "7.5.1",
  "title": "",
  "body": " Suppose you have the following list of numbers to sort:[15, 5, 4, 18, 12, 19, 14, 10, 8, 20] which list represents the partially sorted list after three complete passes of insertion sort?     [4, 5, 12, 15, 14, 10, 8, 18, 19, 20]    This is the result of bubble sort.      [15, 5, 4, 10, 12, 8, 14, 18, 19, 20]    This is the result of selection sort.      [4, 5, 15, 18, 12, 19, 14, 10, 8, 20]    Insertion sort works at the start of the list. Each pass produces a longer sorted list.      [15, 5, 4, 18, 12, 19, 14, 8, 10, 20]    Insertion sort works on the front of the list not the end.    "
},
{
  "id": "sort_the-shell-sort",
  "level": "1",
  "url": "sort_the-shell-sort.html",
  "type": "Section",
  "number": "7.6",
  "title": "The Shell Sort",
  "body": " The Shell Sort  shell sort The shell sort , sometimes called the diminishing increment sort, improves on the insertion sort by breaking the original vector into a number of smaller subvectors, each of which is sorted using an insertion sort. The unique way that these subvectors are chosen is the key to the shell sort. Instead of breaking the vector into subvectors of contiguous items, the shell sort uses an increment i , sometimes called the gap , to create a subvector by choosing all items that are i items apart.  This can be seen in . This vector has nine items. If we use an increment of three, there are three subvectors, each of which can be sorted by an insertion sort. After completing these sorts, we get the vector shown in . Although this vector is not completely sorted, something very interesting has happened. By sorting the subvectors, we have moved the items closer to where they actually belong.   A Shell Sort with Increments of Three   Visual diagram showing three rows of numbers representing sublists in the Shell Sort algorithm with increments of three. Each row contains the same sequence of numbers: 54, 26, 93, 17, 77, 31, 44, 55, 20, categorized into 'sublist 1', 'sublist 2', and 'sublist 3'. This illustrates the initial stage of Shell Sort where the list is divided into sublists based on a specific increment, in this case, three, to be sorted individually.     A Shell Sort after Sorting Each subvector   Illustration of a Shell Sort algorithm after sorting each subvector. Three rows of numbers in boxes, each labeled as 'sublist 1 sorted', 'sublist 2 sorted', and 'sublist 3 sorted', show the partial sorting within each sublist. Arrows point downwards from these sublists to a final sorted row, demonstrating the result of combining the sorted sublists at increment 3. The numbers in the final row are more ordered compared to the original sublists above.    shows a final insertion sort using an increment of one; in other words, a standard insertion sort. Note that by performing the earlier subvector sorts, we have now reduced the total number of shifting operations necessary to put the vector in its final order. For this case, we need only four more shifts to complete the process.   ShellSort: A Final Insertion Sort with Increment of 1   An instructional image of ShellSort's final insertion sort phase with an increment of 1, displaying a series of rows with numerical values in boxes. The top row shows the initial unsorted state of numbers. Subsequent rows depict the sorting process, with arrows indicating the shifting of numbers to insert them into their correct position. Descriptive text such as '1 shift for 20', '2 shifts for 31', and '1 shift for 54' explains the actions taken at each step. The final row shows the numbers in a fully sorted order.     Initial Subvectors for a Shell Sort   The image illustrates the initial division of a list into subvectors for the Shell Sort algorithm. There are four rows of grey boxes, each representing a sublist, labeled from sublist 1 to sublist 4. Inside each row are the same sequence of numbers: 54, 26, 93, 17, 77, 31, 44, 55, 20, indicating the elements that will be sorted within each sublist.    We said earlier that the way in which the increments are chosen is the unique feature of the shell sort. The function shown in uses a different set of increments. In this case, we begin with subvectors. On the next pass, subvectors are sorted. Eventually, a single vector is sorted with the basic insertion sort. shows the first subvectors for our example using this increment.  The following invocation of the shellSort function shows the partially sorted vectors after each increment, with the final sort being an insertion sort with an increment of one.   Shell Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/ print the sorted vector void printl(vector<int> avector) { for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \"; } cout << endl; } \/\/ function returns sorted subvector vector<int> gapInsertionSort(vector<int> avector, int start, int gap) { for (unsigned int i = start + gap; i < avector.size(); i += gap) { int currentvalue = avector[i]; int position = i; while (position >= gap && avector[position - gap] > currentvalue) { avector[position] = avector[position - gap]; position -= gap; } avector[position] = currentvalue; } return avector; } \/\/function shellsorts through the vector vector<int> shellSort(vector<int> avector) { int subvectorcount = avector.size() \/ 2; \/\/cuts vector by half while (subvectorcount > 0) { for (int startposition = 0; startposition < subvectorcount; startposition++) { avector = gapInsertionSort(avector, startposition, subvectorcount);\/* runs avector through gapInsertionSort function *\/ } cout << \"After increments of size \" << subvectorcount << \" The vector is: \" << endl; printl(avector); subvectorcount = subvectorcount \/ 2; \/\/cuts vector in half } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0])); printl(shellSort(avector)); return 0; }  Python Implementation def shellSort(alist): sublistcount = len(alist)\/\/2 while sublistcount > 0: for startposition in range(sublistcount): gapInsertionSort(alist,startposition,sublistcount) print(\"After increments of size\",sublistcount, \"The list is\",alist) sublistcount = sublistcount \/\/ 2 def gapInsertionSort(alist,start,gap): for i in range(start+gap,len(alist),gap): currentvalue = alist[i] position = i while position>=gap and alist[position-gap]>currentvalue: alist[position]=alist[position-gap] position = position-gap alist[position]=currentvalue def main(): alist = [54,26,93,17,77,31,44,55,20] shellSort(alist) print(alist) main()    Shell sort animation.    The video in shows the gap attribute in the form of brown, vertical bars. There are marker arrows that portray the current values being compared during the sort. It finishes by performing a full insertion sort on the full set of bars.   Video of shellSort in action.    At first glance you may think that a shell sort cannot be better than an insertion sort, since it does a complete insertion sort as the last step. It turns out, however, that this final insertion sort does not need to do very many comparisons (or shifts) since the list has been pre-sorted by earlier incremental insertion sorts, as described above. In other words, each pass produces a list that is more sorted than the previous one. This makes the final pass very efficient.  Although a general analysis of the shell sort is well beyond the scope of this text, we can say that it tends to fall somewhere between and , based on the behavior described above. For the increments shown in , the performance is . By changing the increment, for example using (1, 3, 7, 15, 31, and so on), a shell sort can perform at .    Given the following list of numbers: [5, 16, 20, 12, 3, 8, 9, 17, 19, 7], which answer illustrates the contents of the list after all swapping is complete for a gap size of 3?     [5, 3, 8, 7, 16, 19, 9, 17, 20, 12]    Each group of numbers represented by index positions 3 apart are sorted correctly.      [3, 7, 5, 8, 9, 12, 19, 16, 20, 17]    This solution is for a gap size of two.      [3, 5, 7, 8, 9, 12, 16, 17, 19, 20]    This is list completely sorted, you have gone too far.      [5, 16, 20, 3, 8, 12, 9, 17, 20, 7]    The gap size of three indicates that the group represented by every third number e.g. 0, 3, 6, 9 and 1, 4, 7 and 2, 5, 8 are sorted not groups of 3.      "
},
{
  "id": "sort_the-shell-sort-2",
  "level": "2",
  "url": "sort_the-shell-sort.html#sort_the-shell-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "shell sort gap "
},
{
  "id": "fig-incrementsa",
  "level": "2",
  "url": "sort_the-shell-sort.html#fig-incrementsa",
  "type": "Figure",
  "number": "7.6.1",
  "title": "",
  "body": " A Shell Sort with Increments of Three   Visual diagram showing three rows of numbers representing sublists in the Shell Sort algorithm with increments of three. Each row contains the same sequence of numbers: 54, 26, 93, 17, 77, 31, 44, 55, 20, categorized into 'sublist 1', 'sublist 2', and 'sublist 3'. This illustrates the initial stage of Shell Sort where the list is divided into sublists based on a specific increment, in this case, three, to be sorted individually.   "
},
{
  "id": "fig-incrementsb",
  "level": "2",
  "url": "sort_the-shell-sort.html#fig-incrementsb",
  "type": "Figure",
  "number": "7.6.2",
  "title": "",
  "body": " A Shell Sort after Sorting Each subvector   Illustration of a Shell Sort algorithm after sorting each subvector. Three rows of numbers in boxes, each labeled as 'sublist 1 sorted', 'sublist 2 sorted', and 'sublist 3 sorted', show the partial sorting within each sublist. Arrows point downwards from these sublists to a final sorted row, demonstrating the result of combining the sorted sublists at increment 3. The numbers in the final row are more ordered compared to the original sublists above.   "
},
{
  "id": "fig-incrementsc",
  "level": "2",
  "url": "sort_the-shell-sort.html#fig-incrementsc",
  "type": "Figure",
  "number": "7.6.3",
  "title": "",
  "body": " ShellSort: A Final Insertion Sort with Increment of 1   An instructional image of ShellSort's final insertion sort phase with an increment of 1, displaying a series of rows with numerical values in boxes. The top row shows the initial unsorted state of numbers. Subsequent rows depict the sorting process, with arrows indicating the shifting of numbers to insert them into their correct position. Descriptive text such as '1 shift for 20', '2 shifts for 31', and '1 shift for 54' explains the actions taken at each step. The final row shows the numbers in a fully sorted order.   "
},
{
  "id": "fig-incrementsd",
  "level": "2",
  "url": "sort_the-shell-sort.html#fig-incrementsd",
  "type": "Figure",
  "number": "7.6.4",
  "title": "",
  "body": " Initial Subvectors for a Shell Sort   The image illustrates the initial division of a list into subvectors for the Shell Sort algorithm. There are four rows of grey boxes, each representing a sublist, labeled from sublist 1 to sublist 4. Inside each row are the same sequence of numbers: 54, 26, 93, 17, 77, 31, 44, 55, 20, indicating the elements that will be sorted within each sublist.   "
},
{
  "id": "expl-lst-shell",
  "level": "2",
  "url": "sort_the-shell-sort.html#expl-lst-shell",
  "type": "Exploration",
  "number": "7.6.1",
  "title": "Shell Sort.",
  "body": " Shell Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/ print the sorted vector void printl(vector<int> avector) { for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \"; } cout << endl; } \/\/ function returns sorted subvector vector<int> gapInsertionSort(vector<int> avector, int start, int gap) { for (unsigned int i = start + gap; i < avector.size(); i += gap) { int currentvalue = avector[i]; int position = i; while (position >= gap && avector[position - gap] > currentvalue) { avector[position] = avector[position - gap]; position -= gap; } avector[position] = currentvalue; } return avector; } \/\/function shellsorts through the vector vector<int> shellSort(vector<int> avector) { int subvectorcount = avector.size() \/ 2; \/\/cuts vector by half while (subvectorcount > 0) { for (int startposition = 0; startposition < subvectorcount; startposition++) { avector = gapInsertionSort(avector, startposition, subvectorcount);\/* runs avector through gapInsertionSort function *\/ } cout << \"After increments of size \" << subvectorcount << \" The vector is: \" << endl; printl(avector); subvectorcount = subvectorcount \/ 2; \/\/cuts vector in half } return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0])); printl(shellSort(avector)); return 0; }  Python Implementation def shellSort(alist): sublistcount = len(alist)\/\/2 while sublistcount > 0: for startposition in range(sublistcount): gapInsertionSort(alist,startposition,sublistcount) print(\"After increments of size\",sublistcount, \"The list is\",alist) sublistcount = sublistcount \/\/ 2 def gapInsertionSort(alist,start,gap): for i in range(start+gap,len(alist),gap): currentvalue = alist[i] position = i while position>=gap and alist[position-gap]>currentvalue: alist[position]=alist[position-gap] position = position-gap alist[position]=currentvalue def main(): alist = [54,26,93,17,77,31,44,55,20] shellSort(alist) print(alist) main()  "
},
{
  "id": "sort_shellsort-animation",
  "level": "2",
  "url": "sort_the-shell-sort.html#sort_shellsort-animation",
  "type": "Figure",
  "number": "7.6.5",
  "title": "",
  "body": " Shell sort animation.   "
},
{
  "id": "sort_shell-video",
  "level": "2",
  "url": "sort_the-shell-sort.html#sort_shell-video",
  "type": "Figure",
  "number": "7.6.6",
  "title": "",
  "body": " Video of shellSort in action.   "
},
{
  "id": "question_sort_4",
  "level": "2",
  "url": "sort_the-shell-sort.html#question_sort_4",
  "type": "Reading Question",
  "number": "7.6.1",
  "title": "",
  "body": " Given the following list of numbers: [5, 16, 20, 12, 3, 8, 9, 17, 19, 7], which answer illustrates the contents of the list after all swapping is complete for a gap size of 3?     [5, 3, 8, 7, 16, 19, 9, 17, 20, 12]    Each group of numbers represented by index positions 3 apart are sorted correctly.      [3, 7, 5, 8, 9, 12, 19, 16, 20, 17]    This solution is for a gap size of two.      [3, 5, 7, 8, 9, 12, 16, 17, 19, 20]    This is list completely sorted, you have gone too far.      [5, 16, 20, 3, 8, 12, 9, 17, 20, 7]    The gap size of three indicates that the group represented by every third number e.g. 0, 3, 6, 9 and 1, 4, 7 and 2, 5, 8 are sorted not groups of 3.    "
},
{
  "id": "sort_the-merge-sort",
  "level": "1",
  "url": "sort_the-merge-sort.html",
  "type": "Section",
  "number": "7.7",
  "title": "The Merge Sort",
  "body": " The Merge Sort  merge sort We now turn our attention to using a divide and conquer strategy as a way to improve the performance of sorting algorithms. The first algorithm we will study is the merge sort . Merge sort is a recursive algorithm that continually splits a vector in half. If the vector is empty or has one item, it is sorted by definition (the base case). If the vector has more than one item, we split the vector and recursively invoke a merge sort on both halves. Once the two halves are sorted, the fundamental operation, called a merge , is performed. Merging is the process of taking two smaller sorted vectors and combining them together into a single, sorted, new vector. shows our familiar example vector as it is being split by mergeSort . shows the simple vectors, now sorted, as they are merged back together.   Splitting the vector in a Merge Sort.   An illustrative flowchart of the Merge Sort algorithm showing the process of splitting a vector into smaller parts. The chart starts with a single row of numbers at the top: 54, 26, 93, 17, 77, 31, 44, 55, 20, and branches downwards into increasingly smaller groups. Each branch represents a division of the list into two parts, progressively breaking down the numbers into individual elements. The flowchart visually demonstrates how Merge Sort recursively divides a list until each part contains a single element, preparing for the merge phase.     Vectors as They Are Merged Together.   A diagram depicting the merging phase of the Merge Sort algorithm. The flowchart shows the combination of divided vectors into a sorted sequence. It starts with smaller groups of numbers at the top, each sorted individually: 26 and 54, 17 and 93, and so on. These groups are then merged into larger sorted sequences through a series of downward-pointing arrows, indicating the order of merging. The process continues until all numbers are combined into a single sorted list at the bottom: 17, 20, 26, 31, 44, 54, 55, 77, 93.    The mergeSort function shown in begins by asking the base case question. If the length of the vector is less than or equal to one, then we already have a sorted vector and no more processing is necessary. If, on the other hand, the length is greater than one, then we utilize the vector intializer using .begin to extract the left and right halves. This is similar to using the Python slice operation to extract the left and right halves. It is important to note that the vector may not have an even number of items. That does not matter, as the lengths will differ by at most one.   Merge Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function that prints the vector void printl(vector<int> avector) { for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \"; } cout << endl; } \/\/function sorts using mergesort. vector<int> mergeSort(vector<int> avector) { cout<<\"Splitting \"; printl(avector); if (avector.size()>1) { int mid = avector.size()\/2; \/\/C++ Equivalent to using Python Slices vector<int> lefthalf(avector.begin(),avector.begin()+mid); vector<int> righthalf(avector.begin()+mid,avector.begin()+avector.size()); lefthalf = mergeSort(lefthalf); righthalf = mergeSort(righthalf); unsigned i = 0; unsigned j = 0; unsigned k = 0; while (i < lefthalf.size() && j < righthalf.size()) { if (lefthalf[i] < righthalf[j]) { avector[k]=lefthalf[i]; i++; } else { avector[k] = righthalf[j]; j++; } k++; } while (i<lefthalf.size()) { avector[k] = lefthalf[i]; i++; k++; } while (j<righthalf.size()) { avector[k]=righthalf[j]; j++; k++; } } cout<<\"Merging \"; printl(avector); return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); printl(mergeSort(avector)); return 0; }  Python Implementation def mergeSort(alist): print(\"Splitting \",alist) if len(alist)>1: mid = len(alist)\/\/2 lefthalf = alist[:mid] righthalf = alist[mid:] mergeSort(lefthalf) mergeSort(righthalf) i=0 j=0 k=0 while i < len(lefthalf) and j < len(righthalf): if lefthalf[i] < righthalf[j]: alist[k]=lefthalf[i] i=i+1 else: alist[k]=righthalf[j] j=j+1 k=k+1 while i < len(lefthalf): alist[k]=lefthalf[i] i=i+1 k=k+1 while j < len(righthalf): alist[k]=righthalf[j] j=j+1 k=k+1 print(\"Merging \",alist) def main(): alist = [54,26,93,17,77,31,44,55,20] mergeSort(alist) print(alist) main()   Once the mergeSort function is invoked on the left half and the right half (lines 8–9), it is assumed they are sorted. The rest of the function (lines 11–31) is responsible for merging the two smaller sorted vectors into a larger sorted vector. Notice that the merge operation places the items back into the original vector ( avector ) one at a time by repeatedly taking the smallest item from the sorted vectors.  The mergeSort function has been augmented with a print statement (line 2) to show the contents of the vector being sorted at the start of each invocation. There is also a print statement (line 32) to show the merging process. The transcript shows the result of executing the function on our example vector. Note that the vector with 44, 55, and 20 will not divide evenly. The first split gives [44] and the second gives [55,20]. It is easy to see how the splitting process eventually yields a vector that can be immediately merged with other sorted vectors.  The visualization in allows you to step through the algorithm. Red bars represent the element being looked at and blue represents the last element to look at during a pass.   Mergesort animation.    The video in highlights the individual components of the algorithm itself. The arrows on the bottom indicate the left, middle, and right portions that the algorithm is currently examining. Left and right components are indicated by the color brown, while the middle is indicated by orange. Look for the divide-and-conquer aspect of the algorithm here.   Video of mergeSort in action.    In order to analyze the mergeSort function, we need to consider the two distinct processes that make up its implementation. First, the vector is split into halves. We already computed (in a binary search) that we can divide a vector in half times where n is the length of the vector. The second process is the merge. Each item in the vector will eventually be processed and placed on the sorted vector. So the merge operation which results in a vector of size n requires n operations. The result of this analysis is that splits, each of which costs for a total of operations. A merge sort is an algorithm.  Recall that the slicing operator is where k is the size of the slice. In order to guarantee that mergeSort will be we will need to remove the slice operator. Again, this is possible if we simply pass the starting and ending indices along with the vector when we make the recursive call. We leave this as an exercise.  It is important to notice that the mergeSort function requires extra space to hold the two halves as they are extracted with the slicing operations. This additional space can be a critical factor if the vector is large and can make this sort problematic when working on large data sets. In the case with using lists in python, the space complexity is .    Given the following list of numbers: [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40] which answer illustrates the list to be sorted after 3 recursive calls to mergesort?     [16, 49, 39, 27, 43, 34, 46, 40]    This is the second half of the list.      [21,1]    Yes, mergesort will continue to recursively move toward the beginning of the list until it hits a base case.      [21, 1, 26, 45]    Remember mergesort doesn't work on the right half of the list until the left half is completely sorted.      [21]    This is the list after 4 recursive calls      Given the following list of numbers: [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40] which answer illustrates the first two lists to be merged?     [21, 1] and [26, 45]    The first two lists merged will be base case lists, we have not yet reached a base case.      [1, 2, 9, 21, 26, 28, 29, 45] and [16, 27, 34, 39, 40, 43, 46, 49]    These will be the last two lists merged      [21] and [1]    The lists [21] and [1] are the first two base cases encountered by mergesort and will therefore be the first two lists merged.      [9] and [16]    Although 9 and 16 are next to each other they are in different halves of the list starting with the first split.      "
},
{
  "id": "sort_the-merge-sort-2",
  "level": "2",
  "url": "sort_the-merge-sort.html#sort_the-merge-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "merge sort merge "
},
{
  "id": "fig-mergesorta",
  "level": "2",
  "url": "sort_the-merge-sort.html#fig-mergesorta",
  "type": "Figure",
  "number": "7.7.1",
  "title": "",
  "body": " Splitting the vector in a Merge Sort.   An illustrative flowchart of the Merge Sort algorithm showing the process of splitting a vector into smaller parts. The chart starts with a single row of numbers at the top: 54, 26, 93, 17, 77, 31, 44, 55, 20, and branches downwards into increasingly smaller groups. Each branch represents a division of the list into two parts, progressively breaking down the numbers into individual elements. The flowchart visually demonstrates how Merge Sort recursively divides a list until each part contains a single element, preparing for the merge phase.   "
},
{
  "id": "fig-mergesortb",
  "level": "2",
  "url": "sort_the-merge-sort.html#fig-mergesortb",
  "type": "Figure",
  "number": "7.7.2",
  "title": "",
  "body": " Vectors as They Are Merged Together.   A diagram depicting the merging phase of the Merge Sort algorithm. The flowchart shows the combination of divided vectors into a sorted sequence. It starts with smaller groups of numbers at the top, each sorted individually: 26 and 54, 17 and 93, and so on. These groups are then merged into larger sorted sequences through a series of downward-pointing arrows, indicating the order of merging. The process continues until all numbers are combined into a single sorted list at the bottom: 17, 20, 26, 31, 44, 54, 55, 77, 93.   "
},
{
  "id": "expl-mergesort",
  "level": "2",
  "url": "sort_the-merge-sort.html#expl-mergesort",
  "type": "Exploration",
  "number": "7.7.1",
  "title": "Merge Sort.",
  "body": " Merge Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/function that prints the vector void printl(vector<int> avector) { for (unsigned int i=0; i<avector.size(); i++) { cout << avector[i] << \" \"; } cout << endl; } \/\/function sorts using mergesort. vector<int> mergeSort(vector<int> avector) { cout<<\"Splitting \"; printl(avector); if (avector.size()>1) { int mid = avector.size()\/2; \/\/C++ Equivalent to using Python Slices vector<int> lefthalf(avector.begin(),avector.begin()+mid); vector<int> righthalf(avector.begin()+mid,avector.begin()+avector.size()); lefthalf = mergeSort(lefthalf); righthalf = mergeSort(righthalf); unsigned i = 0; unsigned j = 0; unsigned k = 0; while (i < lefthalf.size() && j < righthalf.size()) { if (lefthalf[i] < righthalf[j]) { avector[k]=lefthalf[i]; i++; } else { avector[k] = righthalf[j]; j++; } k++; } while (i<lefthalf.size()) { avector[k] = lefthalf[i]; i++; k++; } while (j<righthalf.size()) { avector[k]=righthalf[j]; j++; k++; } } cout<<\"Merging \"; printl(avector); return avector; } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); printl(mergeSort(avector)); return 0; }  Python Implementation def mergeSort(alist): print(\"Splitting \",alist) if len(alist)>1: mid = len(alist)\/\/2 lefthalf = alist[:mid] righthalf = alist[mid:] mergeSort(lefthalf) mergeSort(righthalf) i=0 j=0 k=0 while i < len(lefthalf) and j < len(righthalf): if lefthalf[i] < righthalf[j]: alist[k]=lefthalf[i] i=i+1 else: alist[k]=righthalf[j] j=j+1 k=k+1 while i < len(lefthalf): alist[k]=lefthalf[i] i=i+1 k=k+1 while j < len(righthalf): alist[k]=righthalf[j] j=j+1 k=k+1 print(\"Merging \",alist) def main(): alist = [54,26,93,17,77,31,44,55,20] mergeSort(alist) print(alist) main()  "
},
{
  "id": "sort_mergesort-animation",
  "level": "2",
  "url": "sort_the-merge-sort.html#sort_mergesort-animation",
  "type": "Figure",
  "number": "7.7.3",
  "title": "",
  "body": " Mergesort animation.   "
},
{
  "id": "sort_merge-video",
  "level": "2",
  "url": "sort_the-merge-sort.html#sort_merge-video",
  "type": "Figure",
  "number": "7.7.4",
  "title": "",
  "body": " Video of mergeSort in action.   "
},
{
  "id": "question_sort_5",
  "level": "2",
  "url": "sort_the-merge-sort.html#question_sort_5",
  "type": "Reading Question",
  "number": "7.7.1",
  "title": "",
  "body": " Given the following list of numbers: [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40] which answer illustrates the list to be sorted after 3 recursive calls to mergesort?     [16, 49, 39, 27, 43, 34, 46, 40]    This is the second half of the list.      [21,1]    Yes, mergesort will continue to recursively move toward the beginning of the list until it hits a base case.      [21, 1, 26, 45]    Remember mergesort doesn't work on the right half of the list until the left half is completely sorted.      [21]    This is the list after 4 recursive calls    "
},
{
  "id": "question_sort_6",
  "level": "2",
  "url": "sort_the-merge-sort.html#question_sort_6",
  "type": "Reading Question",
  "number": "7.7.2",
  "title": "",
  "body": " Given the following list of numbers: [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40] which answer illustrates the first two lists to be merged?     [21, 1] and [26, 45]    The first two lists merged will be base case lists, we have not yet reached a base case.      [1, 2, 9, 21, 26, 28, 29, 45] and [16, 27, 34, 39, 40, 43, 46, 49]    These will be the last two lists merged      [21] and [1]    The lists [21] and [1] are the first two base cases encountered by mergesort and will therefore be the first two lists merged.      [9] and [16]    Although 9 and 16 are next to each other they are in different halves of the list starting with the first split.    "
},
{
  "id": "sort_the-quick-sort",
  "level": "1",
  "url": "sort_the-quick-sort.html",
  "type": "Section",
  "number": "7.8",
  "title": "The Quick Sort",
  "body": " The Quick Sort  quick sort The quick sort uses divide and conquer to gain the same advantages as the merge sort, while not using additional storage. As a trade-off, however, it is possible that the list may not be divided in half. When this happens, we will see that performance is diminished.  A quick sort first selects a value, which is called the pivot value . Although there are many different ways to choose the pivot value, we will simply use the first item in the list. The role of the pivot value is to assist with splitting the list. The actual position where the pivot value belongs in the final sorted list, commonly called the split point , will be used to divide the list for subsequent calls to the quick sort.  shows that 54 will serve as our first pivot value. Since we have looked at this example a few times already, we know that 54 will eventually end up in the position currently holding 31. The partition process will happen next. It will find the split point and at the same time move other items to the appropriate side of the list, either less than or greater than the pivot value.   The First Pivot Value for a Quick Sort.   A single row of numbers shown in boxes with the number 54 highlighted and labeled as '54 will be the first pivot value'. This image is used to illustrate the initial step in the Quick Sort algorithm where a pivot value is chosen to partition the list. The rest of the numbers in the row are in lighter boxes and include 26, 93, 17, 77, 31, 44, 55, and 20.    Partitioning begins by locating two position markers—let's call them leftmark and rightmark —at the beginning and end of the remaining items in the list (positions 1 and 8 in ). The goal of the partition process is to move items that are on the wrong side with respect to the pivot value while also converging on the split point. shows this process as we locate the position of 54.   Finding the Split Point for 54.   A series of diagrams illustrating the process of finding the split point for the number 54 in a Quick Sort algorithm. The diagrams show a row of numbers with two markers, 'leftmark' and 'rightmark', that move towards each other from opposite ends. Each step of the process is annotated with instructions like 'leftmark and rightmark will converge on split point', '26 <54 move to right, exchange 20 and 93, and so on. The movement of the markers and the exchanges of numbers are depicted with arrows and highlighted actions, detailing how the algorithm partitions the data around the pivot. The final diagram shows the leftmark and rightmark crossing over, indicating the split point has been found, and the pivot, 54, is in its correct position.    We begin by incrementing leftmark until we locate a value that is greater than the pivot value. We then decrement rightmark until we find a value that is less than the pivot value. At this point we have discovered two items that are out of place with respect to the eventual split point. For our example, this occurs at 93 and 20. Now we can exchange these two items and then repeat the process again.  At the point where rightmark becomes less than leftmark , we stop. The position of rightmark is now the split point. The pivot value can be exchanged with the contents of the split point and the pivot value is now in place ( ). In addition, all the items to the left of the split point are less than the pivot value, and all the items to the right of the split point are greater than the pivot value. The list can now be divided at the split point and the quick sort can be invoked recursively on the two halves.   Completing the Partition Process to Find the Split Point for 54.   The image shows the final step in the partitioning process of the Quick Sort algorithm, where the split point for the pivot value 54 is established. Two separate groups of numbers are displayed. The first group to the left includes numbers less than 54: 31, 26, 20, 17, and 44, with the annotation 'quicksort left half'. The second group to the right includes numbers greater than 54: 77, 55, and 93, with the annotation 'quicksort right half'. The number 54 is positioned in the center, labeled '54 is in place', indicating that it is at its correct position in the sorted array.    The quickSort function shown in invokes a recursive function, quickSortHelper . quickSortHelper begins with the same base case as the merge sort. If the length of the list is less than or equal to one, it is already sorted. If it is greater, then it can be partitioned and recursively sorted. The partition function implements the process described earlier. The following program sorts the list that was used in the example above.   Quick Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; void printl(vector<int> avector) { for (unsigned i=0; i<avector.size(); i++) { cout<<avector[i]<<\" \"; } cout<<endl; } \/\/function partitions vector depending on pivot value int partition(vector<int> &avector, int first, int last) { int pivotvalue = avector[first]; int rightmark = last; int leftmark = first+1; bool done = false; while(not done){ while(leftmark<=rightmark and avector[leftmark]<=pivotvalue){ leftmark++; } while(rightmark>=leftmark and avector[rightmark]>=pivotvalue){ rightmark--; } if(rightmark<leftmark){ done = true; } else{ swap(avector[rightmark], avector[leftmark]); } } swap(avector[rightmark], avector[first]); return rightmark; } \/\/recursive function that quicksorts through a given vector void quickSort(vector<int> &avector, int first, int last) { int splitpoint; if (first<last) { splitpoint = partition(avector,first,last); quickSort(avector,first,splitpoint); quickSort(avector,splitpoint+1,last); } } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); quickSort(avector,0,avector.size()-1); printl(avector); return 0; }  Python Implementation #recursive function that calls itself to quicksort through a given list of values def quickSort(alist,first,last): if first<last: splitpoint = partition(alist,first,last) quickSort(alist,first,splitpoint-1) quickSort(alist,splitpoint+1,last) #function partitions vector depending on pivot value def partition(alist,first,last): pivotvalue = alist[first] leftmark = first+1 rightmark = last done = False while not done: while alist[leftmark]<=pivotvalue and leftmark<=rightmark: leftmark += 1 while alist[rightmark]>=pivotvalue and rightmark>=leftmark: rightmark -= 1 if rightmark < leftmark: done = True else: temp = alist[rightmark] alist[rightmark] = alist[leftmark] alist[leftmark] = temp temp = alist[rightmark] alist[rightmark] = alist[first] alist[first] = temp return rightmark def main(): alist = [54, 26, 93, 17, 77, 31, 44, 55, 20] quickSort(alist,0,len(alist)-1) print(alist) main()   The visualization in allows you to step through the algorithm.   Quick sort animation.    The visualization in shows how quick sort works in action. Our pivot is represented by the arrow on screen. If an object is bigger than the pivot, it will turn blue and stay where it is. If it is smaller it will turn red and swap to the left side of the pivot. Once an object is sorted, it will turn yellow.   Video of quickSort in action.    To analyze the quickSort function, note that for a list of length n , if the partition always occurs in the middle of the list, there will again be divisions. In order to find the split point, each of the n items needs to be checked against the pivot value. The result is . In addition, there is no need for additional memory as in the merge sort process.  Unfortunately, in the worst case, the split points may not be in the middle and can be very skewed to the left or the right, leaving a very uneven division. In this case, sorting a list of n items divides into sorting a list of 0 items and a list of items. Then sorting a list of divides into a list of size 0 and a list of size , and so on. The result is an sort with all of the overhead that recursion requires.  We mentioned earlier that there are different ways to choose the pivot value. In particular, we can attempt to alleviate some of the potential for an uneven division by using a technique called median of three . To choose the pivot value, we will consider the first, the middle, and the last element in the list. In our example, those are 54, 77, and 20. Now pick the median value, in our case 54, and use it for the pivot value (of course, that was the pivot value we used originally). The idea is that in the case where the the first item in the list does not belong toward the middle of the list, the median of three will choose a better middle value. This will be particularly useful when the original list is somewhat sorted to begin with. We leave the implementation of this pivot value selection as an exercise.    Given the following list of numbers [14, 17, 13, 15, 19, 10, 3, 16, 9, 12] which answer shows the contents of the list after the second partitioning according to the quicksort algorithm?     [9, 3, 10, 13, 12]    It's important to remember that quicksort works on the entire list and sorts it in place.      [9, 3, 10, 13, 12, 14]    Remember quicksort works on the entire list and sorts it in place.      [9, 3, 10, 13, 12, 14, 17, 16, 15, 19]    The first partitioning works on the entire list, and the second partitioning works on the left partition not the right.      [9, 3, 10, 13, 12, 14, 19, 16, 15, 17]    The first partitioning works on the entire list, and the second partitioning works on the left partition.      Given the following list of numbers [1, 20, 11, 5, 2, 9, 16, 14, 13, 19] what would be the first pivot value using the median of 3 method?     1    The three numbers used in selecting the pivot are 1, 9, 19. 1 is not the median, and would be a very bad choice for the pivot since it is the smallest number in the list.      9    Good job.      16    although 16 would be the median of 1, 16, 19 the middle is at len(list) \/\/ 2.      19    the three numbers used in selecting the pivot are 1, 9, 19. 9 is the median. 19 would be a bad choice since it is almost the largest.      "
},
{
  "id": "sort_the-quick-sort-2",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_the-quick-sort-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "quick sort "
},
{
  "id": "sort_the-quick-sort-3",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_the-quick-sort-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pivot value split point "
},
{
  "id": "sort_the-quick-sort-4",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_the-quick-sort-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "partition "
},
{
  "id": "fig-splitvalue",
  "level": "2",
  "url": "sort_the-quick-sort.html#fig-splitvalue",
  "type": "Figure",
  "number": "7.8.1",
  "title": "",
  "body": " The First Pivot Value for a Quick Sort.   A single row of numbers shown in boxes with the number 54 highlighted and labeled as '54 will be the first pivot value'. This image is used to illustrate the initial step in the Quick Sort algorithm where a pivot value is chosen to partition the list. The rest of the numbers in the row are in lighter boxes and include 26, 93, 17, 77, 31, 44, 55, and 20.   "
},
{
  "id": "fig-partitiona",
  "level": "2",
  "url": "sort_the-quick-sort.html#fig-partitiona",
  "type": "Figure",
  "number": "7.8.2",
  "title": "",
  "body": " Finding the Split Point for 54.   A series of diagrams illustrating the process of finding the split point for the number 54 in a Quick Sort algorithm. The diagrams show a row of numbers with two markers, 'leftmark' and 'rightmark', that move towards each other from opposite ends. Each step of the process is annotated with instructions like 'leftmark and rightmark will converge on split point', '26 <54 move to right, exchange 20 and 93, and so on. The movement of the markers and the exchanges of numbers are depicted with arrows and highlighted actions, detailing how the algorithm partitions the data around the pivot. The final diagram shows the leftmark and rightmark crossing over, indicating the split point has been found, and the pivot, 54, is in its correct position.   "
},
{
  "id": "fig-partitionb",
  "level": "2",
  "url": "sort_the-quick-sort.html#fig-partitionb",
  "type": "Figure",
  "number": "7.8.3",
  "title": "",
  "body": " Completing the Partition Process to Find the Split Point for 54.   The image shows the final step in the partitioning process of the Quick Sort algorithm, where the split point for the pivot value 54 is established. Two separate groups of numbers are displayed. The first group to the left includes numbers less than 54: 31, 26, 20, 17, and 44, with the annotation 'quicksort left half'. The second group to the right includes numbers greater than 54: 77, 55, and 93, with the annotation 'quicksort right half'. The number 54 is positioned in the center, labeled '54 is in place', indicating that it is at its correct position in the sorted array.   "
},
{
  "id": "expl-quicksort",
  "level": "2",
  "url": "sort_the-quick-sort.html#expl-quicksort",
  "type": "Exploration",
  "number": "7.8.1",
  "title": "Quick Sort.",
  "body": " Quick Sort  C++ Implementation #include <iostream> #include <vector> using namespace std; void printl(vector<int> avector) { for (unsigned i=0; i<avector.size(); i++) { cout<<avector[i]<<\" \"; } cout<<endl; } \/\/function partitions vector depending on pivot value int partition(vector<int> &avector, int first, int last) { int pivotvalue = avector[first]; int rightmark = last; int leftmark = first+1; bool done = false; while(not done){ while(leftmark<=rightmark and avector[leftmark]<=pivotvalue){ leftmark++; } while(rightmark>=leftmark and avector[rightmark]>=pivotvalue){ rightmark--; } if(rightmark<leftmark){ done = true; } else{ swap(avector[rightmark], avector[leftmark]); } } swap(avector[rightmark], avector[first]); return rightmark; } \/\/recursive function that quicksorts through a given vector void quickSort(vector<int> &avector, int first, int last) { int splitpoint; if (first<last) { splitpoint = partition(avector,first,last); quickSort(avector,first,splitpoint); quickSort(avector,splitpoint+1,last); } } int main() { \/\/ Vector initialized using a static array static const int arr[] = {54, 26, 93, 17, 77, 31, 44, 55, 20}; vector<int> avector (arr, arr + sizeof(arr) \/ sizeof(arr[0]) ); quickSort(avector,0,avector.size()-1); printl(avector); return 0; }  Python Implementation #recursive function that calls itself to quicksort through a given list of values def quickSort(alist,first,last): if first<last: splitpoint = partition(alist,first,last) quickSort(alist,first,splitpoint-1) quickSort(alist,splitpoint+1,last) #function partitions vector depending on pivot value def partition(alist,first,last): pivotvalue = alist[first] leftmark = first+1 rightmark = last done = False while not done: while alist[leftmark]<=pivotvalue and leftmark<=rightmark: leftmark += 1 while alist[rightmark]>=pivotvalue and rightmark>=leftmark: rightmark -= 1 if rightmark < leftmark: done = True else: temp = alist[rightmark] alist[rightmark] = alist[leftmark] alist[leftmark] = temp temp = alist[rightmark] alist[rightmark] = alist[first] alist[first] = temp return rightmark def main(): alist = [54, 26, 93, 17, 77, 31, 44, 55, 20] quickSort(alist,0,len(alist)-1) print(alist) main()  "
},
{
  "id": "sort_quicksort-animation",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_quicksort-animation",
  "type": "Figure",
  "number": "7.8.4",
  "title": "",
  "body": " Quick sort animation.   "
},
{
  "id": "sort_quick-video",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_quick-video",
  "type": "Figure",
  "number": "7.8.5",
  "title": "",
  "body": " Video of quickSort in action.   "
},
{
  "id": "sort_the-quick-sort-19",
  "level": "2",
  "url": "sort_the-quick-sort.html#sort_the-quick-sort-19",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "median of three "
},
{
  "id": "question_sort_7",
  "level": "2",
  "url": "sort_the-quick-sort.html#question_sort_7",
  "type": "Reading Question",
  "number": "7.8.1",
  "title": "",
  "body": " Given the following list of numbers [14, 17, 13, 15, 19, 10, 3, 16, 9, 12] which answer shows the contents of the list after the second partitioning according to the quicksort algorithm?     [9, 3, 10, 13, 12]    It's important to remember that quicksort works on the entire list and sorts it in place.      [9, 3, 10, 13, 12, 14]    Remember quicksort works on the entire list and sorts it in place.      [9, 3, 10, 13, 12, 14, 17, 16, 15, 19]    The first partitioning works on the entire list, and the second partitioning works on the left partition not the right.      [9, 3, 10, 13, 12, 14, 19, 16, 15, 17]    The first partitioning works on the entire list, and the second partitioning works on the left partition.    "
},
{
  "id": "question_sort_8",
  "level": "2",
  "url": "sort_the-quick-sort.html#question_sort_8",
  "type": "Reading Question",
  "number": "7.8.2",
  "title": "",
  "body": " Given the following list of numbers [1, 20, 11, 5, 2, 9, 16, 14, 13, 19] what would be the first pivot value using the median of 3 method?     1    The three numbers used in selecting the pivot are 1, 9, 19. 1 is not the median, and would be a very bad choice for the pivot since it is the smallest number in the list.      9    Good job.      16    although 16 would be the median of 1, 16, 19 the middle is at len(list) \/\/ 2.      19    the three numbers used in selecting the pivot are 1, 9, 19. 9 is the median. 19 would be a bad choice since it is almost the largest.    "
},
{
  "id": "sort_summary",
  "level": "1",
  "url": "sort_summary.html",
  "type": "Section",
  "number": "7.9",
  "title": "Summary",
  "body": " Summary    A bubble sort, a selection sort, and an insertion sort are algorithms.    A shell sort improves on the insertion sort by sorting incremental sublists. It falls between and .    A merge sort is , but requires additional space for the merging process.    A quick sort is , but may degrade to if the split points are not near the middle of the list. It does not require additional space.    "
},
{
  "id": "sort_discussion-questions",
  "level": "1",
  "url": "sort_discussion-questions.html",
  "type": "Section",
  "number": "7.10",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Generate a random list of integers. Show how this list is sorted by the following algorithms:    bubble sort    selection sort    insertion sort    shell sort (you decide on the increments)    merge sort    quick sort (you decide on the pivot value)      Consider the following list of integers: [1,2,3,4,5,6,7,8,9,10]. Show how this list is sorted by the following algorithms:    bubble sort    selection sort    insertion sort    shell sort (you decide on the increments)    merge sort    quick sort (you decide on the pivot value)      Consider the following list of integers: [10,9,8,7,6,5,4,3,2,1]. Show how this list is sorted by the following algorithms:    bubble sort    selection sort    insertion sort    shell sort (you decide on the increments)    merge sort    quick sort (you decide on the pivot value)      Consider the list of characters: [ 'P','Y','T','H','O','N' ]. Show how this list is sorted using the following algorithms:    bubble sort    selection sort    insertion sort    shell sort (you decide on the increments)    merge sort    quick sort (you decide on the pivot value)      Devise alternative strategies for choosing the pivot value in quick sort. For example, pick the middle item. Re-implement the algorithm and then execute it on random data sets. Under what criteria does your new strategy perform better or worse than the strategy from this chapter?    "
},
{
  "id": "sort_programming-exercises",
  "level": "1",
  "url": "sort_programming-exercises.html",
  "type": "Section",
  "number": "7.11",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Using a random number generator, create a list of 500 integers. Perform a benchmark analysis using some of the sorting algorithms from this chapter. What is the difference in execution speed?    Implement the bubble sort using simultaneous assignment.    A bubble sort can be modified to bubble in both directions. The first pass moves up the list, and the second pass moves down. This alternating pattern continues until no more passes are necessary. Implement this variation and describe under what circumstances it might be appropriate.    Implement the selection sort using simultaneous assignment.    Perform a benchmark analysis for a shell sort, using different increment sets on the same vector.    One way to improve the quick sort is to use an insertion sort on lists that have a small length (call it the partition limit ). Why does this make sense? Re-implement the quick sort and use it to sort a random list of integers. Perform an analysis using different list sizes for the partition limit.    Implement the median-of-three method for selecting a pivot value as a modification to quickSort . Run an experiment to compare the two techniques.    "
},
{
  "id": "sort_glossary",
  "level": "1",
  "url": "sort_glossary.html",
  "type": "Section",
  "number": "7.12",
  "title": "Glossary",
  "body": " Glossary    bubble sort  sorting method that makes multiple passes through a collection, comparing adjacent items, and swaps items that are out of order.    gap  an increment used to divide a collection into subsets without breaking apart the collection during a shell sort.    insertion sort  sorting method that maintains a sorted and unsorted subset of a collection and inserts elements from the unsorted subset into the sorted subset.    median of three  method of choosing the pivot value for a quick sort by taking the median of the first, middle, and last element of a collection.    merge  part of merge sort that takes two smaller sorted subsets and combines them.    merge sort  sorting method that uses recursion to split a collection in half until there is one item and then combines the smaller subsets back into larger sorted subsets.    partition  process of quick sort that that finds the split point and moves items to the appropriate side of the collection, either less than or greater than the pivot value.    pivot value  value selected in a collection during quick sort in order to split a collection.    selection sort  sorting method that makes multiple passes through a collection, taking the largest (ascending) or smallest (descending) unsorted element and places it into its correct place by swapping places with the next largest or lowest element.    shell sort  sorting method that divides the collection into subsets, sorts the subsets individually using insertion sort, then also sorts the combination of the sorted subsets using insertion sort.    short bubble  a modified bubble sort that stops if there are no exchanges to do.    sorting  the process of placing elements from a collection in some kind of order.    split point  the position of the pivot value in the sorted collection; used to divide the collection for subsequent calls to quick sort.    quick sort  sorting method that uses recursion to split a collection in half (without using extra space) and places elements on the proper side of the split point.    "
},
{
  "id": "sort_sort_matching",
  "level": "1",
  "url": "sort_sort_matching.html",
  "type": "Section",
  "number": "7.13",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition   Review classes and their properties    bubble sort  Makes multiple passes through a collection, comparing adjacent items, and swaps items that are out of order    short bubble  Stops if there are no exchanges to do    shell sort  Divides the collection into subsets, sorts the subsets individually using insertion sort, then also sorts the combination of the sorted subsets using insertion sort    sorting  Process of placing elements from a collection in some kind of order    split point  Position of the pivot value in the sorted collection; used to divide the collection for subsequent calls to quick sort    quick sort  Uses recursion to split a collection in half and places elements on the proper side of the split point    gap  Used to divide a collection into subsets without breaking apart the collection during a shell sort    insertion sort  Maintains a sorted and unsorted subset of a collection and inserts elements from the unsorted subset into the sorted subset    median of three  Method of choosing the pivot value for a quick sort by taking the median of the first, middle, and last element of a collection    merge  Takes two smaller sorted subsets and combines them    merge sort  Uses recursion to split a collection in half until there is one item and then combines the smaller subsets back into larger sorted subsets    partition  Finds the split point and moves items to the appropriate side of the collection, either less than or greater than the pivot value    pivot value  Value selected in a collection during quick sort in order to split a collection    selection sort  Makes multiple passes through a collection, taking the largest or lowest unsorted element and places it into its correct place by swapping places with the next largest or lowest element    "
},
{
  "id": "matching_sort",
  "level": "2",
  "url": "sort_sort_matching.html#matching_sort",
  "type": "Checkpoint",
  "number": "7.13.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition   Review classes and their properties    bubble sort  Makes multiple passes through a collection, comparing adjacent items, and swaps items that are out of order    short bubble  Stops if there are no exchanges to do    shell sort  Divides the collection into subsets, sorts the subsets individually using insertion sort, then also sorts the combination of the sorted subsets using insertion sort    sorting  Process of placing elements from a collection in some kind of order    split point  Position of the pivot value in the sorted collection; used to divide the collection for subsequent calls to quick sort    quick sort  Uses recursion to split a collection in half and places elements on the proper side of the split point    gap  Used to divide a collection into subsets without breaking apart the collection during a shell sort    insertion sort  Maintains a sorted and unsorted subset of a collection and inserts elements from the unsorted subset into the sorted subset    median of three  Method of choosing the pivot value for a quick sort by taking the median of the first, middle, and last element of a collection    merge  Takes two smaller sorted subsets and combines them    merge sort  Uses recursion to split a collection in half until there is one item and then combines the smaller subsets back into larger sorted subsets    partition  Finds the split point and moves items to the appropriate side of the collection, either less than or greater than the pivot value    pivot value  Value selected in a collection during quick sort in order to split a collection    selection sort  Makes multiple passes through a collection, taking the largest or lowest unsorted element and places it into its correct place by swapping places with the next largest or lowest element   "
},
{
  "id": "trees_objectives",
  "level": "1",
  "url": "trees_objectives.html",
  "type": "Section",
  "number": "8.1",
  "title": "Objectives",
  "body": " Objectives    To understand what a tree data structure is and how it is used.    To see how trees can be used to implement a map data structure.    To implement trees using a list.    To implement trees using classes and references.    To implement trees as a recursive data structure.    To implement a priority queue using a heap.    "
},
{
  "id": "trees_examples-of-trees",
  "level": "1",
  "url": "trees_examples-of-trees.html",
  "type": "Section",
  "number": "8.2",
  "title": "Examples of Trees",
  "body": " Examples of Trees  Now that we have studied linear data structures like stacks and queues and have some experience with recursion, we will look at a common data structure called the tree . Trees are used in many areas of computer science, including operating systems, graphics, database systems, and computer networking. Tree data structures have many things in common with their botanical cousins. A tree data structure has a root, branches, and leaves. The difference between a tree in nature and a tree in computer science is that a tree data structure has its root at the top and its leaves on the bottom.  Before we begin our study of tree data structures, let's look at a few common examples. Our first example of a tree is a classification tree from biology. shows an example of the biological classification of some animals. From this simple example, we can learn about several properties of trees. The first property this example demonstrates is that trees are hierarchical. By hierarchical, we mean that trees are structured in layers with the more general things near the top and the more specific things near the bottom. The top of the hierarchy is the Kingdom, the next layer of the tree (the children of the layer above) is the Phylum, then the Class, and so on. However, no matter how deep we go in the classification tree, all the organisms are still animals.   Taxonomy of Some Common Animals Shown as a Tree.   The image displays a taxonomy tree diagram of some common animals, illustrating their scientific classification from kingdom to species. At the top, 'Animalia' branches into 'Chordate' and 'Arthropoda', leading down to classifications such as 'Mammal' and 'Insect'. Specific branches detail the classification of humans, chimpanzees, house cats, lions, and houseflies, listing their respective taxonomic ranks from 'Kingdom' down to 'Species'. Each species is paired with its common name, like 'Homo sapiens' for human, 'Pan troglodytes' for chimpanzee, 'Felis domestica' for house cat, 'Panthera leo' for lion, and 'Musca domestica' for housefly.    Notice that you can start at the top of the tree and follow a path made of circles and arrows all the way to the bottom. At each level of the tree we might ask ourselves a question and then follow the path that agrees with our answer. For example we might ask, Is this animal a Chordate or an Arthropod? If the answer is Chordate then we follow that path and ask, Is this Chordate a Mammal? If not, we are stuck (but only in this simplified example). When we are at the Mammal level we ask, Is this Mammal a Primate or a Carnivore? We can keep following paths until we get to the very bottom of the tree where we have the common name.  A second property of trees is that all of the children of one node are independent of the children of another node. For example, the Genus Felis has the children Domestica and Leo. The Genus Musca also has a child named Domestica, but it is a different node and is independent of the Domestica child of Felis. This means that we can change the node that is the child of Musca without affecting the child of Felis.  A third property is that each leaf node is unique. We can specify a path from the root of the tree to a leaf that uniquely identifies each species in the animal kingdom; for example, Animalia Chordate Mammal Carnivora Felidae Felis Domestica.  Another example of a tree structure that you probably use every day is a file system. In a file system, directories, or folders, are structured as a tree. illustrates a small part of a Unix file system hierarchy.   A Small Part of the Unix File System Hierarchy.   The image shows a hierarchical diagram representing a small part of the Unix file system structure. It starts from a single root node that branches out to various directories such as '\/dev\/', '\/etc\/', '\/sbin\/', '\/tmp\/', '\/Users\/', '\/usr\/', and '\/var\/'. Each of these main directories further branches into subdirectories like '\/cups\/' and '\/httpd\/' under '\/dev\/', or '\/bin\/', '\/lib\/', and '\/local\/' under '\/usr\/'. The diagram visually organizes the structure and relationships of these directories in a tree-like format, indicating how files and subdirectories are organized within a Unix-based operating system.    The file system tree has much in common with the biological classification tree. You can follow a path from the root to any directory. That path will uniquely identify that subdirectory (and all the files in it). Another important property of trees, derived from their hierarchical nature, is that you can move entire sections of a tree (called a subtree ) to a different position in the tree without affecting the lower levels of the hierarchy. For example, we could take the entire subtree staring with \/etc\/, detach etc\/ from the root and reattach it under usr\/. This would change the unique pathname to httpd from \/etc\/httpd to \/usr\/etc\/httpd, but would not affect the contents or any children of the httpd directory.  A final example of a tree is a web page. The following is an example of a simple web page written using HTML. shows the tree that corresponds to each of the HTML tags used to create the page.  <html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\" xml:lang=\"en\" lang=\"en\"> <head> <meta http-equiv=\"Content-Type\" content=\"text\/html; charset=utf-8\"\/> <title>simple<\/title> <\/head> <body> <h1>A simple web page<\/h1> <ul> <li>List item one<\/li> <li>List item two<\/li> <\/ul> <h2> <a href=\"http:\/\/www.cs.luther.edu\">Luther CS <\/a> <\/h2> <\/body> <\/html>   A Tree Corresponding to the Markup Elements of a Web Page.   A diagrammatic representation of a web page's Document Object Model (DOM) tree. The tree has 'html' as the root node, which branches off into 'head' and 'body' nodes. The 'head' node further branches into 'meta' and 'title', while the 'body' node extends into 'ul', 'h1', and 'h2' nodes. The 'ul' (unordered list) node has two 'li' (list item) child nodes, and the 'h2' node has an 'a' (anchor) child node, representing a hyperlink. This tree structure visually maps out the hierarchy and relationships of markup elements within a web page.    The HTML source code and the tree accompanying the source illustrate another hierarchy. Notice that each level of the tree corresponds to a level of nesting inside the HTML tags. The first tag in the source is <html> and the last is <\/html> All the rest of the tags in the page are inside the pair. If you check, you will see that this nesting property is true at all levels of the tree.   Reading Question   Which of the following are properties of a tree?     each node is unique    correct      children of one node are independent from children of another    correct      each node has children    nodes can have no children      hierarchy    correct      "
},
{
  "id": "trees_examples-of-trees-2",
  "level": "2",
  "url": "trees_examples-of-trees.html#trees_examples-of-trees-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "tree "
},
{
  "id": "trees_examples-biotree",
  "level": "2",
  "url": "trees_examples-of-trees.html#trees_examples-biotree",
  "type": "Figure",
  "number": "8.2.1",
  "title": "",
  "body": " Taxonomy of Some Common Animals Shown as a Tree.   The image displays a taxonomy tree diagram of some common animals, illustrating their scientific classification from kingdom to species. At the top, 'Animalia' branches into 'Chordate' and 'Arthropoda', leading down to classifications such as 'Mammal' and 'Insect'. Specific branches detail the classification of humans, chimpanzees, house cats, lions, and houseflies, listing their respective taxonomic ranks from 'Kingdom' down to 'Species'. Each species is paired with its common name, like 'Homo sapiens' for human, 'Pan troglodytes' for chimpanzee, 'Felis domestica' for house cat, 'Panthera leo' for lion, and 'Musca domestica' for housefly.   "
},
{
  "id": "trees_examples-filetree",
  "level": "2",
  "url": "trees_examples-of-trees.html#trees_examples-filetree",
  "type": "Figure",
  "number": "8.2.2",
  "title": "",
  "body": " A Small Part of the Unix File System Hierarchy.   The image shows a hierarchical diagram representing a small part of the Unix file system structure. It starts from a single root node that branches out to various directories such as '\/dev\/', '\/etc\/', '\/sbin\/', '\/tmp\/', '\/Users\/', '\/usr\/', and '\/var\/'. Each of these main directories further branches into subdirectories like '\/cups\/' and '\/httpd\/' under '\/dev\/', or '\/bin\/', '\/lib\/', and '\/local\/' under '\/usr\/'. The diagram visually organizes the structure and relationships of these directories in a tree-like format, indicating how files and subdirectories are organized within a Unix-based operating system.   "
},
{
  "id": "trees_examples-of-trees-10",
  "level": "2",
  "url": "trees_examples-of-trees.html#trees_examples-of-trees-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "subtree "
},
{
  "id": "trees_examples-htmltree",
  "level": "2",
  "url": "trees_examples-of-trees.html#trees_examples-htmltree",
  "type": "Figure",
  "number": "8.2.3",
  "title": "",
  "body": " A Tree Corresponding to the Markup Elements of a Web Page.   A diagrammatic representation of a web page's Document Object Model (DOM) tree. The tree has 'html' as the root node, which branches off into 'head' and 'body' nodes. The 'head' node further branches into 'meta' and 'title', while the 'body' node extends into 'ul', 'h1', and 'h2' nodes. The 'ul' (unordered list) node has two 'li' (list item) child nodes, and the 'h2' node has an 'a' (anchor) child node, representing a hyperlink. This tree structure visually maps out the hierarchy and relationships of markup elements within a web page.   "
},
{
  "id": "treeProperties",
  "level": "2",
  "url": "trees_examples-of-trees.html#treeProperties",
  "type": "Reading Question",
  "number": "8.2.1",
  "title": "",
  "body": " Which of the following are properties of a tree?     each node is unique    correct      children of one node are independent from children of another    correct      each node has children    nodes can have no children      hierarchy    correct    "
},
{
  "id": "trees_vocabulary-and-definitions",
  "level": "1",
  "url": "trees_vocabulary-and-definitions.html",
  "type": "Section",
  "number": "8.3",
  "title": "Vocabulary and Definitions",
  "body": " Vocabulary and Definitions  Now that we have looked at examples of trees, we will formally define a tree and its components.    Node  Tree Components node  A node is a fundamental part of a tree. It can have a name, which we call the key. A node may also have additional information. We call this additional information the payload. While the payload information is not central to many tree algorithms, it is often critical in applications that make use of trees.    Edge  Tree Components edge  An edge is another fundamental part of a tree. An edge connects two nodes to show that there is a relationship between them. Every node (except the root) is connected by exactly one incoming edge from another node. Each node may have several outgoing edges.    Root  Tree Components root  The root of the tree is the only node in the tree that has no incoming edges. In , \/ is the root of the tree.    Path  Tree Components path  A path is an ordered list of nodes that are connected by edges. For example, Mammal Carnivora Felidae Felis Domestica is a path.    Children  Tree Components children  The set of nodes that have incoming edges from the same node to are said to be the children of that node. In , nodes log\/, spool\/, and yp\/ are the children of node var\/.    Parent  Tree Components parent  A node is the parent of all the nodes it connects to with outgoing edges. In the node var\/ is the parent of nodes log\/, spool\/, and yp\/.    Sibling  Tree Components siblings  Nodes in the tree that are children of the same parent are said to be siblings . The nodes etc\/ and usr\/ are siblings in the filesystem tree.    Subtree  Tree Components subtree  A subtree is a set of nodes and edges comprised of a parent and all the descendants of that parent.    Leaf Node  Tree Components leaf node  A leaf node is a node that has no children. For example, Human and Chimpanzee are leaf nodes in .    Level  Tree Components level  The level of a node is the number of edges on the path from the root node to . For example, the level of the Felis node in is five. By definition, the level of the root node is zero.    Height  Tree Components height  The height of a tree is equal to the maximum level of any node in the tree. The height of the tree in is two.    With the basic vocabulary now defined, we can move on to a formal definition of a tree. In fact, we will provide two definitions of a tree. One definition involves nodes and edges. The second definition, which will prove to be very useful, is a recursive definition.  Definition One: A tree consists of a set of nodes and a set of edges that connect pairs of nodes. A tree has the following properties:    One node of the tree is designated as the root node.    Every node , except the root node, is connected by an edge from exactly one other node , where is the parent of .    A unique path traverses from the root to each node.    If each node in the tree has a maximum of two children, we say that the tree is a binary tree .    illustrates a tree that fits definition one. The arrowheads on the edges indicate the direction of the connection.   A Tree Consisting of a Set of Nodes and Edges.   The image shows a basic conceptual diagram of a tree data structure, consisting of a set of nodes connected by edges. The top of the tree features a 'rootnode', which branches into 'child1' and 'child2'. Below 'child1', there is 'node1' with three children labeled 'child1', 'child2', and 'child3', while 'child2' branches into 'node2' with a single 'child1'. Further down, 'node1' branches into 'node3', 'node4', and 'node5', and 'node2' branches into 'node6'. The nodes are represented by rectangles, and the connecting lines represent the edges of the tree.    Definition Two: A tree is either empty or consists of a root and zero or more subtrees, each of which is also a tree. The root of each subtree is connected to the root of the parent tree by an edge. illustrates this recursive definition of a tree. Using the recursive definition of a tree, we know that the tree in has at least four nodes, since each of the triangles representing a subtree must have a root. It may have many more nodes than that, but we do not know unless we look deeper into the tree.   A recursive Definition of a tree.   The image presents a simplified diagram of a tree data structure with a single 'root' node at the top, branching out into three 'subtrees' labeled 'subtree-1', 'subtree-2', and 'subtree-3'. This visual model illustrates the concept of recursion in data structures, where each subtree can be seen as a smaller instance of the larger structure.     Reading Question   In your own words, define a tree relative to the first definition provided above.    "
},
{
  "id": "trees_vocabulary-and-definitions-3-1-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-1-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "node "
},
{
  "id": "trees_vocabulary-and-definitions-3-2-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-2-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "edge "
},
{
  "id": "trees_vocabulary-and-definitions-3-3-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-3-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "root "
},
{
  "id": "trees_vocabulary-and-definitions-3-4-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-4-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "path "
},
{
  "id": "trees_vocabulary-and-definitions-3-6-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-6-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "parent "
},
{
  "id": "trees_vocabulary-and-definitions-3-7-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-7-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "siblings "
},
{
  "id": "trees_vocabulary-and-definitions-3-8-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-8-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "subtree "
},
{
  "id": "trees_vocabulary-and-definitions-3-9-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-9-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "leaf node "
},
{
  "id": "trees_vocabulary-and-definitions-3-10-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-10-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "level "
},
{
  "id": "trees_vocabulary-and-definitions-3-11-3",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-3-11-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "height "
},
{
  "id": "trees_vocabulary-and-definitions-6",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocabulary-and-definitions-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "binary tree "
},
{
  "id": "fig-nodeedgetree",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#fig-nodeedgetree",
  "type": "Figure",
  "number": "8.3.1",
  "title": "",
  "body": " A Tree Consisting of a Set of Nodes and Edges.   The image shows a basic conceptual diagram of a tree data structure, consisting of a set of nodes connected by edges. The top of the tree features a 'rootnode', which branches into 'child1' and 'child2'. Below 'child1', there is 'node1' with three children labeled 'child1', 'child2', and 'child3', while 'child2' branches into 'node2' with a single 'child1'. Further down, 'node1' branches into 'node3', 'node4', and 'node5', and 'node2' branches into 'node6'. The nodes are represented by rectangles, and the connecting lines represent the edges of the tree.   "
},
{
  "id": "fig-recursivetree",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#fig-recursivetree",
  "type": "Figure",
  "number": "8.3.2",
  "title": "",
  "body": " A recursive Definition of a tree.   The image presents a simplified diagram of a tree data structure with a single 'root' node at the top, branching out into three 'subtrees' labeled 'subtree-1', 'subtree-2', and 'subtree-3'. This visual model illustrates the concept of recursion in data structures, where each subtree can be seen as a smaller instance of the larger structure.   "
},
{
  "id": "trees_vocab_1",
  "level": "2",
  "url": "trees_vocabulary-and-definitions.html#trees_vocab_1",
  "type": "Reading Question",
  "number": "8.3.1",
  "title": "",
  "body": " In your own words, define a tree relative to the first definition provided above.  "
},
{
  "id": "trees_nodes-and-references",
  "level": "1",
  "url": "trees_nodes-and-references.html",
  "type": "Section",
  "number": "8.4",
  "title": "Nodes and References",
  "body": " Nodes and References  Our second method to represent a tree uses nodes and references. In this case we will define a class that has attributes for the root value, as well as the left and right subtrees. Since this representation more closely follows the object-oriented programming paradigm, we will continue to use this representation for the remainder of the chapter.  Using nodes and references, we might think of the tree as being structured like the one shown in .   A Simple Tree Using a Nodes and References Approach.   Illustration of a binary tree structure with three levels. The top level shows a single node labeled 'a' with two pointers 'left' and 'right'. The second level has two nodes: 'b' on the left with its own 'left' and 'right' pointers, and 'c' on the right with pointers also labeled 'left' and 'right'. The third level shows three nodes: 'd' is the left child of 'b' with 'left' and 'right' pointers; 'e' is the right child of 'b' with pointers labeled 'left' and 'right'; 'f' is the right child of 'c' also with 'left' and 'right' pointers. Each pointer is represented by an arrow indicating the direction of the reference.    We will start out with a simple class definition for the nodes and references approach as shown in . The important thing to remember about this representation is that the attributes left and right will become references to other instances of the BinaryTree class. For example, when we insert a new left child into the tree we create another instance of BinaryTree and modify self.leftChild in the root to reference the new tree.   Nodes and References BinaryTree  C++ Implementation #include <iostream> #include <cstdlib> using namespace std; class BinaryTree { private: char key; BinaryTree *leftChild; BinaryTree *rightChild; public: BinaryTree(char rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } };  Python Implementation class BinaryTree: def __init__(self,rootObj): self.key = rootObj self.leftChild = None self.rightChild = None   Notice that in , the constructor function expects to get some kind of object to store in the root. Just like you can store any object you like in an array, the root object of a tree can be a reference to any object. For our early examples, we will store the name of the node as the root value. Using nodes and references to represent the tree in , we would create six instances of the BinaryTree class.  Next let's look at the functions we need to build the tree beyond the root node. To add a left child to the tree, we will create a new binary tree object and set the left attribute of the root to refer to this new object. The code for insertLeft is shown in .   insertLeft  C++ Implementation void insertLeft(char newNode){ if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } }  Python Implementation def insertLeft(self,newNode): if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.leftChild = self.leftChild self.leftChild = t   We must consider two cases for insertion. The first case is characterized by a node with no existing left child. When there is no left child, simply add a node to the tree. The second case is characterized by a node with an existing left child. In the second case, we insert a node and push the existing child down one level in the tree. The second case is handled by the else statement on line 4 of .  The code for insertRight must consider a symmetric set of cases. There will either be no right child, or we must insert the node between the root and an existing right child. The insertion code is shown in .   insertRight  C++ Implementation void insertRight(char newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } }  Python Implementation def insertRight(self,newNode): if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.rightChild = self.rightChild self.rightChild = t   To round out the definition for a simple binary tree data structure, we will write accessor methods (see ) for the left and right children, as well as the root values.   Accessor Methods for BinaryTree  C++ Implementation BinaryTree *getRightChild(){ return this->rightChild; } BinaryTree *getLeftChild(){ return this->leftChild; } void setRootVal(char obj){ this->key = obj; } char getRootVal(){ return this->key; }  Python Implementation ef getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self,obj): self.key = obj def getRootVal(self): return self.key   Now that we have all the pieces to create and manipulate a binary tree, let's use them to check on the structure a bit more. Let's make a simple tree with node a as the root, and add nodes b and c as children. creates the tree and looks at the some of the values stored in key , left , and right . Notice that both the left and right children of the root are themselves distinct instances of the BinaryTree class. As we said in our original recursive definition for a tree, this allows us to treat any child of a binary tree as a binary tree itself.   Accessor Methods for BinaryTree  C++ Implementation #include <iostream> #include <cstdlib> using namespace std; \/\/creates a binary tree, allows you to insert nodes \/\/ and access those nodes. class BinaryTree { private: char key; BinaryTree *leftChild; \/\/ reference other instances of the binary tree the BinaryTree class BinaryTree *rightChild; \/\/ reference other instances of the binary tree the BinaryTree class public: \/\/constructor function expects to get some kind of object to store in the root BinaryTree(char rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } void insertLeft(char newNode){ \/\/ Handles insertion if there is no left child simply adds a node to the tree. if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { \/\/ handles insertion if there is a left child pushes the existing child down one level in the tree. BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } } void insertRight(char newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } } BinaryTree *getRightChild(){ \/\/ accessor method return this->rightChild; } BinaryTree *getLeftChild(){ \/\/ accessor method return this->leftChild; } void setRootVal(char obj){ \/\/ accessor method this->key = obj; } char getRootVal(){ \/\/ accessor method return this->key; } }; int main() { BinaryTree *r = new BinaryTree('a'); cout << r->getRootVal() << endl; cout << r->getLeftChild() << endl; r->insertLeft('b'); cout << r->getLeftChild() << endl; cout << r->getLeftChild()->getRootVal() << endl; r->insertRight('c'); cout << r->getRightChild() << endl; cout << r->getRightChild()->getRootVal() << endl; r->getRightChild()->setRootVal('d'); cout << r->getRightChild()->getRootVal() << endl; return 0; }  Python Implementation \"\"\" creates a binary tree, allows you to insert nodes and access those nodes. \"\"\" class BinaryTree: def __init__(self,rootObj): # initializer function expects to get some kind of object to store in the root self.key = rootObj self.leftChild = None # reference other instances of the binary tree the BinaryTree class self.rightChild = None # reference other instances of the binary tree the BinaryTree class def insertLeft(self,newNode): # Handles insertion if there is no left child simply adds a node to the tree. if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) # handles insertion if there is a left child pushes the existing child down one level in the tree. t.leftChild = self.leftChild self.leftChild = t def insertRight(self,newNode): # Handles insertion if there is no right child simply adds a node to the tree if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: # handles insertion if there is a right child pushes the existing child down one level in the tree. t = BinaryTree(newNode) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): # accessor method return self.rightChild def getLeftChild(self): # accessor method return self.leftChild def setRootVal(self,obj): # accessor method self.key = obj def getRootVal(self): # accessor method return self.key def main(): r = BinaryTree('a') print(r.getRootVal()) print(r.getLeftChild()) r.insertLeft('b') print(r.getLeftChild()) print(r.getLeftChild().getRootVal()) r.insertRight('c') print(r.getRightChild()) print(r.getRightChild().getRootVal()) r.getRightChild().setRootVal('d') print(r.getRightChild().getRootVal()) main()    Reading Question   Which data structure resembles the above implementation of a tree?     Hash Table    Incorrect, a hash table maps key, value pairs for quick access. To access an item in our tree, we have to go through everything before it.      Linked List    Correct, this tree is essentially a linked list connecting other linked lists      Queue    Incorrect, a queue is good for putting data in to fit a FIFO sequence      Stack    Incorrect, a stack is good for putting data in to fit a LIFO sequence      "
},
{
  "id": "fig-treerec",
  "level": "2",
  "url": "trees_nodes-and-references.html#fig-treerec",
  "type": "Figure",
  "number": "8.4.1",
  "title": "",
  "body": " A Simple Tree Using a Nodes and References Approach.   Illustration of a binary tree structure with three levels. The top level shows a single node labeled 'a' with two pointers 'left' and 'right'. The second level has two nodes: 'b' on the left with its own 'left' and 'right' pointers, and 'c' on the right with pointers also labeled 'left' and 'right'. The third level shows three nodes: 'd' is the left child of 'b' with 'left' and 'right' pointers; 'e' is the right child of 'b' with pointers labeled 'left' and 'right'; 'f' is the right child of 'c' also with 'left' and 'right' pointers. Each pointer is represented by an arrow indicating the direction of the reference.   "
},
{
  "id": "expl-nar",
  "level": "2",
  "url": "trees_nodes-and-references.html#expl-nar",
  "type": "Exploration",
  "number": "8.4.1",
  "title": "Nodes and References <code class=\"code-inline tex2jax_ignore\">BinaryTree<\/code>.",
  "body": " Nodes and References BinaryTree  C++ Implementation #include <iostream> #include <cstdlib> using namespace std; class BinaryTree { private: char key; BinaryTree *leftChild; BinaryTree *rightChild; public: BinaryTree(char rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } };  Python Implementation class BinaryTree: def __init__(self,rootObj): self.key = rootObj self.leftChild = None self.rightChild = None  "
},
{
  "id": "expl-insl",
  "level": "2",
  "url": "trees_nodes-and-references.html#expl-insl",
  "type": "Exploration",
  "number": "8.4.2",
  "title": "<code class=\"code-inline tex2jax_ignore\">insertLeft<\/code>.",
  "body": " insertLeft  C++ Implementation void insertLeft(char newNode){ if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } }  Python Implementation def insertLeft(self,newNode): if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.leftChild = self.leftChild self.leftChild = t  "
},
{
  "id": "expl-insr",
  "level": "2",
  "url": "trees_nodes-and-references.html#expl-insr",
  "type": "Exploration",
  "number": "8.4.3",
  "title": "<code class=\"code-inline tex2jax_ignore\">insertRight<\/code>.",
  "body": " insertRight  C++ Implementation void insertRight(char newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } }  Python Implementation def insertRight(self,newNode): if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.rightChild = self.rightChild self.rightChild = t  "
},
{
  "id": "expl-naracc",
  "level": "2",
  "url": "trees_nodes-and-references.html#expl-naracc",
  "type": "Exploration",
  "number": "8.4.4",
  "title": "Accessor Methods for <code class=\"code-inline tex2jax_ignore\">BinaryTree<\/code>.",
  "body": " Accessor Methods for BinaryTree  C++ Implementation BinaryTree *getRightChild(){ return this->rightChild; } BinaryTree *getLeftChild(){ return this->leftChild; } void setRootVal(char obj){ this->key = obj; } char getRootVal(){ return this->key; }  Python Implementation ef getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self,obj): self.key = obj def getRootVal(self): return self.key  "
},
{
  "id": "expl-comptest",
  "level": "2",
  "url": "trees_nodes-and-references.html#expl-comptest",
  "type": "Exploration",
  "number": "8.4.5",
  "title": "Accessor Methods for <code class=\"code-inline tex2jax_ignore\">BinaryTree<\/code>.",
  "body": " Accessor Methods for BinaryTree  C++ Implementation #include <iostream> #include <cstdlib> using namespace std; \/\/creates a binary tree, allows you to insert nodes \/\/ and access those nodes. class BinaryTree { private: char key; BinaryTree *leftChild; \/\/ reference other instances of the binary tree the BinaryTree class BinaryTree *rightChild; \/\/ reference other instances of the binary tree the BinaryTree class public: \/\/constructor function expects to get some kind of object to store in the root BinaryTree(char rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } void insertLeft(char newNode){ \/\/ Handles insertion if there is no left child simply adds a node to the tree. if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { \/\/ handles insertion if there is a left child pushes the existing child down one level in the tree. BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } } void insertRight(char newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } } BinaryTree *getRightChild(){ \/\/ accessor method return this->rightChild; } BinaryTree *getLeftChild(){ \/\/ accessor method return this->leftChild; } void setRootVal(char obj){ \/\/ accessor method this->key = obj; } char getRootVal(){ \/\/ accessor method return this->key; } }; int main() { BinaryTree *r = new BinaryTree('a'); cout << r->getRootVal() << endl; cout << r->getLeftChild() << endl; r->insertLeft('b'); cout << r->getLeftChild() << endl; cout << r->getLeftChild()->getRootVal() << endl; r->insertRight('c'); cout << r->getRightChild() << endl; cout << r->getRightChild()->getRootVal() << endl; r->getRightChild()->setRootVal('d'); cout << r->getRightChild()->getRootVal() << endl; return 0; }  Python Implementation \"\"\" creates a binary tree, allows you to insert nodes and access those nodes. \"\"\" class BinaryTree: def __init__(self,rootObj): # initializer function expects to get some kind of object to store in the root self.key = rootObj self.leftChild = None # reference other instances of the binary tree the BinaryTree class self.rightChild = None # reference other instances of the binary tree the BinaryTree class def insertLeft(self,newNode): # Handles insertion if there is no left child simply adds a node to the tree. if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) # handles insertion if there is a left child pushes the existing child down one level in the tree. t.leftChild = self.leftChild self.leftChild = t def insertRight(self,newNode): # Handles insertion if there is no right child simply adds a node to the tree if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: # handles insertion if there is a right child pushes the existing child down one level in the tree. t = BinaryTree(newNode) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): # accessor method return self.rightChild def getLeftChild(self): # accessor method return self.leftChild def setRootVal(self,obj): # accessor method self.key = obj def getRootVal(self): # accessor method return self.key def main(): r = BinaryTree('a') print(r.getRootVal()) print(r.getLeftChild()) r.insertLeft('b') print(r.getLeftChild()) print(r.getLeftChild().getRootVal()) r.insertRight('c') print(r.getRightChild()) print(r.getRightChild().getRootVal()) r.getRightChild().setRootVal('d') print(r.getRightChild().getRootVal()) main()  "
},
{
  "id": "treeLike",
  "level": "2",
  "url": "trees_nodes-and-references.html#treeLike",
  "type": "Reading Question",
  "number": "8.4.1",
  "title": "",
  "body": " Which data structure resembles the above implementation of a tree?     Hash Table    Incorrect, a hash table maps key, value pairs for quick access. To access an item in our tree, we have to go through everything before it.      Linked List    Correct, this tree is essentially a linked list connecting other linked lists      Queue    Incorrect, a queue is good for putting data in to fit a FIFO sequence      Stack    Incorrect, a stack is good for putting data in to fit a LIFO sequence    "
},
{
  "id": "trees_parse-tree",
  "level": "1",
  "url": "trees_parse-tree.html",
  "type": "Section",
  "number": "8.5",
  "title": "Parse Tree",
  "body": " Parse Tree  With the implementation of our tree data structure complete, we now look at an example of how a tree can be used to solve some real problems. In this section we will look at parse trees. Parse trees can be used to represent real-world constructions like sentences or mathematical expressions.   A Parse Tree for a Simple Sentence.   Diagram of a parse tree for linguistic analysis. The root of the tree is labeled 'Sentence' which splits into two branches: 'Noun Phrase' and 'Verb Phrase'. The 'Noun Phrase' branch further breaks down into 'Proper Noun', which leads to the word 'Homer'. The 'Verb Phrase' branch divides into 'Verb', leading to the word 'Hit', and another 'Noun Phrase', which further breaks down into 'Proper Noun', leading to the word 'Bart'. The structure illustrates the grammatical relationships in a simple sentence.    shows the hierarchical structure of a simple sentence. Representing a sentence as a tree structure allows us to work with the individual parts of the sentence by using subtrees.   Parse Tree for .   Diagram of a parse tree for an arithmetic expression. The root node is an asterisk '*', indicating multiplication. It has two child nodes: on the left, a plus sign '+' connects the numbers 7 and 3, and on the right, a minus sign '-' connects the numbers 5 and 2. This tree represents the mathematical expression ((7 + 3) * (5 - 2)). The image is labeled 'Figure 2: Parse Tree for ((7 + 3) * (5 - 2)).    We can also represent a mathematical expression such as as a parse tree, as shown in . We have already looked at fully parenthesized expressions, so what do we know about this expression? We know that multiplication has a higher precedence than either addition or subtraction. Because of the parentheses, we know that before we can do the multiplication we must evaluate the parenthesized addition and subtraction expressions. The hierarchy of the tree helps us understand the order of evaluation for the whole expression. Before we can evaluate the top-level multiplication, we must evaluate the addition and the subtraction in the subtrees. The addition, which is the left subtree, evaluates to 10. The subtraction, which is the right subtree, evaluates to 3. Using the hierarchical structure of trees, we can simply replace an entire subtree with one node once we have evaluated the expressions in the children. Applying this replacement procedure gives us the simplified tree shown in .   A Simplified Parse Tree for .   Diagram of a simplified parse tree for an arithmetic expression after evaluation. The root node is an asterisk '*', indicating multiplication. It has two child nodes, which are the results of the arithmetic operations: the number 10 on the left, which is the sum of 7 and 3, and the number 3 on the right, which is the result of subtracting 2 from 5. This tree represents the evaluated mathematical expression ((7 + 3) * (5 - 2)). The image is labeled 'Figure 3: A Simplified Parse Tree for ((7 + 3) * (5 - 2)).    In the rest of this section we are going to examine parse trees in more detail. In particular we will look at    How to build a parse tree from a fully parenthesized mathematical expression.    How to evaluate the expression stored in a parse tree.    How to recover the original mathematical expression from a parse tree.    The first step in building a parse tree is to break up the expression string into a vector of tokens. There are four different kinds of tokens to consider: left parentheses, right parentheses, operators, and operands. We know that whenever we read a left parenthesis we are starting a new expression, and hence we should create a new tree to correspond to that expression. Conversely, whenever we read a right parenthesis, we have finished an expression. We also know that operands are going to be leaf nodes and children of their operators. Finally, we know that every operator is going to have both a left and a right child.  Using the information from above we can define four rules as follows:    If the current token is a '(' , add a new node as the left child of the current node, and descend to the left child.    If the current token is in the vector ['+','-','\/','*'] , set the root value of the current node to the operator represented by the current token. Add a new node as the right child of the current node and descend to the right child.    If the current token is a number, set the root value of the current node to the number and return to the parent.    If the current token is a ')' , go to the parent of the current node.    Before writing the C++ code, let's look at an example of the rules outlined above in action. We will use the expression . We will parse this expression into the following vector of character tokens ['(', '3', '+',  '(', '4', '*', '5' ,')',')'] . Initially we will start out with a parse tree that consists of an empty root node. illustrates the structure and contents of the parse tree, as each new token is processed.   Tracing Parse Tree Construction.          A vertical sequence of diagrams illustrating the construction of a binary search tree with numerical values. At the top, there is a single node. As the sequence progresses downwards, nodes are added one by one in binary search tree order, with some nodes shaded to indicate the most recently added node. Each node contains a number, and they are linked by lines representing the tree structure. The numbers in the nodes are not visible, so their specific values are not identifiable in this description.    Using , let's walk through the example step by step:    Create an empty tree.    Read ( as the first token. By rule 1, create a new node as the left child of the root. Make the current node this new child.    Read 3 as the next token. By rule 3, set the root value of the current node to 3 and go back up the tree to the parent.    Read + as the next token. By rule 2, set the root value of the current node to + and add a new node as the right child. The new right child becomes the current node.    Read ( as the next token. By rule 1, create a new node as the left child of the current node. The new left child becomes the current node.    Read 4 as the next token. By rule 3, set the value of the current node to 4. Make the parent of 4 the current node.    Read * as the next token. By rule 2, set the root value of the current node to * and create a new right child. The new right child becomes the current node.    Read 5 as the next token. By rule 3, set the root value of the current node to 5. Make the parent of 5 the current node.    Read ) as the next token. By rule 4 we make the parent of * the current node.    Read ) as the next token. By rule 4 we make the parent of + the current node. At this point there is no parent for + so we are done.    From the example above, it is clear that we need to keep track of the current node as well as the parent of the current node. The tree interface provides us with a way to get children of a node, through the getLeftChild and getRightChild methods, but how can we keep track of the parent? A simple solution to keeping track of parents as we traverse the tree is to use a stack. Whenever we want to descend to a child of the current node, we first push the current node on the stack. When we want to return to the parent of the current node, we pop the parent off the stack.  Using the rules described above, along with the Stack and BinaryTree operations, we are now ready to write a C++ function to create a parse tree. The code for our parse tree builder is presented in .   Building A Parse Tree  C++ Implementation #include <iostream> #include <cstdlib> #include <stack> #include <sstream> #include <string> #include <vector> #include <algorithm> using namespace std; class BinaryTree { private: string key; BinaryTree *leftChild; BinaryTree *rightChild; public: BinaryTree(string rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } void insertLeft(string newNode){ if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } } void insertRight(string newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } } BinaryTree *getRightChild(){ return this->rightChild; } BinaryTree *getLeftChild(){ return this->leftChild; } void setRootVal(string obj){ this->key = obj; } string getRootVal(){ return this->key; } }; BinaryTree *buildParseTree(string fpexp){ string buf; stringstream ss(fpexp); vector<string> fplist; while (ss >> buf){ fplist.push_back(buf); } stack<BinaryTree*> pStack; BinaryTree *eTree = new BinaryTree(\"\"); pStack.push(eTree); BinaryTree *currentTree = eTree; string arr[] = {\"+\", \"-\", \"*\", \"\/\"}; vector<string> vect(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); string arr2[] = {\"+\", \"-\", \"*\", \"\/\", \")\"}; vector<string> vect2(arr2,arr2+(sizeof(arr2)\/ sizeof(arr2[0]))); for (unsigned int i = 0; i<fplist.size(); i++){ if (fplist[i] == \"(\"){ currentTree->insertLeft(\"\"); pStack.push(currentTree); currentTree = currentTree->getLeftChild(); } else if (find(vect.begin(), vect.end(), fplist[i]) != vect.end()){ currentTree->setRootVal(fplist[i]); currentTree->insertRight(\"\"); pStack.push(currentTree); currentTree = currentTree->getRightChild(); } else if (fplist[i] == \")\"){ currentTree = pStack.top(); pStack.pop(); } else if (find(vect2.begin(), vect2.end(), fplist[i]) == vect2.end()) { try { currentTree->setRootVal(fplist[i]); BinaryTree *parent = pStack.top(); pStack.pop(); currentTree = parent; } catch (string ValueError ){ cerr <<\"token \" << fplist[i] << \" is not a valid integer\"<<endl; } } } return eTree; } void postorder(BinaryTree *tree){ if (tree != NULL){ postorder(tree->getLeftChild()); postorder(tree->getRightChild()); cout << tree->getRootVal() << endl; } } int main() { BinaryTree *pt = buildParseTree(\"( ( 10 + 5 ) * 3 )\"); postorder(pt); return 0; }  Python Implementation from pythonds.basic.stack import Stack from pythonds.trees.binaryTree import BinaryTree def buildParseTree(fpexp): fplist = fpexp.split() pStack = Stack() eTree = BinaryTree('') pStack.push(eTree) currentTree = eTree for i in fplist: if i == '(': # adds a new node as the left child of the current node, and descend to the left child currentTree.insertLeft('') pStack.push(currentTree) currentTree = currentTree.getLeftChild() elif i in ['+', '-', '*', '\/']: currentTree.setRootVal(i) # adds a new node as the right child of the current node, and descend to the left child currentTree.insertRight('') pStack.push(currentTree) currentTree = currentTree.getRightChild() elif i == ')': currentTree = pStack.pop() elif i not in ['+', '-', '*', '\/', ')']: # sets root value of the current node to the operator represented by the current token or number. try: currentTree.setRootVal(int(i)) parent = pStack.pop() currentTree = parent except ValueError: raise ValueError(\"token '{}' is not a valid integer\".format(i)) return eTree def main(): pt = buildParseTree(\"( ( 10 + 5 ) * 3 )\") pt.postorder() #defined and explained in the next section main()   The four rules for building a parse tree are coded as the first four clauses of the if statement on lines 12, 17, 23, and 26 of . In each case you can see that the code implements the rule, as described above, with a few calls to the BinaryTree or Stack methods. The only error checking we do in this function is in the else clause where a ValueError exception will be raised if we get a token from the vector that we do not recognize.  Now that we have built a parse tree, what can we do with it? As a first example, we will write a function to evaluate the parse tree, returning the numerical result. To write this function, we will make use of the hierarchical nature of the tree. Look back at . Recall that we can replace the original tree with the simplified tree shown in . This suggests that we can write an algorithm that evaluates a parse tree by recursively evaluating each subtree.  As we have done with past recursive algorithms, we will begin the design for the recursive evaluation function by identifying the base case. A natural base case for recursive algorithms that operate on trees is to check for a leaf node. In a parse tree, the leaf nodes will always be operands. Since numerical objects like integers and floating points require no further interpretation, the evaluate function can simply return the value stored in the leaf node. The recursive step that moves the function toward the base case is to call evaluate on both the left and the right children of the current node. The recursive call effectively moves us down the tree, toward a leaf node.  To put the results of the two recursive calls together, we can simply apply the operator stored in the parent node to the results returned from evaluating both children. In the example from we see that the two children of the root evaluate to themselves, namely 10 and 3. Applying the multiplication operator gives us a final result of 30.  The code for a recursive evaluate function is shown in . First, we obtain references to the left and the right children of the current node. If both the left and right children evaluate to None , then we know that the current node is really a leaf node. This check is on line 7. If the current node is not a leaf node, look up the operator in the current node and apply it to the results from recursively evaluating the left and right children.  To implement the arithmetic, we use a dictionary with the keys '+', '-', '*' , and '\/' . The values stored in the dictionary are functions from C++'s operator module. The operator module provides us with the functional versions of many commonly used operators. When we look up an operator in the dictionary, the corresponding function object is retrieved. Since the retrieved object is a function, we can call it in the usual way function(param1,param2) . So the lookup opers['+'](2,2) is equivalent to operator.add(2,2) .   Evaluating A Parse Tree  C++ Implementation class Operator { public: int add(int x, int y){ return x + y; } int sub(int x, int y){ return x - y; } int mul(int x, int y){ return x * y; } int div(int x, int y){ return x \/ y; } }; int to_int(string str) { stringstream convert(str); int x = 0; convert >> x; return x; } string to_string(int num) { string str; ostringstream convert; convert << num; str = convert.str(); return str; } string evaluate(BinaryTree *parseTree) { Operator Oper; BinaryTree *leftC = parseTree->getLeftChild(); BinaryTree *rightC = parseTree->getRightChild(); if (leftC && rightC) { if (parseTree->getRootVal() == \"+\") { return to_string(Oper.add(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"-\") { return to_string(Oper.sub(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"*\") { return to_string(Oper.mul(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else { return to_string(Oper.div(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } } else { return parseTree->getRootVal(); } } int main(){ return 0; }  Python Implementation def evaluate(parseTree): opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '\/':operator.truediv} leftC = parseTree.getLeftChild() rightC = parseTree.getRightChild() if leftC and rightC: fn = opers[parseTree.getRootVal()] return fn(evaluate(leftC),evaluate(rightC)) else: return parseTree.getRootVal()   Finally, we will trace the evaluate function on the parse tree we created in . When we first call evaluate , we pass the root of the entire tree as the parameter parseTree . Then we obtain references to the left and right children to make sure they exist. The recursive call takes place on line 9. We begin by looking up the operator in the root of the tree, which is '+' . The '+' operator maps to the operator.add function call, which takes two parameters. As usual for a C++ function call, the first thing C++ does is to evaluate the parameters that are passed to the function. In this case both parameters are recursive function calls to our evaluate function. Using left-to-right evaluation, the first recursive call goes to the left. In the first recursive call the evaluate function is given the left subtree. We find that the node has no left or right children, so we are in a leaf node. When we are in a leaf node we just return the value stored in the leaf node as the result of the evaluation. In this case we return the integer 3.  At this point we have one parameter evaluated for our top-level call to operator.add . But we are not done yet. Continuing the left-to-right evaluation of the parameters, we now make a recursive call to evaluate the right child of the root. We find that the node has both a left and a right child so we look up the operator stored in this node, '*' , and call this function using the left and right children as the parameters. At this point you can see that both recursive calls will be to leaf nodes, which will evaluate to the integers four and five respectively. With the two parameters evaluated, we return the result of operator.mul(4,5) . At this point we have evaluated the operands for the top level '+' operator and all that is left to do is finish the call to operator.add(3,20) . The result of the evaluation of the entire expression tree for is 23.   Reading Question   Take a moment and draw the parse tree for the expression (2*12\/6+3)-17+2*0. You do not need to write anything here.    "
},
{
  "id": "fig-nlparse",
  "level": "2",
  "url": "trees_parse-tree.html#fig-nlparse",
  "type": "Figure",
  "number": "8.5.1",
  "title": "",
  "body": " A Parse Tree for a Simple Sentence.   Diagram of a parse tree for linguistic analysis. The root of the tree is labeled 'Sentence' which splits into two branches: 'Noun Phrase' and 'Verb Phrase'. The 'Noun Phrase' branch further breaks down into 'Proper Noun', which leads to the word 'Homer'. The 'Verb Phrase' branch divides into 'Verb', leading to the word 'Hit', and another 'Noun Phrase', which further breaks down into 'Proper Noun', leading to the word 'Bart'. The structure illustrates the grammatical relationships in a simple sentence.   "
},
{
  "id": "fig-meparse",
  "level": "2",
  "url": "trees_parse-tree.html#fig-meparse",
  "type": "Figure",
  "number": "8.5.2",
  "title": "",
  "body": " Parse Tree for .   Diagram of a parse tree for an arithmetic expression. The root node is an asterisk '*', indicating multiplication. It has two child nodes: on the left, a plus sign '+' connects the numbers 7 and 3, and on the right, a minus sign '-' connects the numbers 5 and 2. This tree represents the mathematical expression ((7 + 3) * (5 - 2)). The image is labeled 'Figure 2: Parse Tree for ((7 + 3) * (5 - 2)).   "
},
{
  "id": "fig-mesimple",
  "level": "2",
  "url": "trees_parse-tree.html#fig-mesimple",
  "type": "Figure",
  "number": "8.5.3",
  "title": "",
  "body": " A Simplified Parse Tree for .   Diagram of a simplified parse tree for an arithmetic expression after evaluation. The root node is an asterisk '*', indicating multiplication. It has two child nodes, which are the results of the arithmetic operations: the number 10 on the left, which is the sum of 7 and 3, and the number 3 on the right, which is the result of subtracting 2 from 5. This tree represents the evaluated mathematical expression ((7 + 3) * (5 - 2)). The image is labeled 'Figure 3: A Simplified Parse Tree for ((7 + 3) * (5 - 2)).   "
},
{
  "id": "parse_fig-bldexpstep",
  "level": "2",
  "url": "trees_parse-tree.html#parse_fig-bldexpstep",
  "type": "Figure",
  "number": "8.5.4",
  "title": "",
  "body": " Tracing Parse Tree Construction.          A vertical sequence of diagrams illustrating the construction of a binary search tree with numerical values. At the top, there is a single node. As the sequence progresses downwards, nodes are added one by one in binary search tree order, with some nodes shaded to indicate the most recently added node. Each node contains a number, and they are linked by lines representing the tree structure. The numbers in the nodes are not visible, so their specific values are not identifiable in this description.   "
},
{
  "id": "expl-buildparse",
  "level": "2",
  "url": "trees_parse-tree.html#expl-buildparse",
  "type": "Exploration",
  "number": "8.5.1",
  "title": "Building A Parse Tree.",
  "body": " Building A Parse Tree  C++ Implementation #include <iostream> #include <cstdlib> #include <stack> #include <sstream> #include <string> #include <vector> #include <algorithm> using namespace std; class BinaryTree { private: string key; BinaryTree *leftChild; BinaryTree *rightChild; public: BinaryTree(string rootObj){ this->key = rootObj; this->leftChild = NULL; this->rightChild = NULL; } void insertLeft(string newNode){ if (this->leftChild == NULL){ this->leftChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->leftChild = this->leftChild; this->leftChild = t; } } void insertRight(string newNode){ if (this->rightChild == NULL){ this->rightChild = new BinaryTree(newNode); } else { BinaryTree *t = new BinaryTree(newNode); t->rightChild = this->rightChild; this->rightChild = t; } } BinaryTree *getRightChild(){ return this->rightChild; } BinaryTree *getLeftChild(){ return this->leftChild; } void setRootVal(string obj){ this->key = obj; } string getRootVal(){ return this->key; } }; BinaryTree *buildParseTree(string fpexp){ string buf; stringstream ss(fpexp); vector<string> fplist; while (ss >> buf){ fplist.push_back(buf); } stack<BinaryTree*> pStack; BinaryTree *eTree = new BinaryTree(\"\"); pStack.push(eTree); BinaryTree *currentTree = eTree; string arr[] = {\"+\", \"-\", \"*\", \"\/\"}; vector<string> vect(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); string arr2[] = {\"+\", \"-\", \"*\", \"\/\", \")\"}; vector<string> vect2(arr2,arr2+(sizeof(arr2)\/ sizeof(arr2[0]))); for (unsigned int i = 0; i<fplist.size(); i++){ if (fplist[i] == \"(\"){ currentTree->insertLeft(\"\"); pStack.push(currentTree); currentTree = currentTree->getLeftChild(); } else if (find(vect.begin(), vect.end(), fplist[i]) != vect.end()){ currentTree->setRootVal(fplist[i]); currentTree->insertRight(\"\"); pStack.push(currentTree); currentTree = currentTree->getRightChild(); } else if (fplist[i] == \")\"){ currentTree = pStack.top(); pStack.pop(); } else if (find(vect2.begin(), vect2.end(), fplist[i]) == vect2.end()) { try { currentTree->setRootVal(fplist[i]); BinaryTree *parent = pStack.top(); pStack.pop(); currentTree = parent; } catch (string ValueError ){ cerr <<\"token \" << fplist[i] << \" is not a valid integer\"<<endl; } } } return eTree; } void postorder(BinaryTree *tree){ if (tree != NULL){ postorder(tree->getLeftChild()); postorder(tree->getRightChild()); cout << tree->getRootVal() << endl; } } int main() { BinaryTree *pt = buildParseTree(\"( ( 10 + 5 ) * 3 )\"); postorder(pt); return 0; }  Python Implementation from pythonds.basic.stack import Stack from pythonds.trees.binaryTree import BinaryTree def buildParseTree(fpexp): fplist = fpexp.split() pStack = Stack() eTree = BinaryTree('') pStack.push(eTree) currentTree = eTree for i in fplist: if i == '(': # adds a new node as the left child of the current node, and descend to the left child currentTree.insertLeft('') pStack.push(currentTree) currentTree = currentTree.getLeftChild() elif i in ['+', '-', '*', '\/']: currentTree.setRootVal(i) # adds a new node as the right child of the current node, and descend to the left child currentTree.insertRight('') pStack.push(currentTree) currentTree = currentTree.getRightChild() elif i == ')': currentTree = pStack.pop() elif i not in ['+', '-', '*', '\/', ')']: # sets root value of the current node to the operator represented by the current token or number. try: currentTree.setRootVal(int(i)) parent = pStack.pop() currentTree = parent except ValueError: raise ValueError(\"token '{}' is not a valid integer\".format(i)) return eTree def main(): pt = buildParseTree(\"( ( 10 + 5 ) * 3 )\") pt.postorder() #defined and explained in the next section main()  "
},
{
  "id": "expl-eval",
  "level": "2",
  "url": "trees_parse-tree.html#expl-eval",
  "type": "Exploration",
  "number": "8.5.2",
  "title": "Evaluating A Parse Tree.",
  "body": " Evaluating A Parse Tree  C++ Implementation class Operator { public: int add(int x, int y){ return x + y; } int sub(int x, int y){ return x - y; } int mul(int x, int y){ return x * y; } int div(int x, int y){ return x \/ y; } }; int to_int(string str) { stringstream convert(str); int x = 0; convert >> x; return x; } string to_string(int num) { string str; ostringstream convert; convert << num; str = convert.str(); return str; } string evaluate(BinaryTree *parseTree) { Operator Oper; BinaryTree *leftC = parseTree->getLeftChild(); BinaryTree *rightC = parseTree->getRightChild(); if (leftC && rightC) { if (parseTree->getRootVal() == \"+\") { return to_string(Oper.add(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"-\") { return to_string(Oper.sub(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"*\") { return to_string(Oper.mul(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else { return to_string(Oper.div(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } } else { return parseTree->getRootVal(); } } int main(){ return 0; }  Python Implementation def evaluate(parseTree): opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '\/':operator.truediv} leftC = parseTree.getLeftChild() rightC = parseTree.getRightChild() if leftC and rightC: fn = opers[parseTree.getRootVal()] return fn(evaluate(leftC),evaluate(rightC)) else: return parseTree.getRootVal()  "
},
{
  "id": "drawParseTree",
  "level": "2",
  "url": "trees_parse-tree.html#drawParseTree",
  "type": "Reading Question",
  "number": "8.5.1",
  "title": "",
  "body": " Take a moment and draw the parse tree for the expression (2*12\/6+3)-17+2*0. You do not need to write anything here.  "
},
{
  "id": "trees_tree-traversals",
  "level": "1",
  "url": "trees_tree-traversals.html",
  "type": "Section",
  "number": "8.6",
  "title": "Tree Traversals",
  "body": " Tree Traversals  Now that we have examined the basic functionality of our tree data structure, it is time to look at some additional usage patterns for trees. These usage patterns can be divided into the three ways that we access the nodes of the tree. There are three commonly used patterns to visit all the nodes in a tree. The difference between these patterns is the order in which each node is visited. We call this visitation of the nodes a traversal. The three traversals we will look at are called preorder , inorder , and postorder . Let's start out by defining these three traversals more carefully, then look at some examples where these patterns are useful.   Example tree to be traversed.   Illustration of a binary tree. The top node is labeled '1', and it splits into two child nodes labeled '3' on the left and '8' on the right. The '3' node further splits into two child nodes labeled '7' on the left and '5' on the right. The '8' node also splits into two children, with '2' on the left and '9' on the right. The nodes are connected by lines indicating the tree structure.      preorder  In a preorder traversal, we visit the root node first, then recursively do a preorder traversal of the left subtree, followed by a recursive preorder traversal of the right subtree.     Traversal pattern for preorder.   Diagram of a binary tree to illustrate the preorder traversal pattern. The tree consists of a root node labeled '1', with a left child labeled '3', which in turn has two children labeled '7' and '5'. The root node also has a right child labeled '8', which has two children labeled '2' and '9'. The nodes '1', '3', '7', '5', '8', and '9' are circled, indicating the order of the preorder traversal. Arrows point from the root node '1' to the left child '3', then to '7', back up through '3' to '5', then to the right child '8', and finally to '9', following the preorder traversal pattern. The image is labeled 'Figure 6: Traversal pattern for preorder'.      inorder  In an inorder traversal, we recursively do an inorder traversal on the left subtree, visit the root node, and finally do a recursive inorder traversal of the right subtree.     Traversal pattern for inorder.   Diagram of a binary tree to illustrate the inorder traversal pattern. The tree has a root node at the top labeled '1', which branches out to a left child labeled '3' and a right child labeled '8'. The '3' node has further children labeled '7' and '5', and the '8' node has children labeled '2' and '9'. The nodes are not circled, but the traversal pattern is indicated by a black arrow starting from the '3' node, moving to its left child '7', then up to '3', across to '5', up to '1', then to '8', down to '2', and finally to '9' on the far right. This pattern represents the inorder traversal where you visit the left subtree, the node itself, and then the right subtree.      postorder  In a postorder traversal, we recursively do a postorder traversal of the left subtree and the right subtree followed by a visit to the root node.     Traversal pattern for postorder.   Diagram of a binary tree to illustrate the postorder traversal pattern. The tree structure includes a root node labeled '1' at the top, with a left child labeled '3' and a right child labeled '8'. Node '3' has two children labeled '7' and '5', while node '8' has children labeled '2' and '9'. The traversal pattern is shown with black arrows starting at the leftmost child '7', moving up to '3', across to '5', back to '3', then to the root '1', over to the right child '8', down to '2', and finally to '9'. In postorder traversal, the nodes are visited from the bottom-up, starting with the left subtree, then the right subtree, and ending with the root node.    Let's look at some examples that illustrate each of these three kinds of traversals. First let's look at the preorder traversal. As an example of a tree to traverse, we will represent this book as a tree. The book is the root of the tree, and each chapter is a child of the root. Each section within a chapter is a child of the chapter, and each subsection is a child of its section, and so on. shows a limited version of a book with only two chapters. Note that the traversal algorithm works for trees with any number of children, but we will stick with binary trees for now.   Representing a Book as a Tree.   Diagram of a hierarchical tree representing the structure of a book. The root node at the top is labeled 'Book', which branches out to two child nodes labeled 'Chapter1' and 'Chapter2'. Each chapter node further divides into sections: 'Chapter1' into 'Section 1.1' and 'Section 1.2', while 'Chapter2' splits into 'Section 2.1' and 'Section 2.2'. Each section node also branches into subsections, with 'Section 1.1' leading to 'Section 1.2.1' and 'Section 1.2.2', and 'Section 2.2' leading to 'Section 2.2.1' and 'Section 2.2.2'. The nodes are connected by lines that represent the tree structure, demonstrating the organizational hierarchy of the book's contents.    Suppose that you wanted to read this book from front to back. The preorder traversal gives you exactly that ordering. Starting at the root of the tree (the Book node) we will follow the preorder traversal instructions. We recursively call preorder on the left child, in this case Chapter1. We again recursively call preorder on the left child to get to Section 1.1. Since Section 1.1 has no children, we do not make any additional recursive calls. When we are finished with Section 1.1, we move up the tree to Chapter 1. At this point we still need to visit the right subtree of Chapter 1, which is Section 1.2. As before we visit the left subtree, which brings us to Section 1.2.1, then we visit the node for Section 1.2.2. With Section 1.2 finished, we return to Chapter 1. Then we return to the Book node and follow the same procedure for Chapter 2.  The code for writing tree traversals is surprisingly elegant, largely because the traversals are written recursively. shows the C++ code for a preorder traversal of a binary tree.  You may wonder, what is the best way to write an algorithm like preorder traversal? Should it be a function that simply uses a tree as a data structure, or should it be a method of the tree data structure itself? shows a version of the preorder traversal written as an external function that takes a binary tree as a parameter. The external function is particularly elegant because our base case is simply to check if the tree exists. If the tree parameter is None , then the function returns without taking any action.   Preorder Traversal  C++ Implementation C++ Implementation void preorder(BinaryTree *tree){ if (tree){ cout << tree->getRootVal() << endl; preorder(tree->getLeftChild()); preorder(tree->getRightChild()); } }  Python Implementation def preorder(tree): if tree: print(tree.getRootVal()) preorder(tree.getLeftChild()) preorder(tree.getRightChild())   We can also implement preorder as a method of the BinaryTree class. The code for implementing preorder as an internal method is shown in . Notice what happens when we move the code from external to internal. In general, we just replace tree with self . However, we also need to modify the base case. The internal method must check for the existence of the left and the right children before making the recursive call to preorder .   Preorder Traversal as a Method  C++ Implementation C++ Implementation void preorder(){ cout << this->key << endl; if (this->leftChild){ this->leftChild->preorder(); } if (this->rightChild){ this->rightChild->preorder(); } }  Python Implementation def preorder(self): print(self.key) if self.leftChild: self.leftChild.preorder() if self.rightChild: self.rightChild.preorder()   Which of these two ways to implement preorder is best? The answer is that implementing preorder as an external function is probably better in this case. The reason is that you very rarely want to just traverse the tree. In most cases you are going to want to accomplish something else while using one of the basic traversal patterns. In fact, we will see in the next example that the postorder traversal pattern follows very closely with the code we wrote earlier to evaluate a parse tree. Therefore we will write the rest of the traversals as external functions.  The algorithm for the postorder traversal, shown in , is nearly identical to preorder except that we move the call to print to the end of the function.   Postorder Traversal  C++ Implementation C++ Implementation void postorder(BinaryTree *tree){ if (tree != NULL){ postorder(tree->getLeftChild()); postorder(tree->getRightChild()); cout << tree->getRootVal() << endl; } }  Python Implementation def postorder(tree): if tree != None: postorder(tree.getLeftChild()) postorder(tree.getRightChild()) print(tree.getRootVal())   We have already seen a common use for the postorder traversal, namely evaluating a parse tree. Look back at again. What we are doing is evaluating the left subtree, evaluating the right subtree, and combining them in the root through the function call to an operator. Assume that our binary tree is going to store only expression tree data. Let's rewrite the evaluation function, but model it even more closely on the postorder code in (see ).   Postorder Evaluation  C++ Implementation class Operator { public: int add(int x, int y){ return x + y; } int sub(int x, int y){ return x - y; } int mul(int x, int y){ return x * y; } int div(int x, int y){ return x \/ y; } }; int to_int(string str) { stringstream convert(str); int x = 0; convert >> x; return x; } string to_string(int num) { string str; ostringstream convert; convert << num; str = convert.str(); return str; } string evaluate(BinaryTree *parseTree) { Operator Oper; BinaryTree *leftC = parseTree->getLeftChild(); BinaryTree *rightC = parseTree->getRightChild(); if (leftC && rightC) { if (parseTree->getRootVal() == \"+\") { return to_string(Oper.add(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"-\") { return to_string(Oper.sub(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"*\") { return to_string(Oper.mul(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else { return to_string(Oper.div(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } } else { return parseTree->getRootVal(); } } int main(){ return 0; }  Python Implementation def postordereval(tree): opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '\/':operator.truediv} res1 = None res2 = None if tree: res1 = postordereval(tree.getLeftChild()) res2 = postordereval(tree.getRightChild()) if res1 and res2: return opers[tree.getRootVal()](res1,res2) else: return tree.getRootVal()   Notice that the form in is the same as the form in , except that instead of printing the key at the end of the function, we return it. This allows us to save the values returned from the recursive calls in lines 6 and 7. We then use these saved values along with the operator on line 9.  The final traversal we will look at in this section is the inorder traversal. In the inorder traversal we visit the left subtree, followed by the root, and finally the right subtree. shows our code for the inorder traversal. Notice that in all three of the traversal functions we are simply changing the position of the print statement with respect to the two recursive function calls.   Inorder Traversal  C++ Implementation void inorder(BinaryTree *tree){ if (tree != NULL){ inorder(tree->getLeftChild()); cout << tree->getRootVal(); inorder(tree->getRightChild()); } }  Python Implementation def inorder(tree): if tree != None: inorder(tree.getLeftChild()) print(tree.getRootVal()) inorder(tree.getRightChild())   If we perform a simple inorder traversal of a parse tree we get our original expression back, without any parentheses. Let's modify the basic inorder algorithm to allow us to recover the fully parenthesized version of the expression. The only modifications we will make to the basic template are as follows: print a left parenthesis before the recursive call to the left subtree, and print a right parenthesis after the recursive call to the right subtree. The modified code is shown in .   Inorder Traversal  C++ Implementation string printexp(BinaryTree *tree){ string sVal; if (tree){ sVal = \"(\" + printexp(tree->getLeftChild()); sVal = sVal + tree->getRootVal(); sVal = sVal + printexp(tree->getRightChild()) + \")\"; } return sVal; }  Python Implementation def printexp(tree): sVal = \"\" if tree: sVal = '(' + printexp(tree.getLeftChild()) sVal = sVal + str(tree.getRootVal()) sVal = sVal + printexp(tree.getRightChild())+')' return sVal   Notice that the printexp function as we have implemented it puts parentheses around each number. While not incorrect, the parentheses are clearly not needed. In the exercises at the end of this chapter you are asked to modify the printexp function to remove this set of parentheses.   Reading Questions  Drag the tree traversal to its corresponding pattern. Review the tree traversal patterns. preorder root, left, right inorder left, root, right postorder left, right, root   If you print out the data at each node, what would be the result of using the preorder traversal method on ?     Book, Chapter 1, Section 1.1, Section 1.2, Section 1.2.2, Section 1.2.2, Chapter 2, Section 2.1, Section 2.2, Section 2.2.1, Section 2.2.2    correct      Section 1.1, Chapter 1.2, Section 1.2.1, Section 1.2, Section 1.2.2, Section 2.1, Chapter 2, Section 2.2.1, Section 2.2, Section 2.2.2    Incorrect, this is postorder traversal      Section 1.1, Section 1.2.1, Section 1.2.2, Section 1.2, Chapter 1, Section 2.1, Section 2.2.1, Section 2.2.2, Section 2.2, Chapter 2, Book    Incorrect, this is inorder traversal      "
},
{
  "id": "trees_tree-traversals-2",
  "level": "2",
  "url": "trees_tree-traversals.html#trees_tree-traversals-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "preorder inorder postorder "
},
{
  "id": "fig-trav-tree",
  "level": "2",
  "url": "trees_tree-traversals.html#fig-trav-tree",
  "type": "Figure",
  "number": "8.6.1",
  "title": "",
  "body": " Example tree to be traversed.   Illustration of a binary tree. The top node is labeled '1', and it splits into two child nodes labeled '3' on the left and '8' on the right. The '3' node further splits into two child nodes labeled '7' on the left and '5' on the right. The '8' node also splits into two children, with '2' on the left and '9' on the right. The nodes are connected by lines indicating the tree structure.   "
},
{
  "id": "fig-pre-order-tree",
  "level": "2",
  "url": "trees_tree-traversals.html#fig-pre-order-tree",
  "type": "Figure",
  "number": "8.6.2",
  "title": "",
  "body": " Traversal pattern for preorder.   Diagram of a binary tree to illustrate the preorder traversal pattern. The tree consists of a root node labeled '1', with a left child labeled '3', which in turn has two children labeled '7' and '5'. The root node also has a right child labeled '8', which has two children labeled '2' and '9'. The nodes '1', '3', '7', '5', '8', and '9' are circled, indicating the order of the preorder traversal. Arrows point from the root node '1' to the left child '3', then to '7', back up through '3' to '5', then to the right child '8', and finally to '9', following the preorder traversal pattern. The image is labeled 'Figure 6: Traversal pattern for preorder'.   "
},
{
  "id": "fig-in-order-tree",
  "level": "2",
  "url": "trees_tree-traversals.html#fig-in-order-tree",
  "type": "Figure",
  "number": "8.6.3",
  "title": "",
  "body": " Traversal pattern for inorder.   Diagram of a binary tree to illustrate the inorder traversal pattern. The tree has a root node at the top labeled '1', which branches out to a left child labeled '3' and a right child labeled '8'. The '3' node has further children labeled '7' and '5', and the '8' node has children labeled '2' and '9'. The nodes are not circled, but the traversal pattern is indicated by a black arrow starting from the '3' node, moving to its left child '7', then up to '3', across to '5', up to '1', then to '8', down to '2', and finally to '9' on the far right. This pattern represents the inorder traversal where you visit the left subtree, the node itself, and then the right subtree.   "
},
{
  "id": "fig-post-order-tree",
  "level": "2",
  "url": "trees_tree-traversals.html#fig-post-order-tree",
  "type": "Figure",
  "number": "8.6.4",
  "title": "",
  "body": " Traversal pattern for postorder.   Diagram of a binary tree to illustrate the postorder traversal pattern. The tree structure includes a root node labeled '1' at the top, with a left child labeled '3' and a right child labeled '8'. Node '3' has two children labeled '7' and '5', while node '8' has children labeled '2' and '9'. The traversal pattern is shown with black arrows starting at the leftmost child '7', moving up to '3', across to '5', back to '3', then to the root '1', over to the right child '8', down to '2', and finally to '9'. In postorder traversal, the nodes are visited from the bottom-up, starting with the left subtree, then the right subtree, and ending with the root node.   "
},
{
  "id": "fig-booktree",
  "level": "2",
  "url": "trees_tree-traversals.html#fig-booktree",
  "type": "Figure",
  "number": "8.6.5",
  "title": "",
  "body": " Representing a Book as a Tree.   Diagram of a hierarchical tree representing the structure of a book. The root node at the top is labeled 'Book', which branches out to two child nodes labeled 'Chapter1' and 'Chapter2'. Each chapter node further divides into sections: 'Chapter1' into 'Section 1.1' and 'Section 1.2', while 'Chapter2' splits into 'Section 2.1' and 'Section 2.2'. Each section node also branches into subsections, with 'Section 1.1' leading to 'Section 1.2.1' and 'Section 1.2.2', and 'Section 2.2' leading to 'Section 2.2.1' and 'Section 2.2.2'. The nodes are connected by lines that represent the tree structure, demonstrating the organizational hierarchy of the book's contents.   "
},
{
  "id": "expl-preorder1",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-preorder1",
  "type": "Exploration",
  "number": "8.6.1",
  "title": "Preorder Traversal.",
  "body": " Preorder Traversal  C++ Implementation C++ Implementation void preorder(BinaryTree *tree){ if (tree){ cout << tree->getRootVal() << endl; preorder(tree->getLeftChild()); preorder(tree->getRightChild()); } }  Python Implementation def preorder(tree): if tree: print(tree.getRootVal()) preorder(tree.getLeftChild()) preorder(tree.getRightChild())  "
},
{
  "id": "expl-preorder2",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-preorder2",
  "type": "Exploration",
  "number": "8.6.2",
  "title": "Preorder Traversal as a Method.",
  "body": " Preorder Traversal as a Method  C++ Implementation C++ Implementation void preorder(){ cout << this->key << endl; if (this->leftChild){ this->leftChild->preorder(); } if (this->rightChild){ this->rightChild->preorder(); } }  Python Implementation def preorder(self): print(self.key) if self.leftChild: self.leftChild.preorder() if self.rightChild: self.rightChild.preorder()  "
},
{
  "id": "expl-postorder1",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-postorder1",
  "type": "Exploration",
  "number": "8.6.3",
  "title": "Postorder Traversal.",
  "body": " Postorder Traversal  C++ Implementation C++ Implementation void postorder(BinaryTree *tree){ if (tree != NULL){ postorder(tree->getLeftChild()); postorder(tree->getRightChild()); cout << tree->getRootVal() << endl; } }  Python Implementation def postorder(tree): if tree != None: postorder(tree.getLeftChild()) postorder(tree.getRightChild()) print(tree.getRootVal())  "
},
{
  "id": "expl-postordereval",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-postordereval",
  "type": "Exploration",
  "number": "8.6.4",
  "title": "Postorder Evaluation.",
  "body": " Postorder Evaluation  C++ Implementation class Operator { public: int add(int x, int y){ return x + y; } int sub(int x, int y){ return x - y; } int mul(int x, int y){ return x * y; } int div(int x, int y){ return x \/ y; } }; int to_int(string str) { stringstream convert(str); int x = 0; convert >> x; return x; } string to_string(int num) { string str; ostringstream convert; convert << num; str = convert.str(); return str; } string evaluate(BinaryTree *parseTree) { Operator Oper; BinaryTree *leftC = parseTree->getLeftChild(); BinaryTree *rightC = parseTree->getRightChild(); if (leftC && rightC) { if (parseTree->getRootVal() == \"+\") { return to_string(Oper.add(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"-\") { return to_string(Oper.sub(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else if (parseTree->getRootVal() == \"*\") { return to_string(Oper.mul(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } else { return to_string(Oper.div(to_int(evaluate(leftC)), to_int(evaluate(rightC)))); } } else { return parseTree->getRootVal(); } } int main(){ return 0; }  Python Implementation def postordereval(tree): opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '\/':operator.truediv} res1 = None res2 = None if tree: res1 = postordereval(tree.getLeftChild()) res2 = postordereval(tree.getRightChild()) if res1 and res2: return opers[tree.getRootVal()](res1,res2) else: return tree.getRootVal()  "
},
{
  "id": "expl-inorder1",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-inorder1",
  "type": "Exploration",
  "number": "8.6.5",
  "title": "Inorder Traversal.",
  "body": " Inorder Traversal  C++ Implementation void inorder(BinaryTree *tree){ if (tree != NULL){ inorder(tree->getLeftChild()); cout << tree->getRootVal(); inorder(tree->getRightChild()); } }  Python Implementation def inorder(tree): if tree != None: inorder(tree.getLeftChild()) print(tree.getRootVal()) inorder(tree.getRightChild())  "
},
{
  "id": "expl-printexp",
  "level": "2",
  "url": "trees_tree-traversals.html#expl-printexp",
  "type": "Exploration",
  "number": "8.6.6",
  "title": "Inorder Traversal.",
  "body": " Inorder Traversal  C++ Implementation string printexp(BinaryTree *tree){ string sVal; if (tree){ sVal = \"(\" + printexp(tree->getLeftChild()); sVal = sVal + tree->getRootVal(); sVal = sVal + printexp(tree->getRightChild()) + \")\"; } return sVal; }  Python Implementation def printexp(tree): sVal = \"\" if tree: sVal = '(' + printexp(tree.getLeftChild()) sVal = sVal + str(tree.getRootVal()) sVal = sVal + printexp(tree.getRightChild())+')' return sVal  "
},
{
  "id": "treeTraversalTypes",
  "level": "2",
  "url": "trees_tree-traversals.html#treeTraversalTypes",
  "type": "Reading Question",
  "number": "8.6.1",
  "title": "",
  "body": "Drag the tree traversal to its corresponding pattern. Review the tree traversal patterns. preorder root, left, right inorder left, root, right postorder left, right, root "
},
{
  "id": "question1_1",
  "level": "2",
  "url": "trees_tree-traversals.html#question1_1",
  "type": "Reading Question",
  "number": "8.6.2",
  "title": "",
  "body": " If you print out the data at each node, what would be the result of using the preorder traversal method on ?     Book, Chapter 1, Section 1.1, Section 1.2, Section 1.2.2, Section 1.2.2, Chapter 2, Section 2.1, Section 2.2, Section 2.2.1, Section 2.2.2    correct      Section 1.1, Chapter 1.2, Section 1.2.1, Section 1.2, Section 1.2.2, Section 2.1, Chapter 2, Section 2.2.1, Section 2.2, Section 2.2.2    Incorrect, this is postorder traversal      Section 1.1, Section 1.2.1, Section 1.2.2, Section 1.2, Chapter 1, Section 2.1, Section 2.2.1, Section 2.2.2, Section 2.2, Chapter 2, Book    Incorrect, this is inorder traversal    "
},
{
  "id": "trees_priority-queues-with-binary-heaps",
  "level": "1",
  "url": "trees_priority-queues-with-binary-heaps.html",
  "type": "Section",
  "number": "8.7",
  "title": "Priority Queues with Binary Heaps",
  "body": " Priority Queues with Binary Heaps   priority queue In earlier sections you learned about the first-in first-out data structure called a queue. One important variation of a queue is called a priority queue . A priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. The highest priority items are at the front of the queue and the lowest priority items are at the back. Thus when you enqueue an item on a priority queue, the new item may move all the way to the front. We will see that the priority queue is a useful data structure for some of the graph algorithms we will study in the next chapter.   binary heap You can probably think of a couple of easy ways to implement a priority queue using sorting functions and vectors. However, inserting into a vector is and sorting a vector is . We can do better. The classic way to implement a priority queue is using a data structure called a binary heap . A binary heap will allow us both enqueue and dequeue items in .   min heap  max heap The binary heap is interesting to study because when we diagram the heap it looks a lot like a tree, but when we implement it we use only a single vector as an internal representation. The binary heap has two common variations: the min heap , in which the smallest key is always at the front, and the max heap , in which the largest key value is always at the front. In this section we will implement the min heap. We leave a max heap implementation as an exercise.  "
},
{
  "id": "trees_priority-queues-with-binary-heaps-2",
  "level": "2",
  "url": "trees_priority-queues-with-binary-heaps.html#trees_priority-queues-with-binary-heaps-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "priority queue "
},
{
  "id": "trees_priority-queues-with-binary-heaps-3",
  "level": "2",
  "url": "trees_priority-queues-with-binary-heaps.html#trees_priority-queues-with-binary-heaps-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "binary heap "
},
{
  "id": "trees_priority-queues-with-binary-heaps-4",
  "level": "2",
  "url": "trees_priority-queues-with-binary-heaps.html#trees_priority-queues-with-binary-heaps-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "min heap max heap "
},
{
  "id": "trees_priority-queues-with-binary-heaps-example",
  "level": "1",
  "url": "trees_priority-queues-with-binary-heaps-example.html",
  "type": "Section",
  "number": "8.8",
  "title": "Priority Queues with Binary Heaps Example",
  "body": " Priority Queues with Binary Heaps Example  As mentioned before we can use binary heaps in order to design a priority queue, according to our preference, using a min or max heap would allow us to construct a tree in such a way that the children are always larger or smaller than the parent, respectively. In the example in this section we will be using min heap structure. That way the smallest element will always be at the root, that is the goal of using a heap for a priority queue, since this will allow for swift removal of the element with utmost priority. When inserting new elements into the heap it is important to maintain the priority structure, therefore every time we insert a new element, not only do we insert it in such a way to fill out the tree from left to right, but we also make sure that every parent node is smaller then the child node that we inserted. This way if the inserted node is the smallest node in the tree it will bubble up to the root and push everything else lower into the heap. Deletion of the items is also important, since we know that the element with utmost priority is always at the root we can simply remove the root and replace it with the righmost leaf. However now our priority structure is broken, we can fix this by swaping it with the lesser of its children, then the structure will be correct agian. This structure allows for effective maintenance of the priority of the items and greatly improves the efficiency of our priority queue.  Before we begin with the implementation of Binary Heaps, let us review a real life example of one of the things: Priority Queues. Let us consider a priority queue of homework. If we were trying to decide which homework project to complete, it would make sense to organize the order of doing any specific project based on the deadline of that homework. Let us say you were assigned homeworks in the following order and you are told the deadlines for those homeworks: 3, 10, 5, 8, 7, 2 days respectively. You can observe the insertion of these homeworks into our priority queue in .   Homework insertion process into priority queue.   A sequence of diagrams depicting the insertion process into a priority queue represented by a binary tree. Starting with a single node labeled '3', the first diagram shows 'Insert 10', leading to a new node '10' added as a child. The next step 'Insert 5' adds a new node '5', followed by 'Insert 8' which adds node '8'. Another step shows 'Insert 7' with a node '7' being added, and the sequence progresses with each insertion maintaining the binary tree structure. The diagrams show the dynamic reordering of nodes to maintain the priority queue property, with the final structure at the bottom left displaying a balanced binary tree with node '2' at the top, leading to nodes '3' and '7', which branch out to further nodes '10', '8', '5', and '2'. Arrows indicate the insertion order and the adjustments within the tree.    Now that we have the priority queue of which homeworks we need to do in the order. Let us start by doing the homework with 2 day deadline. We would remove it from the root and put the left most leaf in its place and than rearange the heap back to the proper state, as shown in .   After finishing the earliest homework, the root is removed and rearranges the priority queue.   Two diagrams showing the process of removing the root from a binary heap that represents a priority queue. The first diagram on the left shows a binary tree with the root node '3', which has two children: '7' on the left with its own children '10' and '8', and '5' on the right. An arrow points from this tree to the second diagram on the right, indicating the removal of the root node. The second diagram shows the tree after the root has been removed and the heap has been restructured: the node '5' has been moved to the root position, with '7' as its left child and '3' as its right child, maintaining the heap property. The nodes '10' and '8' remain as children of '7'. The tree restructuring is shown with curved arrows indicating the new parent-child relationships.    As we continue to complete the homework with the closest deadline we will continue to remove the homeworks in the demostrated fashion until we are done.  "
},
{
  "id": "fig-trees_pq-insertion",
  "level": "2",
  "url": "trees_priority-queues-with-binary-heaps-example.html#fig-trees_pq-insertion",
  "type": "Figure",
  "number": "8.8.1",
  "title": "",
  "body": " Homework insertion process into priority queue.   A sequence of diagrams depicting the insertion process into a priority queue represented by a binary tree. Starting with a single node labeled '3', the first diagram shows 'Insert 10', leading to a new node '10' added as a child. The next step 'Insert 5' adds a new node '5', followed by 'Insert 8' which adds node '8'. Another step shows 'Insert 7' with a node '7' being added, and the sequence progresses with each insertion maintaining the binary tree structure. The diagrams show the dynamic reordering of nodes to maintain the priority queue property, with the final structure at the bottom left displaying a balanced binary tree with node '2' at the top, leading to nodes '3' and '7', which branch out to further nodes '10', '8', '5', and '2'. Arrows indicate the insertion order and the adjustments within the tree.   "
},
{
  "id": "fig-trees_pq-del",
  "level": "2",
  "url": "trees_priority-queues-with-binary-heaps-example.html#fig-trees_pq-del",
  "type": "Figure",
  "number": "8.8.2",
  "title": "",
  "body": " After finishing the earliest homework, the root is removed and rearranges the priority queue.   Two diagrams showing the process of removing the root from a binary heap that represents a priority queue. The first diagram on the left shows a binary tree with the root node '3', which has two children: '7' on the left with its own children '10' and '8', and '5' on the right. An arrow points from this tree to the second diagram on the right, indicating the removal of the root node. The second diagram shows the tree after the root has been removed and the heap has been restructured: the node '5' has been moved to the root position, with '7' as its left child and '3' as its right child, maintaining the heap property. The nodes '10' and '8' remain as children of '7'. The tree restructuring is shown with curved arrows indicating the new parent-child relationships.   "
},
{
  "id": "trees_binary-heap-operations",
  "level": "1",
  "url": "trees_binary-heap-operations.html",
  "type": "Section",
  "number": "8.9",
  "title": "Binary Heap Operations",
  "body": " Binary Heap Operations  The basic operations we will implement for our binary heap are as follows:    BinaryHeap() creates a new, empty, binary heap.    insert(k) adds a new item to the heap.    findMin() returns the item with the minimum key value, leaving item in the heap.    delMin() returns the item with the minimum key value, removing the item from the heap.    isEmpty() returns true if the heap is empty, false otherwise.    size() returns the number of items in the heap.    buildHeap(vector) builds a new heap from a vector of keys.    demonstrates the use of some of the binary heap methods. Notice that no matter the order that we add items to the heap, the smallest is removed each time. We will now turn our attention to creating an implementation for this idea.   Binary Heap Operations  C++ Implementation #include <iostream> #include <vector> using namespace std; class BinHeap{ private: vector<int> heapvector; int currentSize; public: BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } } void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); } void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapvector[i*2] < this->heapvector[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } } int delMin(){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector.insert(this->heapvector.end(), avector.begin(), avector.end()); while (i > 0){ this->percDown(i); i = i - 1; } } bool isEmpty(){ if (this->heapvector.size()>0){ return false; } return true; } int findMin(){ return this->heapvector[1]; } }; int main(){ int arr[] = {9, 5, 6, 2, 3}; vector<int> a(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); vector<int> vec; vec.push_back(0); BinHeap *bh = new BinHeap(vec); bh->insert(5); bh->insert(7); bh->insert(3); bh->insert(11); cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; return 0; }  Python Implementation #you can use the command below to import the binheap library: #from pythonds.trees.binheap import BinHeap class BinHeap: def __init__(self, heaparray): self.heaparray = heaparray self.size = 0 def percUp(self, i): while ((i\/\/2) > 0): if(self.heaparray[i] < self.heaparray[i\/\/2]): temp = self.heaparray[i\/\/2] self.heaparray[i\/\/2] = self.heaparray[i] self.heaparray[i] = temp i = i\/\/2 def insert(self, k): self.heaparray.append(k) self.size += 1 self.percUp(self.size) def percDown(self, i): while (i*2) <= self.size: mc = self.minChild(i) if self.heaparray[i] > self.heaparray[mc]: temp = self.heaparray[i] self.heaparray[i] = self.heaparray[mc] self.heaparray[mc] = temp i = mc def minChild(self, i): if ((i*2)+1) > self.size: return i*2; else: if self.heaparray[i*2] < self.heaparray[(i*2)+1]: return i*2 else: return (i*2) + 1 def delMin(self): retval = self.heaparray[1] self.heaparray[1] = self.heaparray[self.size] self.size = self.size - 1 del self.heaparray[-1] self.percDown(1) return retval def buildheap(self, alist): # might be wrong i = len(alist) \/ 2 self.size = len(alist) self.heaparray.insert(self.heaparray[-1], alist[0], alist[-1]) while i > 0: self.perdDown(i) i -= 1 def isEmpty(self): if len(self.heaparray) > 0: return False; return True def findMin(self): return self.heaparray[1] def main(): alist = [] alist.append(0) #required for indexing in the class methods!! bh = BinHeap(alist); bh.insert(5); bh.insert(7); bh.insert(3); bh.insert(11); print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) main()   "
},
{
  "id": "expl-binheapops",
  "level": "2",
  "url": "trees_binary-heap-operations.html#expl-binheapops",
  "type": "Exploration",
  "number": "8.9.1",
  "title": "Binary Heap Operations.",
  "body": " Binary Heap Operations  C++ Implementation #include <iostream> #include <vector> using namespace std; class BinHeap{ private: vector<int> heapvector; int currentSize; public: BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } } void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); } void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapvector[i*2] < this->heapvector[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } } int delMin(){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector.insert(this->heapvector.end(), avector.begin(), avector.end()); while (i > 0){ this->percDown(i); i = i - 1; } } bool isEmpty(){ if (this->heapvector.size()>0){ return false; } return true; } int findMin(){ return this->heapvector[1]; } }; int main(){ int arr[] = {9, 5, 6, 2, 3}; vector<int> a(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); vector<int> vec; vec.push_back(0); BinHeap *bh = new BinHeap(vec); bh->insert(5); bh->insert(7); bh->insert(3); bh->insert(11); cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; return 0; }  Python Implementation #you can use the command below to import the binheap library: #from pythonds.trees.binheap import BinHeap class BinHeap: def __init__(self, heaparray): self.heaparray = heaparray self.size = 0 def percUp(self, i): while ((i\/\/2) > 0): if(self.heaparray[i] < self.heaparray[i\/\/2]): temp = self.heaparray[i\/\/2] self.heaparray[i\/\/2] = self.heaparray[i] self.heaparray[i] = temp i = i\/\/2 def insert(self, k): self.heaparray.append(k) self.size += 1 self.percUp(self.size) def percDown(self, i): while (i*2) <= self.size: mc = self.minChild(i) if self.heaparray[i] > self.heaparray[mc]: temp = self.heaparray[i] self.heaparray[i] = self.heaparray[mc] self.heaparray[mc] = temp i = mc def minChild(self, i): if ((i*2)+1) > self.size: return i*2; else: if self.heaparray[i*2] < self.heaparray[(i*2)+1]: return i*2 else: return (i*2) + 1 def delMin(self): retval = self.heaparray[1] self.heaparray[1] = self.heaparray[self.size] self.size = self.size - 1 del self.heaparray[-1] self.percDown(1) return retval def buildheap(self, alist): # might be wrong i = len(alist) \/ 2 self.size = len(alist) self.heaparray.insert(self.heaparray[-1], alist[0], alist[-1]) while i > 0: self.perdDown(i) i -= 1 def isEmpty(self): if len(self.heaparray) > 0: return False; return True def findMin(self): return self.heaparray[1] def main(): alist = [] alist.append(0) #required for indexing in the class methods!! bh = BinHeap(alist); bh.insert(5); bh.insert(7); bh.insert(3); bh.insert(11); print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) main()  "
},
{
  "id": "trees_binary-heap-implementation",
  "level": "1",
  "url": "trees_binary-heap-implementation.html",
  "type": "Section",
  "number": "8.10",
  "title": "Binary Heap Implementation",
  "body": " Binary Heap Implementation   The Structure Property  complete binary tree In order to make our heap work efficiently, we will take advantage of the logarithmic nature of the binary tree to represent our heap. In order to guarantee logarithmic performance, we must keep our tree balanced. A balanced binary tree has roughly the same number of nodes in the left and right subtrees of the root. In our heap implementation we keep the tree balanced by creating a complete binary tree . A complete binary tree is a tree in which each level has all of its nodes. The exception to this is the bottom level of the tree, which we fill in from left to right. shows an example of a complete binary tree.   A Complete Binary Tree.   Diagram of a complete binary tree. The top node, or the root, is labeled '5'. This root node has two child nodes: '9' to the left and '11' to the right. Each of these child nodes further branches out into two more nodes. The left child '9' has nodes '14' and '18' as children. '14' has a single left child labeled '33', while '18' has two children labeled '17' and '27'. On the right side, the child '11' has two children labeled '19' and '21'. The tree is balanced and each level is fully filled except for the last level, which is filled from the left. The image is labeled 'Figure 1: A Complete Binary Tree'.    Another interesting property of a complete tree is that we can represent it using a single vector. We do not need to use nodes and references or even vectors of vectors. Because the tree is complete, the left child of a parent (at position ) is the node that is found in position in the vector. Similarly, the right child of the parent is at position in the vector. To find the parent of any node in the tree, we can simply use Python's integer division. Given that a node is at position in the vector, the parent is at position . shows a complete binary tree and also gives the vector representation of the tree. Note the and relationship between parent and children. The vector representation of the tree, along with the full structure property, allows us to efficiently traverse a complete binary tree using only a few simple mathematical operations. We will see that this also leads to an efficient implementation of our binary heap.    The Heap Order Property  heap order property The method that we will use to store items in a binary heap relies on maintaining the heap order property. The heap order property is as follows: In a binary heap, for every node with parent , the key in is smaller than or equal to the key in . also illustrates a complete binary tree that has the heap order property.   A Complete Binary Tree, along with its Vector Representation.   The image depicts a complete binary tree at the top and its corresponding vector representation at the bottom. The binary tree has a root node labeled '5', which branches out to two nodes labeled '9' on the left and '11' on the right. The '9' node further branches into '14' and '18', which in turn have children '33' and '17', and '27', respectively. The '11' node branches into '19' and '21'. Below the binary tree, there is a vector representation with indexed positions from 0 to 11. The values in the vector are arranged as '5', '9', '11', '14', '18', '19', '21', '33', '17', '27', respecting the binary tree's structure. The image is labeled 'Figure 2: A Complete Binary Tree, along with its Vector Representation'.      Heap Operations  We will begin our implementation of a binary heap with the constructor. Since the entire binary heap can be represented by a single vector, all the constructor will do is initialize the vector and an attribute currentSize to keep track of the current size of the heap. shows the C++ code for the constructor. You will notice that an empty binary heap has a single zero as the first element of heapList and that this zero is not used, but is there so that simple integer division can be used in later methods.   BinHeap Class and Constructor  class BinHeap{ private: vector<int> heapvector; int currentSize; public: BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } }   The next method we will implement is insert . The easiest, and most efficient, way to add an item to a vector is to simply append the item to the end of the vector. The good news about appending is that it guarantees that we will maintain the complete tree property. The bad news about appending is that we will very likely violate the heap structure property. However, it is possible to write a method that will allow us to regain the heap structure property by comparing the newly added item with its parent. If the newly added item is less than its parent, then we can swap the item with its parent. shows the series of swaps needed to percolate the newly added item up to its proper position in the tree.   Percolate the New Node up to Its Proper Position.    Notice that when we percolate an item up, we are restoring the heap property between the newly added item and the parent. We are also preserving the heap property for any siblings. Of course, if the newly added item is very small, we may still need to swap it up another level. In fact, we may need to keep swapping until we get to the top of the tree. shows the percUp method, which percolates a new item as far up in the tree as it needs to go to maintain the heap property. Here is where our wasted element in heapvector is important. Notice that we can compute the parent of any node by using simple integer division. The parent of the current node can be computed by dividing the index of the current node by 2.  We are now ready to write the insert method (see ). Most of the work in the insert method is really done by percUp . Once a new item is appended to the tree, percUp takes over and positions the new item properly.   percUp Method  void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } }    insert Method  void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); }   With the insert method properly defined, we can now look at the delMin method. Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy. The hard part of delMin is restoring full compliance with the heap structure and heap order properties after the root has been removed. We can restore our heap in two steps. First, we will restore the root item by taking the last item in the vector and moving it to the root position. Moving the last item maintains our heap structure property. However, we have probably destroyed the heap order property of our binary heap. Second, we will restore the heap order property by pushing the new root node down the tree to its proper position. shows the series of swaps needed to move the new root node to its proper position in the heap.   Percolating the Root Node down the Tree.    In order to maintain the heap order property, all we need to do is swap the root with its smallest child less than the root. After the initial swap, we may repeat the swapping process with a node and its children until the node is swapped into a position on the tree where it is already less than both children. The code for percolating a node down the tree is found in the percDown and minChild methods in .   percDown and minChild Methods  void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapList[i*2] < this->heapList[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } }   The code for the delMin operation is in . Note that once again the hard work is handled by a helper function, in this case percDown .   delMin Implementation  int delMin(){ if (this->currentSize > 1){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } else{ int retval = this->heapvector[0]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } }   To finish our discussion of binary heaps, we will look at a method to build an entire heap from a vector of keys. The first method you might think of may be like the following. Given a vector of keys, you could easily build a heap by inserting each key one at a time. Since you are starting with a vector of one item, the vector is sorted and you could use binary search to find the right position to insert the next key at a cost of approximately operations. However, remember that inserting an item in the middle of the vector may require operations to shift the rest of the vector over to make room for the new key. Therefore, to insert keys into the heap would require a total of operations. However, if we start with an entire vector then we can build the whole heap in operations. shows the code to build the entire heap.   buildHeap Implementation  void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector = avector; while (i > 0){ this->percDown(i); i = i - 1; } }    Building a Heap from the vector [9, 6, 5, 2, 3].    shows the swaps that the buildHeap method makes as it moves the nodes in an initial tree of [9, 6, 5, 2, 3] into their proper positions. Although we start out in the middle of the tree and work our way back toward the root, the percDown method ensures that the largest child is always moved down the tree. Because the heap is a complete binary tree, any nodes past the halfway point will be leaves and therefore have no children. Notice that when i=1 , we are percolating down from the root of the tree, so this may require multiple swaps. As you can see in the rightmost two trees of , first the 9 is moved out of the root position, but after 9 is moved down one level in the tree, percDown ensures that we check the next set of children farther down in the tree to ensure that it is pushed as low as it can go. In this case it results in a second swap with 3. Now that 9 has been moved to the lowest level of the tree, no further swapping can be done. It is useful to compare the vector representation of this series of swaps as shown in with the tree representation.  i = 2 [0, 9, 5, 6, 2, 3] i = 1 [0, 9, 2, 6, 5, 3] i = 0 [0, 2, 3, 6, 5, 9]  The complete binary heap implementation can be seen in .   Complete Heap Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/ uses a vector to creat a Binar Heap class BinHeap{ private: vector<int> heapvector; int currentSize; public: \/\/ initializes the vector and an attribute currentSize \/\/ as 0 to allow for interger division. BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } \/\/ prelocates and item as far up in the \/\/ tree as possible to maintain \/\/ the Heap property void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } } \/\/ appends item to the end of the vector void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); } \/\/ prelocates and item as far up in the \/\/ tree as possible to maintain \/\/ the Heap property void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapvector[i*2] < this->heapvector[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } } \/\/ restores full complince with the heap structure \/\/ and heap order properties after the root is removed \/\/ by taking the last item and moving it to the root position \/\/ and pushing the new root node down the tree to its proper postion. int delMin(){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector.insert(this->heapvector.end(), avector.begin(), avector.end()); while (i > 0){ this->percDown(i); i = i - 1; } } bool isEmpty(){ if (this->heapvector.size()>0){ return false; } return true; } int findMin(){ return this->heapvector[1]; } }; int main(){ int arr[] = {9, 5, 6, 2, 3}; vector<int> a(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); vector<int> vec; vec.push_back(0); BinHeap *bh = new BinHeap(vec); bh->buildheap(a); cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; return 0; }  Python Implementation # uses a vector to create a Binary Heap class BinHeap: \"\"\"initializes the vector and an attribute currentSize as 0 to allow for interger division.\"\"\" def __init__(self): self.heapList = [0] self.currentSize = 0 \"\"\" prelocates and item as far up in the tree as possible to maintain the Heap property \"\"\" def percUp(self,i): while i \/\/ 2 > 0: if self.heapList[i] < self.heapList[i \/\/ 2]: tmp = self.heapList[i \/\/ 2] self.heapList[i \/\/ 2] = self.heapList[i] self.heapList[i] = tmp i = i \/\/ 2 # appends item to the end of the vector def insert(self,k): self.heapList.append(k) self.currentSize = self.currentSize + 1 self.percUp(self.currentSize) \"\"\" prelocates and item as far down in the tree as possible to maintain the Heap property \"\"\" def percDown(self,i): while (i * 2) <= self.currentSize: mc = self.minChild(i) if self.heapList[i] > self.heapList[mc]: tmp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = tmp i = mc def minChild(self,i): if i * 2 + 1 > self.currentSize: return i * 2 else: if self.heapList[i*2] < self.heapList[i*2+1]: return i * 2 else: return i * 2 + 1 \"\"\" restores full complince with the heap structure and heap order properties after the root is removed by taking the last item and moving it to the root position and pushing the new root node down the tree to its proper postion.\"\"\" def delMin(self): retval = self.heapList[1] self.heapList[1] = self.heapList[self.currentSize] self.currentSize = self.currentSize - 1 self.heapList.pop() self.percDown(1) return retval def buildHeap(self,alist): i = len(alist) \/\/ 2 self.currentSize = len(alist) self.heapList = [0] + alist[:] while (i > 0): self.percDown(i) i = i - 1 def main(): bh = BinHeap() bh.buildHeap([9,5,6,2,3]) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) main()   The assertion that we can build the heap in may seem a bit mysterious at first, and a proof is beyond the scope of this book. However, the key to understanding that you can build the heap in is to remember that the factor is derived from the height of the tree. For most of the work in buildHeap , the tree is shorter than .  Using the fact that you can build a heap from a vector in time, you will construct a sorting algorithm that uses a heap and sorts a vector in as an exercise at the end of this chapter.   Reading Question   What is the vector used in the binary tree in the first image of ? Exclude any whitespace.  Is the correct answer! Remember what has to be at the beginning of the vector to accurately traverse through the binary tree. Look back at chp. 8.9.2. Refer to section 8.10.1 and 8.10.2    "
},
{
  "id": "trees_the-structure-property-2",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#trees_the-structure-property-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "complete binary tree "
},
{
  "id": "binheap_fig-comptree",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_fig-comptree",
  "type": "Figure",
  "number": "8.10.1",
  "title": "",
  "body": " A Complete Binary Tree.   Diagram of a complete binary tree. The top node, or the root, is labeled '5'. This root node has two child nodes: '9' to the left and '11' to the right. Each of these child nodes further branches out into two more nodes. The left child '9' has nodes '14' and '18' as children. '14' has a single left child labeled '33', while '18' has two children labeled '17' and '27'. On the right side, the child '11' has two children labeled '19' and '21'. The tree is balanced and each level is fully filled except for the last level, which is filled from the left. The image is labeled 'Figure 1: A Complete Binary Tree'.   "
},
{
  "id": "trees_the-heap-order-property-2",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#trees_the-heap-order-property-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "heap order property "
},
{
  "id": "binheap_fig-heaporder",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_fig-heaporder",
  "type": "Figure",
  "number": "8.10.2",
  "title": "",
  "body": " A Complete Binary Tree, along with its Vector Representation.   The image depicts a complete binary tree at the top and its corresponding vector representation at the bottom. The binary tree has a root node labeled '5', which branches out to two nodes labeled '9' on the left and '11' on the right. The '9' node further branches into '14' and '18', which in turn have children '33' and '17', and '27', respectively. The '11' node branches into '19' and '21'. Below the binary tree, there is a vector representation with indexed positions from 0 to 11. The values in the vector are arranged as '5', '9', '11', '14', '18', '19', '21', '33', '17', '27', respecting the binary tree's structure. The image is labeled 'Figure 2: A Complete Binary Tree, along with its Vector Representation'.   "
},
{
  "id": "binheap_lst-heap1a",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap1a",
  "type": "Listing",
  "number": "8.10.3",
  "title": "",
  "body": " BinHeap Class and Constructor  class BinHeap{ private: vector<int> heapvector; int currentSize; public: BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } }  "
},
{
  "id": "binheap_fig-percup",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_fig-percup",
  "type": "Figure",
  "number": "8.10.4",
  "title": "",
  "body": " Percolate the New Node up to Its Proper Position.   "
},
{
  "id": "binheap_lst-heap2",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap2",
  "type": "Listing",
  "number": "8.10.5",
  "title": "",
  "body": " percUp Method  void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } }  "
},
{
  "id": "binheap_lst-heap3",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap3",
  "type": "Listing",
  "number": "8.10.6",
  "title": "",
  "body": " insert Method  void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); }  "
},
{
  "id": "binheap_fig-percdown",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_fig-percdown",
  "type": "Figure",
  "number": "8.10.7",
  "title": "",
  "body": " Percolating the Root Node down the Tree.   "
},
{
  "id": "binheap_lst-heap4",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap4",
  "type": "Listing",
  "number": "8.10.8",
  "title": "",
  "body": " percDown and minChild Methods  void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapList[i*2] < this->heapList[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } }  "
},
{
  "id": "binheap_lst-heap5",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap5",
  "type": "Listing",
  "number": "8.10.9",
  "title": "",
  "body": " delMin Implementation  int delMin(){ if (this->currentSize > 1){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } else{ int retval = this->heapvector[0]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } }  "
},
{
  "id": "binheap_lst-heap6",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_lst-heap6",
  "type": "Listing",
  "number": "8.10.10",
  "title": "",
  "body": " buildHeap Implementation  void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector = avector; while (i > 0){ this->percDown(i); i = i - 1; } }  "
},
{
  "id": "binheap_fig-buildheap",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_fig-buildheap",
  "type": "Figure",
  "number": "8.10.11",
  "title": "",
  "body": " Building a Heap from the vector [9, 6, 5, 2, 3].   "
},
{
  "id": "expl-heapwhole",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#expl-heapwhole",
  "type": "Exploration",
  "number": "8.10.1",
  "title": "Complete Heap Implementation.",
  "body": " Complete Heap Implementation  C++ Implementation #include <iostream> #include <vector> using namespace std; \/\/ uses a vector to creat a Binar Heap class BinHeap{ private: vector<int> heapvector; int currentSize; public: \/\/ initializes the vector and an attribute currentSize \/\/ as 0 to allow for interger division. BinHeap(vector<int> heapvector){ this->heapvector = heapvector; this->currentSize = 0; } \/\/ prelocates and item as far up in the \/\/ tree as possible to maintain \/\/ the Heap property void percUp(int i){ while ((i \/ 2) > 0){ if (this->heapvector[i] < this->heapvector[i\/2]){ int tmp = this->heapvector[i\/2]; this->heapvector[i\/2] = this->heapvector[i]; this->heapvector[i] = tmp; } i = i\/2; } } \/\/ appends item to the end of the vector void insert(int k){ this->heapvector.push_back(k); this->currentSize = this->currentSize + 1; this->percUp(this->currentSize); } \/\/ prelocates and item as far up in the \/\/ tree as possible to maintain \/\/ the Heap property void percDown(int i){ while ((i*2) <= this->currentSize){ int mc = this->minChild(i); if (this->heapvector[i] > this->heapvector[mc]){ int tmp = this->heapvector[i]; this->heapvector[i] = this->heapvector[mc]; this->heapvector[mc] = tmp; } i = mc; } } int minChild(int i){ if (((i*2)+1) > this->currentSize){ return i * 2; } else{ if (this->heapvector[i*2] < this->heapvector[(i*2)+1]){ return i * 2; } else{ return (i * 2) + 1; } } } \/\/ restores full complince with the heap structure \/\/ and heap order properties after the root is removed \/\/ by taking the last item and moving it to the root position \/\/ and pushing the new root node down the tree to its proper postion. int delMin(){ int retval = this->heapvector[1]; this->heapvector[1] = this->heapvector[this->currentSize]; this->currentSize = this->currentSize - 1; this->heapvector.pop_back(); this->percDown(1); return retval; } void buildheap(vector<int> avector){ int i = avector.size() \/ 2; this->currentSize = avector.size(); this->heapvector.insert(this->heapvector.end(), avector.begin(), avector.end()); while (i > 0){ this->percDown(i); i = i - 1; } } bool isEmpty(){ if (this->heapvector.size()>0){ return false; } return true; } int findMin(){ return this->heapvector[1]; } }; int main(){ int arr[] = {9, 5, 6, 2, 3}; vector<int> a(arr,arr+(sizeof(arr)\/ sizeof(arr[0]))); vector<int> vec; vec.push_back(0); BinHeap *bh = new BinHeap(vec); bh->buildheap(a); cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; cout << bh->delMin() << endl; return 0; }  Python Implementation # uses a vector to create a Binary Heap class BinHeap: \"\"\"initializes the vector and an attribute currentSize as 0 to allow for interger division.\"\"\" def __init__(self): self.heapList = [0] self.currentSize = 0 \"\"\" prelocates and item as far up in the tree as possible to maintain the Heap property \"\"\" def percUp(self,i): while i \/\/ 2 > 0: if self.heapList[i] < self.heapList[i \/\/ 2]: tmp = self.heapList[i \/\/ 2] self.heapList[i \/\/ 2] = self.heapList[i] self.heapList[i] = tmp i = i \/\/ 2 # appends item to the end of the vector def insert(self,k): self.heapList.append(k) self.currentSize = self.currentSize + 1 self.percUp(self.currentSize) \"\"\" prelocates and item as far down in the tree as possible to maintain the Heap property \"\"\" def percDown(self,i): while (i * 2) <= self.currentSize: mc = self.minChild(i) if self.heapList[i] > self.heapList[mc]: tmp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = tmp i = mc def minChild(self,i): if i * 2 + 1 > self.currentSize: return i * 2 else: if self.heapList[i*2] < self.heapList[i*2+1]: return i * 2 else: return i * 2 + 1 \"\"\" restores full complince with the heap structure and heap order properties after the root is removed by taking the last item and moving it to the root position and pushing the new root node down the tree to its proper postion.\"\"\" def delMin(self): retval = self.heapList[1] self.heapList[1] = self.heapList[self.currentSize] self.currentSize = self.currentSize - 1 self.heapList.pop() self.percDown(1) return retval def buildHeap(self,alist): i = len(alist) \/\/ 2 self.currentSize = len(alist) self.heapList = [0] + alist[:] while (i > 0): self.percDown(i) i = i - 1 def main(): bh = BinHeap() bh.buildHeap([9,5,6,2,3]) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) print(bh.delMin()) main()  "
},
{
  "id": "binheap_1",
  "level": "2",
  "url": "trees_binary-heap-implementation.html#binheap_1",
  "type": "Reading Question",
  "number": "8.10.3.1",
  "title": "",
  "body": " What is the vector used in the binary tree in the first image of ? Exclude any whitespace.  Is the correct answer! Remember what has to be at the beginning of the vector to accurately traverse through the binary tree. Look back at chp. 8.9.2. Refer to section 8.10.1 and 8.10.2 "
},
{
  "id": "trees_binary-search-trees",
  "level": "1",
  "url": "trees_binary-search-trees.html",
  "type": "Section",
  "number": "8.11",
  "title": "Binary Search Trees",
  "body": " Binary Search Trees  We have already seen two different ways to get key-value pairs in a collection. Recall that these collections implement the map abstract data type. The two implementations of a map ADT we discussed were binary search on a vector and hash tables. In this section we will study binary search trees as yet another way to map from a key to a value. In this case we are not interested in the exact placement of items in the tree, but we are interested in using the binary tree structure to provide for efficient searching.  "
},
{
  "id": "trees_binary-search-trees-2",
  "level": "2",
  "url": "trees_binary-search-trees.html#trees_binary-search-trees-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "binary search trees "
},
{
  "id": "trees_search-tree-operations",
  "level": "1",
  "url": "trees_search-tree-operations.html",
  "type": "Section",
  "number": "8.12",
  "title": "Search Tree Operations",
  "body": " Search Tree Operations  Before we look at the implementation, let's discuss the operations that will be provided by the BinarySearchTree . You should notice that this interface is very similar to the C++ Hash Table in . While the operations provided by BinarySearchTree are the same as the Hash Table, we will see that how items are stored and accessed is very different.    BinarySearchTree() Create a new, empty tree.    put(key,val) Add a new key-value pair to the tree. If the key is already in the tree then replace the old value with the new value.    get(key) Given a key, return the value stored in the tree or NULL otherwise.    del(key) Delete the key-value pair from the tree.    length() Return the number of key-value pairs stored in the tree.    "
},
{
  "id": "trees_search-tree-implementation",
  "level": "1",
  "url": "trees_search-tree-implementation.html",
  "type": "Section",
  "number": "8.13",
  "title": "Search Tree Implementation",
  "body": " Search Tree Implementation  bst property A binary search tree relies on the property that keys that are less than the parent are found in the left subtree, and keys that are greater than the parent are found in the right subtree. We will call this the bst property . As we implement the Map interface as described above, the bst property will guide our implementation. illustrates this property of a binary search tree, showing the keys without any associated values. Notice that the property holds for each parent and child. All of the keys in the left subtree are less than the key in the root. All of the keys in the right subtree are greater than the root.   A Simple Binary Search Tree.    Now that you know what a binary search tree is, we will look at how a binary search tree is constructed. The search tree in represents the nodes that exist after we have inserted the following keys in the order shown: . Since 70 was the first key inserted into the tree, it is the root. Next, 31 is less than 70, so it becomes the left child of 70. Next, 93 is greater than 70, so it becomes the right child of 70. Now we have two levels of the tree filled, so the next key is going to be the left or right child of either 31 or 93. Since 94 is greater than 70 and 93, it becomes the right child of 93. Similarly 14 is less than 70 and 31, so it becomes the left child of 31. 23 is also less than 31, so it must be in the left subtree of 31. However, it is greater than 14, so it becomes the right child of 14.  To implement the binary search tree, we will use the nodes and references approach similar to the one we used to implement the linked list, and the expression tree. To effectively manage scenerios where the binary search tree might be empty, we use two separate classes. The first class we will call BinarySearchTree , and the second class we will call TreeNode . The BinarySearchTree class has a reference to the TreeNode that is the root of the binary search tree. In most cases the external methods defined in the outer class simply check to see if the tree is empty. If there are nodes in the tree, the request is just passed on to a private method defined in the BinarySearchTree class that takes the root as a parameter. In the case where the tree is empty or we want to delete the key at the root of the tree, we must take special action. The code for the BinarySearchTree class constructor along with a few other miscellaneous functions is shown in .   BinarySearchTree Class and Constructor  class BinarySearchTree{ private: TreeNode *root; int size; public: BinarySearchTree(){ this->root = NULL; this->size = 0; } int length(){ return this->size; } }   The TreeNode class provides many helper functions that make the work done in the BinarySearchTree class methods much easier. The constructor for a TreeNode , along with these helper functions, is shown in . As you can see in the listing many of these helper functions help to classify a node according to its own position as a child, (left or right) and the kind of children the node has. The TreeNode class will also explicitly keep track of the parent as an attribute of each node. You will see why this is important when we discuss the implementation for the del operator.  Another interesting aspect of the implementation of TreeNode in is that we use C++'s optional parameters. Optional parameters make it easy for us to create a TreeNode under several different circumstances. Sometimes we will want to construct a new TreeNode that already has both a parent and a child . With an existing parent and child, we can pass parent and child as parameters. At other times we will just create a TreeNode with the key value pair, and we will not pass any parameters for parent or child . In this case, the default values of the optional parameters are used.   TreeNode Class  class TreeNode{ public: int key; string payload; TreeNode *leftChild; TreeNode *rightChild; TreeNode *parent; TreeNode(int key, string val, TreeNode *parent = NULL, TreeNode *left = NULL, TreeNode *right = NULL){ this->key = key; this->payload = val; this->leftChild = left; this->rightChild = right; this->parent = parent; } TreeNode *hasLeftChild(){ return this->leftChild; } TreeNode *hasRightChild(){ return this->rightChild; } bool isLeftChild(){ return this->parent && this->parent->leftChild == this; } bool isRightChild(){ return this->parent && this->parent->rightChild == this; } bool isRoot(){ return !this->parent; } bool isLeaf(){ return !(this->rightChild || this->leftChild); } bool hasAnyChildren(){ return this->rightChild || this->leftChild; } bool hasBothChildren(){ return this->rightChild && this->leftChild; } void replaceNodeData(int key, string value, TreeNode *lc = NULL, TreeNode *rc = NULL){ this->key = key; this->payload = value; this->leftChild = lc; this->rightChild = rc; if (this->hasLeftChild()){ this->leftChild->parent = this; } if (this->hasRightChild()){ this->rightChild->parent = this; } } }   Now that we have the BinarySearchTree shell and the TreeNode it is time to write the put method that will allow us to build our binary search tree. The put method is a method of the BinarySearchTree class. This method will check to see if the tree already has a root. If there is not a root then put will create a new TreeNode and install it as the root of the tree. If a root node is already in place then put calls the private, recursive, helper function _put to search the tree according to the following algorithm:    Starting at the root of the tree, search the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.    When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.    To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.    shows the C++ code for inserting a new node in the tree. The _put function is written recursively following the steps outlined above. Notice that when a new child is inserted into the tree, the currentNode is passed to the new tree as the parent.  One important problem with our implementation of insert is that duplicate keys are not handled properly. As our tree is implemented a duplicate key will create a new node with the same key value in the right subtree of the node having the original key. The result of this is that the node with the new key will never be found during a search. A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value. We leave fixing this bug as an exercise for you.   put and _put Methods  void put(int key, string val){ if (this->root){ this->_put(key, val, this->root); } else{ this->root = new TreeNode(key, val); } this->size = this->size + 1; } void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); } } }   illustrates the process for inserting a new node into a binary search tree. The lightly shaded nodes indicate the nodes that were visited during the insertion process.   Inserting a Node with Key = 19.    Self Check   Once the tree is constructed, the next task is to implement the retrieval of a value for a given key. The get method is even easier than the put method because it simply searches the tree recursively until it gets to a non-matching leaf node or finds a matching key. When a matching key is found, the value stored in the payload of the node is returned.  shows the code for get and _get . The search code in the _get method uses the same logic for choosing the left or right child as the _put method. Notice that the _get method returns a TreeNode to get , this allows _get to be used as a flexible helper method for other BinarySearchTree methods that may need to make use of other data from the TreeNode besides the payload.   get and _get Methods  string get(int key){ if (this->root){ TreeNode *res = this->_get(key, this->root); if (res){ return res->payload; } else{ return 0; } } else{ return 0; } } TreeNode *_get(int key, TreeNode *currentNode){ if (!currentNode){ return NULL; } else if (currentNode->key == key){ return currentNode; } else if (key < currentNode->key){ return this->_get(key, currentNode->leftChild); } else{ return this->_get(key, currentNode->rightChild); } }   Finally, we turn our attention to the most challenging method in the binary search tree, the deletion of a key (see ). The first task is to find the node to delete by searching the tree. If the tree has more than one node we search using the _get method to find the TreeNode that needs to be removed. If the tree only has a single node, that means we are removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted. In either case if the key is not found the del operator raises an error.   del Method  void del(int key){ if (this->size > 1){ TreeNode *nodeToRemove = this->_get(key, this->root); if (nodeToRemove){ this->remove(nodeToRemove); this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } else if (this->size == 1 && this->root->key == key){ this->root = NULL; this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } }   Once we've found the node containing the key we want to delete, there are three cases that we must consider:    The node to be deleted has no children (see ).    The node to be deleted has only one child (see ).    The node to be deleted has two children (see ).    The first case is straightforward (see ). If the current node has no children all we need to do is delete the node and remove the reference to this node in the parent. The code for this case is shown in here.   Deleting a Node With No Children  if (currentNode->isLeaf()){ \/\/leaf if (currentNode == currentNode->parent->leftChild){ currentNode->parent->leftChild = NULL; } else{ currentNode->parent->rightChild = NULL; } }    Deleting Node 16, a Node without Children.    The second case is only slightly more complicated (see ). If a node has only a single child, then we can simply promote the child to take the place of its parent. The code for this case is shown in the next listing. As you look at this code you will see that there are six cases to consider. Since the cases are symmetric with respect to either having a left or right child we will just discuss the case where the current node has a left child. The decision proceeds as follows:    If the current node is a left child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the left child reference of the parent to point to the current node's left child.    If the current node is a right child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the right child reference of the parent to point to the current node's left child.    If the current node has no parent, it must be the root. In this case we will just replace the key , payload , leftChild , and rightChild data by calling the replaceNodeData method on the root.     Handling One Child Node  else{ \/\/ this node has one child if (currentNode->hasLeftChild()){ if (currentNode->isLeftChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->leftChild; } else if (currentNode->isRightChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->leftChild; } else{ currentNode->replaceNodeData(currentNode->leftChild->key, currentNode->leftChild->payload, currentNode->leftChild->leftChild, currentNode->leftChild->rightChild); } } else{ if (currentNode->isLeftChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->rightChild; } else if (currentNode->isRightChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->rightChild; } else{ currentNode->replaceNodeData(currentNode->rightChild->key, currentNode->rightChild->payload, currentNode->rightChild->leftChild, currentNode->rightChild->rightChild); } } }    Deleting Node 25, a Node That Has a Single Child.    successor node The third case is the most difficult case to handle (see ). If a node has two children, then it is unlikely that we can simply promote one of them to take the node's place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the successor node , and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.   Deleting Node 5, a Node with Two Children.    The code to handle the third case is shown in . Notice that we make use of the helper methods findSuccessor and findMin to find the successor. To remove the successor, we make use of the method spliceOut . The reason we use spliceOut is that it goes directly to the node we want to splice out and makes the right changes. We could call delete recursively, but then we would waste time re-searching for the key node.   Deleting a Node With Two Children  else if (currentNode->hasBothChildren()){ \/\/interior TreeNode *succ = currentNode->findSuccessor(); succ->spliceOut(); currentNode->key = succ->key; currentNode->payload = succ->payload; }   The code to find the successor is shown below (see ) and as you can see is a method of the TreeNode class. This code makes use of the same properties of binary search trees that cause an inorder traversal to print out the nodes in the tree from smallest to largest. There are three cases to consider when looking for the successor:    If the node has a right child, then the successor is the smallest key in the right subtree.    If the node has no right child and is the left child of its parent, then the parent is the successor.    If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.    The first condition is the only one that matters for us when deleting a node from a binary search tree. However, the findSuccessor method has other uses that we will explore in the exercises at the end of this chapter.  The findMin method is called to find the minimum key in a subtree. You should convince yourself that the minimum valued key in any binary search tree is the leftmost child of the tree. Therefore the findMin method simply follows the leftChild references in each node of the subtree until it reaches a node that does not have a left child.   findSuccessor , findMin , and spliceOut Methods  TreeNode *findSuccessor(){ TreeNode *succ = NULL; if (this->hasRightChild()){ succ = this->rightChild->findMin(); } else{ if (this->parent){ if (this->isLeftChild()){ succ = this->parent; } else{ this->parent->rightChild = NULL; succ = this->parent->findSuccessor(); this->parent->rightChild = this; } } } return succ; } TreeNode *findMin(){ TreeNode *current = this; while (current->hasLeftChild()){ current = current->leftChild; } return current; } void spliceOut(){ if (this->isLeaf()){ if (this->isLeftChild()){ this->parent->leftChild = NULL; } else{ this->parent->rightChild = NULL; } } else if (this->hasAnyChildren()){ if (this->hasLeftChild()){ if (this->isLeftChild()){ this->parent->leftChild = this->leftChild; } else{ this->parent->rightChild = this->rightChild; } this->leftChild->parent = this->parent; } else{ if (this->isLeftChild()){ this->parent->leftChild = this->rightChild; } else{ this->parent->rightChild = this->rightChild; } this->rightChild->parent = this->parent; } } }   We need to look at one last interface method for the binary search tree. Suppose that we would like to simply iterate over all the keys in the tree in order. This is definitely something we have done with dictionaries, so why not trees? You already know how to traverse a binary tree in order, using the inorder traversal algorithm. However, writing an iterator requires a bit more work, since an iterator should return only one node each time the iterator is called.  Python provides us with a very powerful function to use when creating an iterator. The function is called yield . yield is similar to return in that it returns a value to the caller. However, yield also takes the additional step of freezing the state of the function so that the next time the function is called it continues executing from the exact point it left off earlier. Functions that create objects that can be iterated are called generator functions.  The code for an inorder iterator of a binary tree is shown in the next listing. Look at this code carefully; at first glance you might think that the code is not recursive. However, remember that __iter__ overrides the for x in operation for iteration, so it really is recursive! Because it is recursive over TreeNode instances the __iter__ method is defined in the TreeNode class ( ).   __iter__ Method for TreeNode Class  def __iter__(self): if self: if self.hasLeftChild(): for elem in self.leftChiLd: yield elem yield self.key if self.hasRightChild(): for elem in self.rightChild: yield elem   At this point you may want to download the entire file containing the full version of the BinarySearchTree and TreeNode classes shown in .   Complete Binary Search Tree  C++ Implementation #include <iostream> #include <cstdlib> #include <cstddef> #include <string> using namespace std; \/\/The TreeNode class represents a node, or vertex, in a tree heirarchy. class TreeNode{ public: int key; string payload; TreeNode *leftChild; TreeNode *rightChild; TreeNode *parent; \/\/ Using Optional parameters make it \/\/ easy for us to create a TreeNode under several different circumstances. TreeNode(int key, string val, TreeNode *parent = NULL, TreeNode *left = NULL, TreeNode *right = NULL){ this->key = key; this->payload = val; this->leftChild = left; this->rightChild = right; this->parent = parent; } \/\/ Returns a pointer to the left child of this node. \/\/ If null, the child doesn't exist. TreeNode *hasLeftChild(){ return this->leftChild; } \/\/Returns a pointer to the right child of this node. \/\/If null, the child doesn't exist. TreeNode *hasRightChild(){ return this->rightChild; } \/\/Returns a boolean indicating if this node is the left child of its parent. bool isLeftChild(){ return this->parent && this->parent->leftChild == this; } \/\/Returns a boolean indicating if this node is the right child of its parent. bool isRightChild(){ return this->parent && this->parent->rightChild == this; } \/\/Returns a boolean indicating if this node is a root node (has no parent). bool isRoot(){ return !this->parent; } \/\/Returns a boolean indicating if this node has no children. bool isLeaf(){ return !(this->rightChild || this->leftChild); } \/\/ Returns a boolean indicating if this node has children. bool hasAnyChildren(){ return this->rightChild || this->leftChild; } \/\/Returns a boolean indicating if this node has both children. bool hasBothChildren(){ return this->rightChild && this->leftChild; } \/\/Removes this node from the tree it exists in, \/\/making it the root node of its own tree. void spliceOut(){ if (this->isLeaf()){ if (this->isLeftChild()){ this->parent->leftChild = NULL; } else{ this->parent->rightChild = NULL; } } else if (this->hasAnyChildren()){ if (this->hasLeftChild()){ if (this->isLeftChild()){ this->parent->leftChild = this->leftChild; } else{ this->parent->rightChild = this->rightChild; } this->leftChild->parent = this->parent; } else{ if (this->isLeftChild()){ this->parent->leftChild = this->rightChild; } else{ this->parent->rightChild = this->rightChild; } this->rightChild->parent = this->parent; } } } \/\/ Uses same properties of binary search tree \/\/ that cause an inorder traversal to print out the \/\/ nodes in the tree from smallest to largest. TreeNode *findSuccessor(){ TreeNode *succ = NULL; if (this->hasRightChild()){ succ = this->rightChild->findMin(); } else{ if (this->parent){ if (this->isLeftChild()){ succ = this->parent; } else{ this->parent->rightChild = NULL; succ = this->parent->findSuccessor(); this->parent->rightChild = this; } } } return succ; } \/\/Finds the leftmost node out of all of this node's children. TreeNode *findMin(){ TreeNode *current = this; while (current->hasLeftChild()){ current = current->leftChild; } return current; } \/\/Sets the variables of this node. lc\/rc are left child and right child. void replaceNodeData(int key, string value, TreeNode *lc = NULL, TreeNode *rc = NULL){ this->key = key; this->payload = value; this->leftChild = lc; this->rightChild = rc; if (this->hasLeftChild()){ this->leftChild->parent = this; } if (this->hasRightChild()){ this->rightChild->parent = this; } } }; class BinarySearchTree{ \/\/ references the TreeNode \/\/ that is the root of the binary search tree. private: TreeNode *root; int size; \/*searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*\/ \/* When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*\/ \/*To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*\/ \/\/ this is all done recursively void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); } } } \/\/ Uses the same search method as _put, and returns \/\/ a TreeNode to get TreeNode *_get(int key, TreeNode *currentNode){ if (!currentNode){ return NULL; } else if (currentNode->key == key){ return currentNode; } else if (key < currentNode->key){ return this->_get(key, currentNode->leftChild); } else{ return this->_get(key, currentNode->rightChild); } } public: BinarySearchTree(){ this->root = NULL; this->size = 0; } int length(){ return this->size; } \/\/ Checks to see if the tree has a root, \/\/ if there is not a root then it will create a new TreeNode \/\/ and install it as the root of the tree. \/\/ If a root node is already in place than it calls _put \/\/ to search the tree void put(int key, string val){ if (this->root){ this->_put(key, val, this->root); } else{ this->root = new TreeNode(key, val); } this->size = this->size + 1; } \/\/ prints string associated with key to console string get(int key){ if (this->root){ TreeNode *res = this->_get(key, this->root); if (res){ return res->payload; } else{ return 0; } } else{ return 0; } } \/\/ checks to make sure the key of the root matches the key that is to be deleted. \/\/ In either case if the key is not found an error is raised. \/\/ If the node is found and has no childeren it is deleted \/\/ If the node has a single child, the child takes the place of the parent. \/\/ Look at explination for listing 10 void del(int key){ if (this->size > 1){ TreeNode *nodeToRemove = this->_get(key, this->root); if (nodeToRemove){ this->remove(nodeToRemove); this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } else if (this->size == 1 && this->root->key == key){ this->root = NULL; this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } void remove(TreeNode *currentNode){ if (currentNode->isLeaf()){ \/\/leaf if (currentNode == currentNode->parent->leftChild){ currentNode->parent->leftChild = NULL; } else{ currentNode->parent->rightChild = NULL; } } else if (currentNode->hasBothChildren()){ \/\/interior TreeNode *succ = currentNode->findSuccessor(); succ->spliceOut(); currentNode->key = succ->key; currentNode->payload = succ->payload; } else{ \/\/ this node has one child if (currentNode->hasLeftChild()){ if (currentNode->isLeftChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->leftChild; } else if (currentNode->isRightChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->leftChild; } else{ currentNode->replaceNodeData(currentNode->leftChild->key, currentNode->leftChild->payload, currentNode->leftChild->leftChild, currentNode->leftChild->rightChild); } } else{ if (currentNode->isLeftChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->rightChild; } else if (currentNode->isRightChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->rightChild; } else{ currentNode->replaceNodeData(currentNode->rightChild->key, currentNode->rightChild->payload, currentNode->rightChild->leftChild, currentNode->rightChild->rightChild); } } } } }; int main(){ BinarySearchTree *mytree = new BinarySearchTree(); mytree->put(3, \"red\"); mytree->put(4, \"blue\"); mytree->put(6, \"yellow\"); mytree->put(2, \"at\"); cout << mytree->get(6) << endl; cout << mytree->get(2) << endl; return 0; }  Python Implementation #The TreeNode class represents a node, or vertex, in a tree heirarchy. class TreeNode: def __init__(self,key,val,left=None,right=None,parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent \"\"\" Returns a pointer to the left child of this node. If null, the child doesn't exist.\"\"\" def hasLeftChild(self): return self.leftChild \"\"\" Returns the right child, or None if it doesn't exist.\"\"\" def hasRightChild(self): return self.rightChild # Returns a boolean indicating if this node is the left child of its parent. def isLeftChild(self): return self.parent and self.parent.leftChild == self # Returns a boolean indicating if this node is the right child of its parent. def isRightChild(self): return self.parent and self.parent.rightChild == self # Returns a boolean indicating if this node is a root node (has no parents). def isRoot(self): return not self.parent # Returns a boolean indicating if this node has no children. def isLeaf(self): return not (self.rightChild or self.leftChild) # Returns a boolean indicating if this node has children. def hasAnyChildren(self): return self.rightChild or self.leftChild # Returns a boolean indicating if this node has both childeren. def hasBothChildren(self): return self.rightChild and self.leftChild \"\"\" Removes this node from the tree it exists in, making it the root node of its own tree.\"\"\" def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.hasLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent \"\"\" Uses same properties of binary search tree that cause an inorder traversal to find nodes in the tree from smallest to largest. \"\"\" def findSuccessor(self): succ = None if self.hasRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ #Finds the leftmost node out of all of this node's children. def findMin(self): current = self while current.hasLeftChild(): current = current.leftChild return current # Sets the variables of this node. lc\/rc are left child and right child. def replaceNodeData(self,key,value,lc,rc): self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.hasLeftChild(): self.leftChild.parent = self if self.hasRightChild(): self.rightChild.parent = self class BinarySearchTree: # references the TreeNode # that is the root of the binary search tree. def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size \"\"\"Checks to see if the tree has a root, if there is not a root then it will create a new TreeNode and install it as the root of the tree. If a root node is already in place than it calls _put to search the tree\"\"\" def put(self,key,val): if self.root: self._put(key,val,self.root) else: self.root = TreeNode(key,val) self.size = self.size + 1 \"\"\"searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*\\ When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*\\ To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*\\ this is all done recursively\"\"\" def _put(self,key,val,currentNode): if key < currentNode.key: if currentNode.hasLeftChild(): self._put(key,val,currentNode.leftChild) else: currentNode.leftChild = TreeNode(key,val,parent=currentNode) else: if currentNode.hasRightChild(): self._put(key,val,currentNode.rightChild) else: currentNode.rightChild = TreeNode(key,val,parent=currentNode) # prints string associated with key to console def get(self,key): if self.root: res = self._get(key,self.root) if res: return res.payload else: return None else: return None # Uses the same search method as _put, and returns # a TreeNode to get def _get(self,key,currentNode): if not currentNode: return None elif currentNode.key == key: return currentNode elif key < currentNode.key: return self._get(key,currentNode.leftChild) else: return self._get(key,currentNode.rightChild) #def __contains__(self,key): # if self._get(key,self.root): # return True #else: # return False \"\"\" Checks to make sure the key of the root matches the key that is to be deleted. In either case if the key is not found an error is raised. If the node is found and has no childeren it is deleted If the node has a single child, the child takes the place of the parent. Look at explination for listing 10 \"\"\" def delete(self,key): if self.size > 1: nodeToRemove = self._get(key,self.root) if nodeToRemove: self.remove(nodeToRemove) self.size = self.size-1 else: raise KeyError('Error, key not in tree') elif self.size == 1 and self.root.key == key: self.root = None self.size = self.size - 1 else: raise KeyError('Error, key not in tree') # Removes the specified currentNode from this tree. def remove(self,currentNode): if currentNode.isLeaf(): #leaf if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None elif currentNode.hasBothChildren(): #interior succ = currentNode.findSuccessor() succ.spliceOut() currentNode.key = succ.key currentNode.payload = succ.payload else: # this node has one child if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.leftChild elif currentNode.isRightChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.leftChild else: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) else: if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.rightChild elif currentNode.isRightChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.rightChild else: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) def main(): mytree = BinarySearchTree() mytree.put(3, \"red\") mytree.put(4, \"blue\") mytree.put(6, \"yellow\") mytree.put(2, \"at\") print(mytree.get(6)) print(mytree.get(2)) main()    Reading Questions   How many children can a node have in a binary search tree?     At least 4    Incorrect. Refer back to the definition of a binary search tree.      At most 3    Incorrect.      At least 1    Incorrect, it has a limit.      At most 2    Correct!      Which of the trees shows a correct binary search tree given that the keys were inserted in the following order 5, 30, 2, 40, 25, 4.        Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.         good job.         This looks like a binary tree that satisfies the full tree property needed for a heap.      "
},
{
  "id": "trees_search-tree-implementation-2",
  "level": "2",
  "url": "trees_search-tree-implementation.html#trees_search-tree-implementation-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "bst property "
},
{
  "id": "bst_fig-simplebst",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_fig-simplebst",
  "type": "Figure",
  "number": "8.13.1",
  "title": "",
  "body": " A Simple Binary Search Tree.   "
},
{
  "id": "bst_lst-bst1",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst1",
  "type": "Listing",
  "number": "8.13.2",
  "title": "",
  "body": " BinarySearchTree Class and Constructor  class BinarySearchTree{ private: TreeNode *root; int size; public: BinarySearchTree(){ this->root = NULL; this->size = 0; } int length(){ return this->size; } }  "
},
{
  "id": "bst_lst-bst2",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst2",
  "type": "Listing",
  "number": "8.13.3",
  "title": "",
  "body": " TreeNode Class  class TreeNode{ public: int key; string payload; TreeNode *leftChild; TreeNode *rightChild; TreeNode *parent; TreeNode(int key, string val, TreeNode *parent = NULL, TreeNode *left = NULL, TreeNode *right = NULL){ this->key = key; this->payload = val; this->leftChild = left; this->rightChild = right; this->parent = parent; } TreeNode *hasLeftChild(){ return this->leftChild; } TreeNode *hasRightChild(){ return this->rightChild; } bool isLeftChild(){ return this->parent && this->parent->leftChild == this; } bool isRightChild(){ return this->parent && this->parent->rightChild == this; } bool isRoot(){ return !this->parent; } bool isLeaf(){ return !(this->rightChild || this->leftChild); } bool hasAnyChildren(){ return this->rightChild || this->leftChild; } bool hasBothChildren(){ return this->rightChild && this->leftChild; } void replaceNodeData(int key, string value, TreeNode *lc = NULL, TreeNode *rc = NULL){ this->key = key; this->payload = value; this->leftChild = lc; this->rightChild = rc; if (this->hasLeftChild()){ this->leftChild->parent = this; } if (this->hasRightChild()){ this->rightChild->parent = this; } } }  "
},
{
  "id": "bst_lst-bst3",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst3",
  "type": "Listing",
  "number": "8.13.4",
  "title": "",
  "body": " put and _put Methods  void put(int key, string val){ if (this->root){ this->_put(key, val, this->root); } else{ this->root = new TreeNode(key, val); } this->size = this->size + 1; } void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); } } }  "
},
{
  "id": "bst_fig-bstput",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_fig-bstput",
  "type": "Figure",
  "number": "8.13.5",
  "title": "",
  "body": " Inserting a Node with Key = 19.  "
},
{
  "id": "trees_search-tree-implementation-17",
  "level": "2",
  "url": "trees_search-tree-implementation.html#trees_search-tree-implementation-17",
  "type": "Note",
  "number": "8.13.6",
  "title": "Self Check.",
  "body": " Self Check  "
},
{
  "id": "bst_lst-bst4",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst4",
  "type": "Listing",
  "number": "8.13.7",
  "title": "",
  "body": " get and _get Methods  string get(int key){ if (this->root){ TreeNode *res = this->_get(key, this->root); if (res){ return res->payload; } else{ return 0; } } else{ return 0; } } TreeNode *_get(int key, TreeNode *currentNode){ if (!currentNode){ return NULL; } else if (currentNode->key == key){ return currentNode; } else if (key < currentNode->key){ return this->_get(key, currentNode->leftChild); } else{ return this->_get(key, currentNode->rightChild); } }  "
},
{
  "id": "bst_lst-bst5",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst5",
  "type": "Listing",
  "number": "8.13.8",
  "title": "",
  "body": " del Method  void del(int key){ if (this->size > 1){ TreeNode *nodeToRemove = this->_get(key, this->root); if (nodeToRemove){ this->remove(nodeToRemove); this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } else if (this->size == 1 && this->root->key == key){ this->root = NULL; this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } }  "
},
{
  "id": "bst_lst-bst6",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst6",
  "type": "Listing",
  "number": "8.13.9",
  "title": "",
  "body": " Deleting a Node With No Children  if (currentNode->isLeaf()){ \/\/leaf if (currentNode == currentNode->parent->leftChild){ currentNode->parent->leftChild = NULL; } else{ currentNode->parent->rightChild = NULL; } }  "
},
{
  "id": "bst_fig-bstdel1",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_fig-bstdel1",
  "type": "Figure",
  "number": "8.13.10",
  "title": "",
  "body": " Deleting Node 16, a Node without Children.   "
},
{
  "id": "bst_lst-bst7",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst7",
  "type": "Listing",
  "number": "8.13.11",
  "title": "",
  "body": " Handling One Child Node  else{ \/\/ this node has one child if (currentNode->hasLeftChild()){ if (currentNode->isLeftChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->leftChild; } else if (currentNode->isRightChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->leftChild; } else{ currentNode->replaceNodeData(currentNode->leftChild->key, currentNode->leftChild->payload, currentNode->leftChild->leftChild, currentNode->leftChild->rightChild); } } else{ if (currentNode->isLeftChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->rightChild; } else if (currentNode->isRightChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->rightChild; } else{ currentNode->replaceNodeData(currentNode->rightChild->key, currentNode->rightChild->payload, currentNode->rightChild->leftChild, currentNode->rightChild->rightChild); } } }  "
},
{
  "id": "bst_fig-bstdel2",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_fig-bstdel2",
  "type": "Figure",
  "number": "8.13.12",
  "title": "",
  "body": " Deleting Node 25, a Node That Has a Single Child.   "
},
{
  "id": "trees_search-tree-implementation-32",
  "level": "2",
  "url": "trees_search-tree-implementation.html#trees_search-tree-implementation-32",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "successor node "
},
{
  "id": "bst_fig-bstdel3",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_fig-bstdel3",
  "type": "Figure",
  "number": "8.13.13",
  "title": "",
  "body": " Deleting Node 5, a Node with Two Children.   "
},
{
  "id": "bst_lst-bst8",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst8",
  "type": "Listing",
  "number": "8.13.14",
  "title": "",
  "body": " Deleting a Node With Two Children  else if (currentNode->hasBothChildren()){ \/\/interior TreeNode *succ = currentNode->findSuccessor(); succ->spliceOut(); currentNode->key = succ->key; currentNode->payload = succ->payload; }  "
},
{
  "id": "bst_lst-bst9",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_lst-bst9",
  "type": "Listing",
  "number": "8.13.15",
  "title": "",
  "body": " findSuccessor , findMin , and spliceOut Methods  TreeNode *findSuccessor(){ TreeNode *succ = NULL; if (this->hasRightChild()){ succ = this->rightChild->findMin(); } else{ if (this->parent){ if (this->isLeftChild()){ succ = this->parent; } else{ this->parent->rightChild = NULL; succ = this->parent->findSuccessor(); this->parent->rightChild = this; } } } return succ; } TreeNode *findMin(){ TreeNode *current = this; while (current->hasLeftChild()){ current = current->leftChild; } return current; } void spliceOut(){ if (this->isLeaf()){ if (this->isLeftChild()){ this->parent->leftChild = NULL; } else{ this->parent->rightChild = NULL; } } else if (this->hasAnyChildren()){ if (this->hasLeftChild()){ if (this->isLeftChild()){ this->parent->leftChild = this->leftChild; } else{ this->parent->rightChild = this->rightChild; } this->leftChild->parent = this->parent; } else{ if (this->isLeftChild()){ this->parent->leftChild = this->rightChild; } else{ this->parent->rightChild = this->rightChild; } this->rightChild->parent = this->parent; } } }  "
},
{
  "id": "lst-bst-pyiter",
  "level": "2",
  "url": "trees_search-tree-implementation.html#lst-bst-pyiter",
  "type": "Listing",
  "number": "8.13.16",
  "title": "",
  "body": " __iter__ Method for TreeNode Class  def __iter__(self): if self: if self.hasLeftChild(): for elem in self.leftChiLd: yield elem yield self.key if self.hasRightChild(): for elem in self.rightChild: yield elem  "
},
{
  "id": "expl-bstwhole",
  "level": "2",
  "url": "trees_search-tree-implementation.html#expl-bstwhole",
  "type": "Exploration",
  "number": "8.13.1",
  "title": "Complete Binary Search Tree.",
  "body": " Complete Binary Search Tree  C++ Implementation #include <iostream> #include <cstdlib> #include <cstddef> #include <string> using namespace std; \/\/The TreeNode class represents a node, or vertex, in a tree heirarchy. class TreeNode{ public: int key; string payload; TreeNode *leftChild; TreeNode *rightChild; TreeNode *parent; \/\/ Using Optional parameters make it \/\/ easy for us to create a TreeNode under several different circumstances. TreeNode(int key, string val, TreeNode *parent = NULL, TreeNode *left = NULL, TreeNode *right = NULL){ this->key = key; this->payload = val; this->leftChild = left; this->rightChild = right; this->parent = parent; } \/\/ Returns a pointer to the left child of this node. \/\/ If null, the child doesn't exist. TreeNode *hasLeftChild(){ return this->leftChild; } \/\/Returns a pointer to the right child of this node. \/\/If null, the child doesn't exist. TreeNode *hasRightChild(){ return this->rightChild; } \/\/Returns a boolean indicating if this node is the left child of its parent. bool isLeftChild(){ return this->parent && this->parent->leftChild == this; } \/\/Returns a boolean indicating if this node is the right child of its parent. bool isRightChild(){ return this->parent && this->parent->rightChild == this; } \/\/Returns a boolean indicating if this node is a root node (has no parent). bool isRoot(){ return !this->parent; } \/\/Returns a boolean indicating if this node has no children. bool isLeaf(){ return !(this->rightChild || this->leftChild); } \/\/ Returns a boolean indicating if this node has children. bool hasAnyChildren(){ return this->rightChild || this->leftChild; } \/\/Returns a boolean indicating if this node has both children. bool hasBothChildren(){ return this->rightChild && this->leftChild; } \/\/Removes this node from the tree it exists in, \/\/making it the root node of its own tree. void spliceOut(){ if (this->isLeaf()){ if (this->isLeftChild()){ this->parent->leftChild = NULL; } else{ this->parent->rightChild = NULL; } } else if (this->hasAnyChildren()){ if (this->hasLeftChild()){ if (this->isLeftChild()){ this->parent->leftChild = this->leftChild; } else{ this->parent->rightChild = this->rightChild; } this->leftChild->parent = this->parent; } else{ if (this->isLeftChild()){ this->parent->leftChild = this->rightChild; } else{ this->parent->rightChild = this->rightChild; } this->rightChild->parent = this->parent; } } } \/\/ Uses same properties of binary search tree \/\/ that cause an inorder traversal to print out the \/\/ nodes in the tree from smallest to largest. TreeNode *findSuccessor(){ TreeNode *succ = NULL; if (this->hasRightChild()){ succ = this->rightChild->findMin(); } else{ if (this->parent){ if (this->isLeftChild()){ succ = this->parent; } else{ this->parent->rightChild = NULL; succ = this->parent->findSuccessor(); this->parent->rightChild = this; } } } return succ; } \/\/Finds the leftmost node out of all of this node's children. TreeNode *findMin(){ TreeNode *current = this; while (current->hasLeftChild()){ current = current->leftChild; } return current; } \/\/Sets the variables of this node. lc\/rc are left child and right child. void replaceNodeData(int key, string value, TreeNode *lc = NULL, TreeNode *rc = NULL){ this->key = key; this->payload = value; this->leftChild = lc; this->rightChild = rc; if (this->hasLeftChild()){ this->leftChild->parent = this; } if (this->hasRightChild()){ this->rightChild->parent = this; } } }; class BinarySearchTree{ \/\/ references the TreeNode \/\/ that is the root of the binary search tree. private: TreeNode *root; int size; \/*searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*\/ \/* When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*\/ \/*To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*\/ \/\/ this is all done recursively void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); } } } \/\/ Uses the same search method as _put, and returns \/\/ a TreeNode to get TreeNode *_get(int key, TreeNode *currentNode){ if (!currentNode){ return NULL; } else if (currentNode->key == key){ return currentNode; } else if (key < currentNode->key){ return this->_get(key, currentNode->leftChild); } else{ return this->_get(key, currentNode->rightChild); } } public: BinarySearchTree(){ this->root = NULL; this->size = 0; } int length(){ return this->size; } \/\/ Checks to see if the tree has a root, \/\/ if there is not a root then it will create a new TreeNode \/\/ and install it as the root of the tree. \/\/ If a root node is already in place than it calls _put \/\/ to search the tree void put(int key, string val){ if (this->root){ this->_put(key, val, this->root); } else{ this->root = new TreeNode(key, val); } this->size = this->size + 1; } \/\/ prints string associated with key to console string get(int key){ if (this->root){ TreeNode *res = this->_get(key, this->root); if (res){ return res->payload; } else{ return 0; } } else{ return 0; } } \/\/ checks to make sure the key of the root matches the key that is to be deleted. \/\/ In either case if the key is not found an error is raised. \/\/ If the node is found and has no childeren it is deleted \/\/ If the node has a single child, the child takes the place of the parent. \/\/ Look at explination for listing 10 void del(int key){ if (this->size > 1){ TreeNode *nodeToRemove = this->_get(key, this->root); if (nodeToRemove){ this->remove(nodeToRemove); this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } else if (this->size == 1 && this->root->key == key){ this->root = NULL; this->size = this->size - 1; } else{ cerr << \"Error, key not in tree\" << endl; } } void remove(TreeNode *currentNode){ if (currentNode->isLeaf()){ \/\/leaf if (currentNode == currentNode->parent->leftChild){ currentNode->parent->leftChild = NULL; } else{ currentNode->parent->rightChild = NULL; } } else if (currentNode->hasBothChildren()){ \/\/interior TreeNode *succ = currentNode->findSuccessor(); succ->spliceOut(); currentNode->key = succ->key; currentNode->payload = succ->payload; } else{ \/\/ this node has one child if (currentNode->hasLeftChild()){ if (currentNode->isLeftChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->leftChild; } else if (currentNode->isRightChild()){ currentNode->leftChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->leftChild; } else{ currentNode->replaceNodeData(currentNode->leftChild->key, currentNode->leftChild->payload, currentNode->leftChild->leftChild, currentNode->leftChild->rightChild); } } else{ if (currentNode->isLeftChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->leftChild = currentNode->rightChild; } else if (currentNode->isRightChild()){ currentNode->rightChild->parent = currentNode->parent; currentNode->parent->rightChild = currentNode->rightChild; } else{ currentNode->replaceNodeData(currentNode->rightChild->key, currentNode->rightChild->payload, currentNode->rightChild->leftChild, currentNode->rightChild->rightChild); } } } } }; int main(){ BinarySearchTree *mytree = new BinarySearchTree(); mytree->put(3, \"red\"); mytree->put(4, \"blue\"); mytree->put(6, \"yellow\"); mytree->put(2, \"at\"); cout << mytree->get(6) << endl; cout << mytree->get(2) << endl; return 0; }  Python Implementation #The TreeNode class represents a node, or vertex, in a tree heirarchy. class TreeNode: def __init__(self,key,val,left=None,right=None,parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent \"\"\" Returns a pointer to the left child of this node. If null, the child doesn't exist.\"\"\" def hasLeftChild(self): return self.leftChild \"\"\" Returns the right child, or None if it doesn't exist.\"\"\" def hasRightChild(self): return self.rightChild # Returns a boolean indicating if this node is the left child of its parent. def isLeftChild(self): return self.parent and self.parent.leftChild == self # Returns a boolean indicating if this node is the right child of its parent. def isRightChild(self): return self.parent and self.parent.rightChild == self # Returns a boolean indicating if this node is a root node (has no parents). def isRoot(self): return not self.parent # Returns a boolean indicating if this node has no children. def isLeaf(self): return not (self.rightChild or self.leftChild) # Returns a boolean indicating if this node has children. def hasAnyChildren(self): return self.rightChild or self.leftChild # Returns a boolean indicating if this node has both childeren. def hasBothChildren(self): return self.rightChild and self.leftChild \"\"\" Removes this node from the tree it exists in, making it the root node of its own tree.\"\"\" def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.hasLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent \"\"\" Uses same properties of binary search tree that cause an inorder traversal to find nodes in the tree from smallest to largest. \"\"\" def findSuccessor(self): succ = None if self.hasRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ #Finds the leftmost node out of all of this node's children. def findMin(self): current = self while current.hasLeftChild(): current = current.leftChild return current # Sets the variables of this node. lc\/rc are left child and right child. def replaceNodeData(self,key,value,lc,rc): self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.hasLeftChild(): self.leftChild.parent = self if self.hasRightChild(): self.rightChild.parent = self class BinarySearchTree: # references the TreeNode # that is the root of the binary search tree. def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size \"\"\"Checks to see if the tree has a root, if there is not a root then it will create a new TreeNode and install it as the root of the tree. If a root node is already in place than it calls _put to search the tree\"\"\" def put(self,key,val): if self.root: self._put(key,val,self.root) else: self.root = TreeNode(key,val) self.size = self.size + 1 \"\"\"searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*\\ When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*\\ To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*\\ this is all done recursively\"\"\" def _put(self,key,val,currentNode): if key < currentNode.key: if currentNode.hasLeftChild(): self._put(key,val,currentNode.leftChild) else: currentNode.leftChild = TreeNode(key,val,parent=currentNode) else: if currentNode.hasRightChild(): self._put(key,val,currentNode.rightChild) else: currentNode.rightChild = TreeNode(key,val,parent=currentNode) # prints string associated with key to console def get(self,key): if self.root: res = self._get(key,self.root) if res: return res.payload else: return None else: return None # Uses the same search method as _put, and returns # a TreeNode to get def _get(self,key,currentNode): if not currentNode: return None elif currentNode.key == key: return currentNode elif key < currentNode.key: return self._get(key,currentNode.leftChild) else: return self._get(key,currentNode.rightChild) #def __contains__(self,key): # if self._get(key,self.root): # return True #else: # return False \"\"\" Checks to make sure the key of the root matches the key that is to be deleted. In either case if the key is not found an error is raised. If the node is found and has no childeren it is deleted If the node has a single child, the child takes the place of the parent. Look at explination for listing 10 \"\"\" def delete(self,key): if self.size > 1: nodeToRemove = self._get(key,self.root) if nodeToRemove: self.remove(nodeToRemove) self.size = self.size-1 else: raise KeyError('Error, key not in tree') elif self.size == 1 and self.root.key == key: self.root = None self.size = self.size - 1 else: raise KeyError('Error, key not in tree') # Removes the specified currentNode from this tree. def remove(self,currentNode): if currentNode.isLeaf(): #leaf if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None elif currentNode.hasBothChildren(): #interior succ = currentNode.findSuccessor() succ.spliceOut() currentNode.key = succ.key currentNode.payload = succ.payload else: # this node has one child if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.leftChild elif currentNode.isRightChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.leftChild else: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) else: if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.rightChild elif currentNode.isRightChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.rightChild else: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) def main(): mytree = BinarySearchTree() mytree.put(3, \"red\") mytree.put(4, \"blue\") mytree.put(6, \"yellow\") mytree.put(2, \"at\") print(mytree.get(6)) print(mytree.get(2)) main()  "
},
{
  "id": "question1_2",
  "level": "2",
  "url": "trees_search-tree-implementation.html#question1_2",
  "type": "Reading Question",
  "number": "8.13.1",
  "title": "",
  "body": " How many children can a node have in a binary search tree?     At least 4    Incorrect. Refer back to the definition of a binary search tree.      At most 3    Incorrect.      At least 1    Incorrect, it has a limit.      At most 2    Correct!    "
},
{
  "id": "bst_1",
  "level": "2",
  "url": "trees_search-tree-implementation.html#bst_1",
  "type": "Reading Question",
  "number": "8.13.2",
  "title": "",
  "body": " Which of the trees shows a correct binary search tree given that the keys were inserted in the following order 5, 30, 2, 40, 25, 4.        Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.         good job.         This looks like a binary tree that satisfies the full tree property needed for a heap.    "
},
{
  "id": "trees_search-tree-analysis",
  "level": "1",
  "url": "trees_search-tree-analysis.html",
  "type": "Section",
  "number": "8.14",
  "title": "Search Tree Analysis",
  "body": " Search Tree Analysis  With the implementation of a binary search tree now complete, we will do a quick analysis of the methods we have implemented. Let's first look at the put method. The limiting factor on its performance is the height of the binary tree. Recall from the vocabulary section that the height of a tree is the number of edges between the root and the deepest leaf node. The height is the limiting factor because when we are searching for the appropriate place to insert a node into the tree, we will need to do at most one comparison at each level of the tree.  What is the height of a binary tree likely to be? The answer to this question depends on how the keys are added to the tree. If the keys are added in a random order, the height of the tree is going to be around where is the number of nodes in the tree. This is because if the keys are randomly distributed, about half of them will be less than the root and half will be greater than the root. Remember that in a binary tree there is one node at the root, two nodes in the next level, and four at the next. The number of nodes at any particular level is where is the depth of the level. The total number of nodes in a perfectly balanced binary tree is , where represents the height of the tree.  A perfectly balanced tree has the same number of nodes in the left subtree as the right subtree. In a balanced binary tree, the worst-case performance of put is , where is the number of nodes in the tree. Notice that this is the inverse relationship to the calculation in the previous paragraph. So gives us the height of the tree, and represents the maximum number of comparisons that put will need to do as it searches for the proper place to insert a new node.  Unfortunately it is possible to construct a search tree that has height simply by inserting the keys in sorted order! An example of such a tree is shown in . In this case the performance of the put method is .  A skewed binary search tree would give poor performance.  Now that you understand that the performance of the put method is limited by the height of the tree, you can probably guess that other methods, get, in, and del , are limited as well. Since get searches the tree to find the key, in the worst case the tree is searched all the way to the bottom and no key is found. At first glance del might seem more complicated, since it may need to search for the successor before the deletion operation can complete. But remember that the worst-case scenario to find the successor is also just the height of the tree which means that you would simply double the work. Since doubling is a constant factor it does not change worst case   Reading Question   The worst-case performance of the del function is O( )? Is the correct answer! Read carefully the restrictions of the the functions   "
},
{
  "id": "fig-skewedtree-analysis",
  "level": "2",
  "url": "trees_search-tree-analysis.html#fig-skewedtree-analysis",
  "type": "Figure",
  "number": "8.14.1",
  "title": "",
  "body": "A skewed binary search tree would give poor performance. "
},
{
  "id": "stanalysis_1",
  "level": "2",
  "url": "trees_search-tree-analysis.html#stanalysis_1",
  "type": "Reading Question",
  "number": "8.14.1",
  "title": "",
  "body": " The worst-case performance of the del function is O( )? Is the correct answer! Read carefully the restrictions of the the functions "
},
{
  "id": "trees_balanced-binary-search-trees",
  "level": "1",
  "url": "trees_balanced-binary-search-trees.html",
  "type": "Section",
  "number": "8.15",
  "title": "Balanced Binary Search Trees",
  "body": " Balanced Binary Search Trees  AVL tree The previous section we looked at building a binary search tree. As we learned, the performance of the binary search tree can degrade to for operations like get and put when the tree becomes unbalanced. In this section we will look at a special kind of binary search tree that automatically makes sure that the tree remains balanced at all times. This tree is called an AVL tree and is named for its inventors: G.M. Adelson-Velskii and E.M. Landis.  balance factor An AVL tree implements the Map abstract data type just like a regular binary search tree, the only difference is in how the tree performs. To implement our AVL tree we need to keep track of a balance factor for each node in the tree. We do this by looking at the heights of the left and right subtrees for each node. More formally, we define the balance factor for a node as the difference between the height of the left subtree and the height of the right subtree.   Using the definition for balance factor given above we say that a subtree is left-heavy if the balance factor is greater than zero. If the balance factor is less than zero then the subtree is right heavy. If the balance factor is zero then the tree is perfectly in balance. For purposes of implementing an AVL tree, and gaining the benefit of having a balanced tree we will define a tree to be in balance if the balance factor is -1, 0, or 1. Once the balance factor of a node in a tree is outside this range we will need to have a procedure to bring the tree back into balance. shows an example of an unbalanced, right-heavy tree and the balance factors of each node.  An Unbalanced Right-Heavy Tree with Balance Factors.  "
},
{
  "id": "trees_balanced-binary-search-trees-2",
  "level": "2",
  "url": "trees_balanced-binary-search-trees.html#trees_balanced-binary-search-trees-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "AVL tree "
},
{
  "id": "trees_balanced-binary-search-trees-3",
  "level": "2",
  "url": "trees_balanced-binary-search-trees.html#trees_balanced-binary-search-trees-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "balance factor "
},
{
  "id": "fig-unbal",
  "level": "2",
  "url": "trees_balanced-binary-search-trees.html#fig-unbal",
  "type": "Figure",
  "number": "8.15.1",
  "title": "",
  "body": "An Unbalanced Right-Heavy Tree with Balance Factors. "
},
{
  "id": "trees_avl-tree-performance",
  "level": "1",
  "url": "trees_avl-tree-performance.html",
  "type": "Section",
  "number": "8.16",
  "title": "AVL Tree Performance",
  "body": " AVL Tree Performance  Before we proceed any further let's look at the result of enforcing this new balance factor requirement. Our claim is that by ensuring that a tree always has a balance factor of -1, 0, or 1 we can get better Big-O performance of key operations. Let us start by thinking about how this balance condition changes the worst-case tree. There are two possibilities to consider, a left-heavy tree and a right heavy tree. If we consider trees of heights 0, 1, 2, and 3, illustrates the most unbalanced left-heavy tree possible under the new rules.  Worst-Case Left-Heavy AVL Trees.  Looking at the total number of nodes in the tree we see that for a tree of height 0 there is 1 node, for a tree of height 1 there is nodes, for a tree of height 2 there are and for a tree of height 3 there are . More generally the pattern we see for the number of nodes in a tree of height h ( ) is:   This recurrence may look familiar to you because it is very similar to the Fibonacci sequence. We can use this fact to derive a formula for the height of an AVL tree given the number of nodes in the tree. Recall that for the Fibonacci sequence the Fibonacci number is given by:   An important mathematical result is that as the numbers of the Fibonacci sequence get larger and larger the ratio of becomes closer and closer to approximating the golden ratio which is defined as . You can consult a math text if you want to see a derivation of the previous equation. We will simply use this equation to approximate as . If we make use of this approximation we can rewrite the equation for as:   By replacing the Fibonacci reference with its golden ratio approximation we get:   If we rearrange the terms, and take the base 2 log of both sides and then solve for we get the following derivation:   This derivation shows us that at any time the height of our AVL tree is equal to a constant(1.44) times the log of the number of nodes in the tree. This is great news for searching our AVL tree because it limits the search to .  "
},
{
  "id": "fig-worstavl",
  "level": "2",
  "url": "trees_avl-tree-performance.html#fig-worstavl",
  "type": "Figure",
  "number": "8.16.1",
  "title": "",
  "body": "Worst-Case Left-Heavy AVL Trees. "
},
{
  "id": "trees_avl-tree-implementation",
  "level": "1",
  "url": "trees_avl-tree-implementation.html",
  "type": "Section",
  "number": "8.17",
  "title": "AVL Tree Implementation",
  "body": " AVL Tree Implementation  Now that we have demonstrated that keeping an AVL tree in balance is going to be a big performance improvement, let us look at how we will augment the procedure to insert a new key into the tree. Since all new keys are inserted into the tree as leaf nodes and we know that the balance factor for a new leaf is zero, there are no new requirements for the node that was just inserted. But once the new leaf is added we must update the balance factor of its parent. How this new leaf affects the parent's balance factor depends on whether the leaf node is a left child or a right child. If the new node is a right child the balance factor of the parent will be reduced by one. If the new node is a left child then the balance factor of the parent will be increased by one. This relation can be applied recursively to the grandparent of the new node, and possibly to every ancestor all the way up to the root of the tree. Since this is a recursive procedure let us examine the two base cases for updating balance factors:    The recursive call has reached the root of the tree.    The balance factor of the parent has been adjusted to zero. You should convince yourself that once a subtree has a balance factor of zero, then the balance of its ancestor nodes does not change.    We will implement the AVL tree as a subclass of BinarySearchTree . To begin, we will override the _put method and write a new updateBalance helper method. These methods are shown in . You will notice that the definition for _put is exactly the same as in simple binary search trees except for the additions of the calls to updateBalance on lines 8 and 17.   Implementation of _put and updateBalance  void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); this->updateBalance(currentNode->leftChild); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); this->updateBalance(currentNode->rightChild); } } } int updateBalance(TreeNode *node){ if (node->balanceFactor > 1 || node->balanceFactor < -1){ this->rebalance(node); return 0; } if (node->parent != NULL){ if (node->isLeftChild()){ node->parent->balanceFactor += 1; } else if (node->isRightChild()){ node->parent->balanceFactor -= 1; } if (node->parent->balanceFactor != 0){ this->updateBalance(node->parent); } } return 0; }   The new updateBalance method is where most of the work is done. The updateBalance method first checks to see if the current node is out of balance enough to require rebalancing (line 23). If that is the case then the rebalancing is done and no further updating to parents is required. If the current node does not require rebalancing then the balance factor of the parent is adjusted. If the balance factor of the parent is non-zero then the algorithm continues to work its way up the tree toward the root by recursively calling updateBalance on the parent.  When a rebalancing of the tree is necessary, how do we do it? Efficient rebalancing is the key to making the AVL Tree work well without sacrificing performance. In order to bring an AVL Tree back into balance we will perform one or more rotations on the tree.  To understand what a rotation is let us look at a very simple example. Consider the tree in the left half of . This tree is out of balance with a balance factor of -2. To bring this tree into balance we will use a left rotation around the subtree rooted at node A.   Transforming an Unbalanced Tree Using a Left Rotation.    To perform a left rotation we essentially do the following:    Promote the right child (B) to be the root of the subtree.    Move the old root (A) to be the left child of the new root.    If new root (B) already had a left child then make it the right child of the new left child (A). Note: Since the new root (B) was the right child of A the right child of A is guaranteed to be empty at this point. This allows us to add a new node as the right child without any further consideration.    While this procedure is fairly easy in concept, the details of the code are a bit tricky since we need to move things around in just the right order so that all properties of a Binary Search Tree are preserved. Furthermore we need to make sure to update all of the parent pointers appropriately.  Let's look at a slightly more complicated tree to illustrate the right rotation. The left side of shows a tree that is left-heavy and with a balance factor of 2 at the root. To perform a right rotation we essentially do the following:    Promote the left child (C) to be the root of the subtree.    Move the old root (E) to be the right child of the new root.    If the new root(C) already had a right child (D) then make it the left child of the new right child (E). Note: Since the new root (C) was the left child of E, the left child of E is guaranteed to be empty at this point. This allows us to add a new node as the left child without any further consideration.     Transforming an Unbalanced Tree Using a Right Rotation.    Now that you have seen the rotations and have the basic idea of how a rotation works let us look at the code. shows the code for both the right and the left rotations. In line 2 we create a temporary variable to keep track of the new root of the subtree. As we said before the new root is the right child of the previous root. Now that a reference to the right child has been stored in this temporary variable we replace the right child of the old root with the left child of the new.  The next step is to adjust the parent pointers of the two nodes. If newRoot has a left child then the new parent of the left child becomes the old root. The parent of the new root is set to the parent of the old root. If the old root was the root of the entire tree then we must set the root of the tree to point to this new root. Otherwise, if the old root is a left child then we change the parent of the left child to point to the new root; otherwise we change the parent of the right child to point to the new root. (lines 11-18). Finally we set the parent of the old root to be the new root. This is a lot of complicated bookkeeping, so we encourage you to trace through this function while looking at . The rotateRight method is symmetrical to rotateLeft so we will leave it to you to study the code for rotateRight .   Implementation of rotateLeft and rotateRight  void rotateLeft(TreeNode *rotRoot){ TreeNode *newRoot = rotRoot->rightChild; rotRoot->rightChild = newRoot->leftChild; if (newRoot->leftChild != NULL){ newRoot->leftChild->parent = rotRoot; } newRoot->parent = rotRoot->parent; if (rotRoot->isRoot()){ this->root = newRoot; } else{ if (rotRoot->isLeftChild()){ rotRoot->parent->leftChild = newRoot; } else{ rotRoot->parent->rightChild = newRoot; } } newRoot->leftChild = rotRoot; rotRoot->parent = newRoot; rotRoot->balanceFactor = rotRoot->balanceFactor + 1 - min(newRoot->balanceFactor, 0); newRoot->balanceFactor = newRoot->balanceFactor + 1 + max(rotRoot->balanceFactor, 0); }   Finally, lines 21-22 require some explanation. In these two lines we update the balance factors of the old and the new root. Since all the other moves are moving entire subtrees around the balance factors of all other nodes are unaffected by the rotation. But how can we update the balance factors without completely recalculating the heights of the new subtrees? The following derivation should convince you that these lines are correct.   A Left Rotation.    shows a left rotation. B and D are the pivotal nodes and A, C, E are their subtrees. Let denote the height of a particular subtree rooted at node . By definition we know the following:   But we know that the old height of D can also be given by , that is, the height of D is one more than the maximum height of its two children. Remember that and hav not changed. So, let us substitute that in to the second equation, which gives us   and then subtract the two equations. The following steps do the subtraction and use some algebra to simplify the equation for .   Next we will move to the right hand side of the equation and make use of the fact that .   But, is the same as . So we can use another identity that says . So we can finish our derivation of with the following steps:   Now we have all of the parts in terms that we readily know. If we remember that B is rotRoot and D is newRoot then we can see this corresponds exactly to the statement on line 21, or:  rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor)  A similar derivation gives us the equation for the updated node D, as well as the balance factors after a right rotation. We leave these as exercises for you.  Now you might think that we are done. We know how to do our left and right rotations, and we know when we should do a left or right rotation, but take a look at . Since node A has a balance factor of -2 we should do a left rotation. But, what happens when we do the left rotation around A?   An Unbalanced Tree that is More Difficult to Balance.    shows us that after the left rotation we are now out of balance the other way. If we do a right rotation to correct the situation we are right back where we started.   After a Left Rotation the Tree is Out of Balance in the Other Direction.    To correct this problem we must use the following set of rules:    If a subtree needs a left rotation to bring it into balance, first check the balance factor of the right child. If the right child is left heavy then do a right rotation on right child, followed by the original left rotation.    If a subtree needs a right rotation to bring it into balance, first check the balance factor of the left child. If the left child is right heavy then do a left rotation on the left child, followed by the original right rotation.    shows how these rules solve the dilemma we encountered in and . Starting with a right rotation around node C puts the tree in a position where the left rotation around A brings the entire subtree back into balance.   A Right Rotation Followed by a Left Rotation.    The code that implements these rules can be found in our rebalance method, which is shown in . Rule number 1 from above is implemented by the if statement starting on line 2. Rule number 2 is implemented by the else if statement starting on line 11.   Implementation of rebalance  void rebalance(TreeNode *node){ if (node->balanceFactor < 0){ if (node->rightChild->balanceFactor > 0){ this->rotateRight(node->rightChild); this->rotateLeft(node); } else{ this->rotateLeft(node); } } else if (node->balanceFactor > 0){ if (node->leftChild->balanceFactor < 0){ this->rotateLeft(node->leftChild); this->rotateRight(node); } else { this->rotateRight(node); } } }   The discussion questions provide you the opportunity to rebalance a tree that requires a left rotation followed by a right. In addition the discussion questions provide you with the opportunity to rebalance some trees that are a little more complex than the tree in .  By keeping the tree in balance at all times, we can ensure that the get method will run in order time. But the question is at what cost to our put method? Let us break this down into the operations performed by put . Since a new node is inserted as a leaf, updating the balance factors of all the parents will require a maximum of operations, one for each level of the tree. If a subtree is found to be out of balance a maximum of two rotations are required to bring the tree back into balance. But, each of the rotations works in time, so even our put operation remains .  At this point we have implemented a functional AVL-Tree, unless you need the ability to delete a node. We leave the deletion of the node and subsequent updating and rebalancing as an exercise for you.   Reading Question   How does adding a new leaf in an AVL Tree affect the parent's balance factor?     A left leaf reduces the balance factor by 1    Carefully think about what you read in AVL performance      A right leaf reduces the balance factor by 2    Carefully think about what you read in AVL performance      A left leaf increases the balance factor by 1 and the right leaf reduces the balance factor by 1 and does not affect the grandparent's balance factor    Carefully think about what you read in AVL performance      A left leaf increases the balance factor by 1 and the right leaf reduces the balance factor by 1 of the parent    Correct!      The leaves do not affect the parent's balance factor, only the ancestor nodes    Carefully think about what you read in AVL performance      "
},
{
  "id": "trees_lst-updbal",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#trees_lst-updbal",
  "type": "Listing",
  "number": "8.17.1",
  "title": "",
  "body": " Implementation of _put and updateBalance  void _put(int key, string val, TreeNode *currentNode){ if (key < currentNode->key){ if (currentNode->hasLeftChild()){ this->_put(key, val, currentNode->leftChild); } else{ currentNode->leftChild = new TreeNode(key, val, currentNode); this->updateBalance(currentNode->leftChild); } } else{ if (currentNode->hasRightChild()){ this->_put(key, val, currentNode->rightChild); } else{ currentNode->rightChild = new TreeNode(key, val, currentNode); this->updateBalance(currentNode->rightChild); } } } int updateBalance(TreeNode *node){ if (node->balanceFactor > 1 || node->balanceFactor < -1){ this->rebalance(node); return 0; } if (node->parent != NULL){ if (node->isLeftChild()){ node->parent->balanceFactor += 1; } else if (node->isRightChild()){ node->parent->balanceFactor -= 1; } if (node->parent->balanceFactor != 0){ this->updateBalance(node->parent); } } return 0; }  "
},
{
  "id": "trees_avl-tree-implementation-7",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#trees_avl-tree-implementation-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "rotations "
},
{
  "id": "fig-unbalsimple",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#fig-unbalsimple",
  "type": "Figure",
  "number": "8.17.2",
  "title": "",
  "body": " Transforming an Unbalanced Tree Using a Left Rotation.   "
},
{
  "id": "fig-rightrot1",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#fig-rightrot1",
  "type": "Figure",
  "number": "8.17.3",
  "title": "",
  "body": " Transforming an Unbalanced Tree Using a Right Rotation.   "
},
{
  "id": "trees_lst-bothrotations",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#trees_lst-bothrotations",
  "type": "Listing",
  "number": "8.17.4",
  "title": "",
  "body": " Implementation of rotateLeft and rotateRight  void rotateLeft(TreeNode *rotRoot){ TreeNode *newRoot = rotRoot->rightChild; rotRoot->rightChild = newRoot->leftChild; if (newRoot->leftChild != NULL){ newRoot->leftChild->parent = rotRoot; } newRoot->parent = rotRoot->parent; if (rotRoot->isRoot()){ this->root = newRoot; } else{ if (rotRoot->isLeftChild()){ rotRoot->parent->leftChild = newRoot; } else{ rotRoot->parent->rightChild = newRoot; } } newRoot->leftChild = rotRoot; rotRoot->parent = newRoot; rotRoot->balanceFactor = rotRoot->balanceFactor + 1 - min(newRoot->balanceFactor, 0); newRoot->balanceFactor = newRoot->balanceFactor + 1 + max(rotRoot->balanceFactor, 0); }  "
},
{
  "id": "trees-avl-fig-bfderive",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#trees-avl-fig-bfderive",
  "type": "Figure",
  "number": "8.17.5",
  "title": "",
  "body": " A Left Rotation.   "
},
{
  "id": "avlimpl_fig-hardrotate",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#avlimpl_fig-hardrotate",
  "type": "Figure",
  "number": "8.17.6",
  "title": "",
  "body": " An Unbalanced Tree that is More Difficult to Balance.   "
},
{
  "id": "avlimpl_fig-badrotate",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#avlimpl_fig-badrotate",
  "type": "Figure",
  "number": "8.17.7",
  "title": "",
  "body": " After a Left Rotation the Tree is Out of Balance in the Other Direction.   "
},
{
  "id": "avlimpl_fig-rotatelr",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#avlimpl_fig-rotatelr",
  "type": "Figure",
  "number": "8.17.8",
  "title": "",
  "body": " A Right Rotation Followed by a Left Rotation.   "
},
{
  "id": "avlimpl_lst-rebalance",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#avlimpl_lst-rebalance",
  "type": "Listing",
  "number": "8.17.9",
  "title": "",
  "body": " Implementation of rebalance  void rebalance(TreeNode *node){ if (node->balanceFactor < 0){ if (node->rightChild->balanceFactor > 0){ this->rotateRight(node->rightChild); this->rotateLeft(node); } else{ this->rotateLeft(node); } } else if (node->balanceFactor > 0){ if (node->leftChild->balanceFactor < 0){ this->rotateLeft(node->leftChild); this->rotateRight(node); } else { this->rotateRight(node); } } }  "
},
{
  "id": "AVLbalancetree",
  "level": "2",
  "url": "trees_avl-tree-implementation.html#AVLbalancetree",
  "type": "Reading Question",
  "number": "8.17.1",
  "title": "",
  "body": " How does adding a new leaf in an AVL Tree affect the parent's balance factor?     A left leaf reduces the balance factor by 1    Carefully think about what you read in AVL performance      A right leaf reduces the balance factor by 2    Carefully think about what you read in AVL performance      A left leaf increases the balance factor by 1 and the right leaf reduces the balance factor by 1 and does not affect the grandparent's balance factor    Carefully think about what you read in AVL performance      A left leaf increases the balance factor by 1 and the right leaf reduces the balance factor by 1 of the parent    Correct!      The leaves do not affect the parent's balance factor, only the ancestor nodes    Carefully think about what you read in AVL performance    "
},
{
  "id": "trees_summary-of-map-adt-implementations",
  "level": "1",
  "url": "trees_summary-of-map-adt-implementations.html",
  "type": "Section",
  "number": "8.18",
  "title": "Summary of Map ADT Implementations",
  "body": " Summary of Map ADT Implementations  Over the past two chapters we have looked at several data structures that can be used to implement the map abstract data type. A binary Search on a list, a hash table, a binary search tree, and a balanced binary search tree. To conclude this section, let's summarize the performance of each data structure for the key operations defined by the map ADT (see ).   Comparing the Performance of Different Map Implementations   operation  Sorted Array  Hash Table  Binary Search Tree  AVL Tree    put                get                in                del                "
},
{
  "id": "trees_tab-compare",
  "level": "2",
  "url": "trees_summary-of-map-adt-implementations.html#trees_tab-compare",
  "type": "Table",
  "number": "8.18.1",
  "title": "",
  "body": " Comparing the Performance of Different Map Implementations   operation  Sorted Array  Hash Table  Binary Search Tree  AVL Tree    put                get                in                del               "
},
{
  "id": "trees_summary",
  "level": "1",
  "url": "trees_summary.html",
  "type": "Section",
  "number": "8.19",
  "title": "Summary",
  "body": " Summary  In this chapter we have looked at the tree data structure. The tree data structure enables us to write many interesting algorithms. In this chapter we have looked at algorithms that use trees to do the following:    A binary tree for parsing and evaluating expressions.    A balanced binary tree (AVL tree).    A binary tree to implement a min heap.    A min heap used to implement a priority queue.    "
},
{
  "id": "trees_discussion-questions",
  "level": "1",
  "url": "trees_discussion-questions.html",
  "type": "Section",
  "number": "8.20",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Draw the tree structure resulting from the following set of tree function calls:  >>> r = BinaryTree(3) >>> insertLeft(r,4) [3, [4, [], []], []] >>> insertLeft(r,5) [3, [5, [4, [], []], []], []] >>> insertRight(r,6) [3, [5, [4, [], []], []], [6, [], []]] >>> insertRight(r,7) [3, [5, [4, [], []], []], [7, [], [6, [], []]]] >>> setRootVal(r,9) >>> insertLeft(r,11) [9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]]    Trace the algorithm for creating an expression tree for the expression .    Consider the following array of integers: [1,2,3,4,5,6,7,8,9,10]. Show the binary search tree resulting from inserting the integers in the array.    Consider the following array of integers: [10,9,8,7,6,5,4,3,2,1]. Show the binary search tree resulting from inserting the integers in the array.    Generate a random array of integers. Show the binary heap tree resulting from inserting the integers on the array one at a time.    Using the array from the previous question, show the binary heap tree resulting from using the array as a parameter to the buildHeap method. Show both the tree and array form.    Draw the binary search tree that results from inserting the following keys in the order given: 68,88,61,89,94,50,4,76,66, and 82.    Generate a random array of integers. Draw the binary search tree resulting from inserting the integers on the array.    Consider the following array of integers: [1,2,3,4,5,6,7,8,9,10]. Show the binary heap resulting from inserting the integers one at a time.    Consider the following array of integers: [10,9,8,7,6,5,4,3,2,1]. Show the binary heap resulting from inserting the integers one at a time.    Consider the two different techniques we used for implementing traversals of a binary tree. Why must we check before the call to preorder when implementing as a method, whereas we could check inside the call when implementing as a function?    Show the function calls needed to build the binary tree in .   Tree of Programming Languages   A tree whose root node is language. The language node has two children: compiled and interpreted. The compiled node has two children: C and Java. The interpreted node has two children: Python and Scheme.      Given the tree in , perform the appropriate rotations to bring it back into balance.   Out of Balance Tree   A tree whose root node is B with a balance factor of -2. B has two children: A with a balance factor of 0 and E with a balanace factor of 1. A has no children. E has two children: D with a balance factor of 1 and F with a balance factor of 0. D has only a left child: C with balance factor 0. F has no children.      Using as a starting point, derive the equation that gives the updated balance factor for node D.   Compute Updated Balance Factor      "
},
{
  "id": "exertree",
  "level": "2",
  "url": "trees_discussion-questions.html#exertree",
  "type": "Figure",
  "number": "8.20.1",
  "title": "",
  "body": " Tree of Programming Languages   A tree whose root node is language. The language node has two children: compiled and interpreted. The compiled node has two children: C and Java. The interpreted node has two children: Python and Scheme.   "
},
{
  "id": "rotexer1",
  "level": "2",
  "url": "trees_discussion-questions.html#rotexer1",
  "type": "Figure",
  "number": "8.20.2",
  "title": "",
  "body": " Out of Balance Tree   A tree whose root node is B with a balance factor of -2. B has two children: A with a balance factor of 0 and E with a balanace factor of 1. A has no children. E has two children: D with a balance factor of 1 and F with a balance factor of 0. D has only a left child: C with balance factor 0. F has no children.   "
},
{
  "id": "bfderive",
  "level": "2",
  "url": "trees_discussion-questions.html#bfderive",
  "type": "Figure",
  "number": "8.20.3",
  "title": "",
  "body": " Compute Updated Balance Factor   "
},
{
  "id": "trees_programming-exercises",
  "level": "1",
  "url": "trees_programming-exercises.html",
  "type": "Section",
  "number": "8.21",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Extend the buildParseTree function to handle mathematical expressions that do not have spaces between every character.    Modify the buildParseTree and evaluate functions to handle boolean statements (and, or, and not). Remember that not is a unary operator, so this will complicate your code somewhat.    Using the findSuccessor method, write a non-recursive inorder traversal for a binary search tree.    Modify the code for a binary search tree to make it threaded. Write a non-recursive inorder traversal method for the threaded binary search tree. A threaded binary tree maintains a reference from each node to its successor.    Modify our implementation of the binary search tree so that it handles duplicate keys properly. That is, if a key is already in the tree then the new payload should replace the old rather than add another node with the same key.    Create a binary heap with a limited heap size. In other words, the heap only keeps track of the n most important items. If the heap grows in size to more than n items the least important item is dropped.    Clean up the printexp function so that it does not include an ‘extra' set of parentheses around each number.    Using the buildHeap method, write a sorting function that can sort a array in time.    Write a function that takes a parse tree for a mathematical expression and calculates the derivative of the expression with respect to some variable.    Implement a binary heap as a max heap.    Using the BinaryHeap class, implement a new class called PriorityQueue . Your PriorityQueue class should implement the constructor, plus the enqueue and dequeue methods.    "
},
{
  "id": "trees_glossary",
  "level": "1",
  "url": "trees_glossary.html",
  "type": "Section",
  "number": "8.22",
  "title": "Glossary",
  "body": " Glossary    AVL tree  a binary search tree that automatically makes sure the tree remains balanced at all times.    balance factor  the difference between the height of the left and right subtrees of a node.    binary heap  a complete binary tree that follows heap ordering rules.    binary search tree  a binary tree in which each node has no more than 2 children; node values in the left sub-tree are less than the parent while node values in the right sub-tree are.    binary tree  a tree with a maximum of two children for each node.    bst propery  property of a binary search key in which the keys that are less than the parent are found in the left subtree and keys that are greater than the parent are found in the right subtree.    children  the nodes that one node leads to.    complete binary tree  a tree in which each level has all of its nodes, with the exception of the bottom level.    edge  connects two nodes in a tree; has only one incoming edge.    heap order property  property of the heap based on min heap or max heap (i.e. in a min heap, every node x with a parent p, the key in p is smaller than or equal to the key in x).    height  the maximum level of any node in the tree.    inorder  recursive tree traversal in which the left subtree is visited, then the root node, followed by the right subtree.    leaf node  a node that has no children.    level  the number of edges on the path from the root to the current node.    max heap  a binary heap in which the largest key is always at the front.    min heap  a binary heap in which the smallest key is always at the front.    node  part of the tree that holds information.    parent  a node that leads to other nodes.    path  an ordered list of nodes connected by edges.    postorder  recursive tree traversal in which the left subtree is visited, then the right, followed by the root node.    preorder  recursive tree traversal in which the root node is visited, then the left, followed by the right subtree.    priority queue  a queue whose elements have a priority that determines their order.    root  the starting point of the tree; has no incoming edges.    rotation  rotating the parent and children nodes in a subtree to reorganize their hierarchy.    sibling  children of the same parent node.    subtree  a section of a tree.    successor  a node that can replace another node while preserving the binary search tree relationships; the next-largest key in the tree.    tree  a hierarchal data structure with a root, branches, and leaves.    "
},
{
  "id": "trees_trees_matching",
  "level": "1",
  "url": "trees_trees_matching.html",
  "type": "Section",
  "number": "8.23",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition (Note not all words in the glossary are here)   Look at your glossary    tree  Hierarchal data structure with a root, branches, and leaves.    rotation  Pivoting the parent and children nodes in a subtree to reorganize their hierarchy    preorder  Recursive tree traversal in which the root node is visited, then the left, followed by the right subtree    postorder  Recursive tree traversal in which the left subtree is visited, then the right, followed by the root node    inorder  Recursive tree traversal in which the left subtree is visited, then the root node, followed by the right subtree    successor  Replaces another node while preserving the binary search tree relationships; the next-largest key in the tree    subtree  Section of a tree    complete binary tree  Tree in which each level has all of its nodes, with the exception of the bottom level    level  Number of edges on the path from the root to the current node    height  Maximum level of any node in the tree    AVL tree  Binary search tree that automatically makes sure the tree remains balanced at all times    binary search tree  Binary tree in which each node has no more than 2 children.    bst propery  Node values in the left sub-tree are less than the parent while node values in the right sub-tree are are greater than the parent    Leaf node  Node that has no children    root  Starting point of the tree    path  Ordered list of nodes connected by edges    parent  Node that leads to other nodes    max heap  Largest key is always at the front    "
},
{
  "id": "matching_trees",
  "level": "2",
  "url": "trees_trees_matching.html#matching_trees",
  "type": "Checkpoint",
  "number": "8.23.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition (Note not all words in the glossary are here)   Look at your glossary    tree  Hierarchal data structure with a root, branches, and leaves.    rotation  Pivoting the parent and children nodes in a subtree to reorganize their hierarchy    preorder  Recursive tree traversal in which the root node is visited, then the left, followed by the right subtree    postorder  Recursive tree traversal in which the left subtree is visited, then the right, followed by the root node    inorder  Recursive tree traversal in which the left subtree is visited, then the root node, followed by the right subtree    successor  Replaces another node while preserving the binary search tree relationships; the next-largest key in the tree    subtree  Section of a tree    complete binary tree  Tree in which each level has all of its nodes, with the exception of the bottom level    level  Number of edges on the path from the root to the current node    height  Maximum level of any node in the tree    AVL tree  Binary search tree that automatically makes sure the tree remains balanced at all times    binary search tree  Binary tree in which each node has no more than 2 children.    bst propery  Node values in the left sub-tree are less than the parent while node values in the right sub-tree are are greater than the parent    Leaf node  Node that has no children    root  Starting point of the tree    path  Ordered list of nodes connected by edges    parent  Node that leads to other nodes    max heap  Largest key is always at the front   "
},
{
  "id": "graphs_objectives",
  "level": "1",
  "url": "graphs_objectives.html",
  "type": "Section",
  "number": "9.1",
  "title": "Objectives",
  "body": " Objectives    To learn what a graph is and how it is used.    To implement the graph abstract data type using multiple internal representations.    To see how graphs can be used to solve a wide variety of problems.    In this chapter we will study graphs. Graphs are a more general structure than the trees we studied in the last chapter; in fact you can think of a tree as a special kind of graph. Graphs can be used to represent many interesting things about our world, including systems of roads, airline flights from city to city, how the Internet is connected, or even the sequence of classes you must take to complete a major in computer science. We will see in this chapter that once we have a good representation for a problem, we can use some standard graph algorithms to solve what otherwise might seem to be a very difficult problem.  While it is relatively easy for humans to look at a road map and understand the relationships between different places, a computer has no such knowledge. However, we can also think of a road map as a graph. When we do so we can have our computer do interesting things for us. If you have ever used one of the Internet map sites, you know that a computer can find the shortest, quickest, or easiest path from one place to another.  As a student of computer science you may wonder about the courses you must take in order to get a major. A graph is a good way to represent the prerequisites and other interdependencies among courses. shows another graph. This one represents the courses and the order in which they must be taken to complete a major in computer science at Luther College.   Prerequisites for a Computer Science Major.   Flowchart outlining the prerequisites for a Computer Science major. The chart begins with 'Math-151' leading into 'CS-220'. Below this, 'CS-150' points to 'CS-151', which in turn branches into 'CS-250' and 'CS-230'. 'CS-230' continues to 'CS-466', and 'CS-151' also points to 'CS-360', which then leads to 'CS-490'. Additionally, 'CS-360' branches off to 'CS-477'. Each course is represented as a node, and the arrows indicate the prerequisite relationship, where one course must be completed before moving on to the next.    "
},
{
  "id": "graphs_objectives-2",
  "level": "2",
  "url": "graphs_objectives.html#graphs_objectives-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "graph "
},
{
  "id": "graphs_fig1",
  "level": "2",
  "url": "graphs_objectives.html#graphs_fig1",
  "type": "Figure",
  "number": "9.1.1",
  "title": "",
  "body": " Prerequisites for a Computer Science Major.   Flowchart outlining the prerequisites for a Computer Science major. The chart begins with 'Math-151' leading into 'CS-220'. Below this, 'CS-150' points to 'CS-151', which in turn branches into 'CS-250' and 'CS-230'. 'CS-230' continues to 'CS-466', and 'CS-151' also points to 'CS-360', which then leads to 'CS-490'. Additionally, 'CS-360' branches off to 'CS-477'. Each course is represented as a node, and the arrows indicate the prerequisite relationship, where one course must be completed before moving on to the next.   "
},
{
  "id": "graphs_vocabulary-and-definitions",
  "level": "1",
  "url": "graphs_vocabulary-and-definitions.html",
  "type": "Section",
  "number": "9.2",
  "title": "Vocabulary and Definitions",
  "body": " Vocabulary and Definitions  Now that we have looked at some examples of graphs, we will more formally define a graph and its components. We already know some of these terms from our discussion of trees.    Vertex  Graph Components vertex  A vertex (also called a node ) is a fundamental part of a graph. It can have a name, which we will call the key. A vertex may also have additional information. We will call this additional information the payload.    Edge  Graph Components edge  Graph Components directed graph  Graph Components digraph  An edge (also called an arc ) is another fundamental part of a graph. An edge connects two vertices to show that there is a relationship between them. Edges may be one-way or two-way. If the edges in a graph are all one-way, we say that the graph is a directed graph , or a digraph . The class prerequisites graph shown above is clearly a digraph since you must take some classes before others.    Weight  Graph Components weight  Edges may be weighted to show that there is a cost to go from one vertex to another. For example in a graph of roads that connect one city to another, the weight on the edge might represent the distance between the two cities.    With those definitions in hand we can formally define a graph. A graph can be represented by where . For the graph , is a set of vertices and is a set of edges. Each edge is a tuple where . We can add a third component to the edge tuple to represent a weight. A subgraph is a set of edges and vertices such that and .  shows another example of a simple weighted digraph. Formally we can represent this graph as the set of six vertices:   and the set of nine edges:    A Simple Example of a Directed Graph.   Diagram representing a simple directed graph with vertices labeled V0 to V5. Arrows indicating direction connect the vertices, with weights on each edge. V0 connects to V4 and V1 with weights 1 and 5, respectively. V1 is connected from V0 and to V5 with weights 5 and 4, respectively. V2 connects from V3 and V5 with weights 9 and 1, respectively. V3 connects to V2 and V5 with weights 9 and 3, respectively, and also to V4 with a weight of 7. V4 connects from V0 and V5 with weights 1 and 8, respectively, and to V3 with a weight of 7. V5, at the center, has incoming edges from V1, V3, and V4 with weights 4, 3, and 8, respectively, and outgoing edges to V2 with a weight of 1.    The example graph in helps illustrate two other key graph terms:    Path  Graph Components path  A path in a graph is a sequence of vertices that are connected by edges. Formally we would define a path as such that for all . The unweighted path length is the number of edges in the path, specifically . The weighted path length is the sum of the weights of all the edges in the path. For example in the path from to is the sequence of vertices . The edges are .    Cycle  Graph Components cycle  Graph Components acyclic graph  Graph Components directed acyclic graph  Graph Components DAG  A cycle in a directed graph is a path that starts and ends at the same vertex. For example, in the path is a cycle. A graph with no cycles is called an acyclic graph . A directed graph with no cycles is called a directed acyclic graph or a DAG . We will see that we can solve several important problems if the problem can be represented as a DAG.    "
},
{
  "id": "graphs_vocabulary-and-definitions-3-2-5",
  "level": "2",
  "url": "graphs_vocabulary-and-definitions.html#graphs_vocabulary-and-definitions-3-2-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "directed graph digraph "
},
{
  "id": "fig-dgsimple",
  "level": "2",
  "url": "graphs_vocabulary-and-definitions.html#fig-dgsimple",
  "type": "Figure",
  "number": "9.2.1",
  "title": "",
  "body": " A Simple Example of a Directed Graph.   Diagram representing a simple directed graph with vertices labeled V0 to V5. Arrows indicating direction connect the vertices, with weights on each edge. V0 connects to V4 and V1 with weights 1 and 5, respectively. V1 is connected from V0 and to V5 with weights 5 and 4, respectively. V2 connects from V3 and V5 with weights 9 and 1, respectively. V3 connects to V2 and V5 with weights 9 and 3, respectively, and also to V4 with a weight of 7. V4 connects from V0 and V5 with weights 1 and 8, respectively, and to V3 with a weight of 7. V5, at the center, has incoming edges from V1, V3, and V4 with weights 4, 3, and 8, respectively, and outgoing edges to V2 with a weight of 1.   "
},
{
  "id": "graphs_vocabulary-and-definitions-11-2-6",
  "level": "2",
  "url": "graphs_vocabulary-and-definitions.html#graphs_vocabulary-and-definitions-11-2-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "acyclic graph directed acyclic graph DAG "
},
{
  "id": "graphs_the-graph-abstract-data-type",
  "level": "1",
  "url": "graphs_the-graph-abstract-data-type.html",
  "type": "Section",
  "number": "9.3",
  "title": "The Graph Abstract Data Type",
  "body": " The Graph Abstract Data Type  The graph abstract data type (ADT) is defined as follows:    Graph() creates a new, empty graph.    addVertex(vert) adds an instance of Vertex to the graph.    addEdge(fromVert, toVert) Adds a new, directed edge to the graph that connects two vertices.    addEdge(fromVert, toVert, weight) Adds a new, weighted, directed edge to the graph that connects two vertices.    getVertex(vertKey) finds the vertex in the graph named vertKey .    getVertices() returns the list of all vertices in the graph.    in returns True for a statement of the form vertex in graph , if the given vertex is in the graph, False otherwise.    Beginning with the formal definition for a graph there are several ways we can implement the graph ADT in Python. We will see that there are trade-offs in using different representations to implement the ADT described above. There are two well-known implementations of a graph, the adjacency matrix adjacency matrix and the adjacency list adjacency list . We will explain both of these options, and then implement one as a Python class.   Reading Question  Drag and drop each graph abstract data type to its corresponding definition. This is feedback. Graph() creates a new, empty graph.  addVertex(vert) adds an instance of Vertex to the graph.  addEdge(fromVert, toVert) Adds a new, directed edge to the graph that connects two vertices.  Drag and drop each graph abstract data type to its corresponding definition. This is feedback. addEdge(fromVert, toVert, weight) Adds a new, weighted, directed edge to the graph that connects two vertices.  getVertex(vertKey) finds the vertex in the graph named vertKey. getVertices() returns the list of all vertices in the graph. in returns True for a statement of the form vertex in graph, if the given vertex is in the graph, False otherwise.   "
},
{
  "id": "graphs_the-graph-abstract-data-type-4",
  "level": "2",
  "url": "graphs_the-graph-abstract-data-type.html#graphs_the-graph-abstract-data-type-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "adjacency matrix adjacency list "
},
{
  "id": "gadt",
  "level": "2",
  "url": "graphs_the-graph-abstract-data-type.html#gadt",
  "type": "Reading Question",
  "number": "9.3.1",
  "title": "",
  "body": "Drag and drop each graph abstract data type to its corresponding definition. This is feedback. Graph() creates a new, empty graph.  addVertex(vert) adds an instance of Vertex to the graph.  addEdge(fromVert, toVert) Adds a new, directed edge to the graph that connects two vertices. "
},
{
  "id": "gadt1",
  "level": "2",
  "url": "graphs_the-graph-abstract-data-type.html#gadt1",
  "type": "Reading Question",
  "number": "9.3.2",
  "title": "",
  "body": "Drag and drop each graph abstract data type to its corresponding definition. This is feedback. addEdge(fromVert, toVert, weight) Adds a new, weighted, directed edge to the graph that connects two vertices.  getVertex(vertKey) finds the vertex in the graph named vertKey. getVertices() returns the list of all vertices in the graph. in returns True for a statement of the form vertex in graph, if the given vertex is in the graph, False otherwise. "
},
{
  "id": "graphs_an-adjacency-matrix",
  "level": "1",
  "url": "graphs_an-adjacency-matrix.html",
  "type": "Section",
  "number": "9.4",
  "title": "An Adjacency Matrix",
  "body": " An Adjacency Matrix  One of the easiest ways to implement a graph is to use a two-dimensional matrix. In this matrix implementation, each of the rows and columns represent a vertex in the graph. The value that is stored in the cell at the intersection of row and column indicates if there is an edge from vertex to vertex . When two vertices are connected by an edge, we say that they are adjacent adjacent . illustrates the adjacency matrix for the graph in . A value in a cell represents the weight of the edge from vertex to vertex .   An Adjacency Matrix Representation for a Graph.   Image showing an adjacency matrix representation for a graph. The matrix is a square grid labeled from V0 to V5 along both the top row and the left column, representing vertices of the graph. The cells within the matrix are mostly empty, indicating no edge between those vertex pairs, with a few cells filled with numbers indicating the weight of the edge between the vertices. Specifically, V0 has an edge to V1 with a weight of 5. V1 has an edge to V5 with a weight of 4. V2 has an edge to V3 with a weight of 9. V3 has edges to V4 and V5 with weights of 7 and 3, respectively. V4 has an edge to V0 with a weight of 1. V5 has edges to V2 and V4 with weights of 1 and 8, respectively.    The advantage of the adjacency matrix is that it is simple, and for small graphs it is easy to see which nodes are connected to other nodes. However, notice that most of the cells in the matrix are empty. Because most of the cells are empty we say that this matrix is sparse. A matrix is not a very efficient way to store sparse data. In fact, in C++ you must go out of your way to even create a matrix structure like the one in .  The adjacency matrix is a good implementation for a graph when the number of edges is large. But what do we mean by large? How many edges would be needed to fill the matrix? Since there is one row and one column for every vertex in the graph, the number of edges required to fill the matrix is . A matrix is full when every vertex is connected to every other vertex. There are few real problems that approach this sort of connectivity. The problems we will look at in this chapter all involve graphs that are sparsely connected.  "
},
{
  "id": "graphs_an-adjacency-matrix-2",
  "level": "2",
  "url": "graphs_an-adjacency-matrix.html#graphs_an-adjacency-matrix-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "adjacent "
},
{
  "id": "fig-adjmat",
  "level": "2",
  "url": "graphs_an-adjacency-matrix.html#fig-adjmat",
  "type": "Figure",
  "number": "9.4.1",
  "title": "",
  "body": " An Adjacency Matrix Representation for a Graph.   Image showing an adjacency matrix representation for a graph. The matrix is a square grid labeled from V0 to V5 along both the top row and the left column, representing vertices of the graph. The cells within the matrix are mostly empty, indicating no edge between those vertex pairs, with a few cells filled with numbers indicating the weight of the edge between the vertices. Specifically, V0 has an edge to V1 with a weight of 5. V1 has an edge to V5 with a weight of 4. V2 has an edge to V3 with a weight of 9. V3 has edges to V4 and V5 with weights of 7 and 3, respectively. V4 has an edge to V0 with a weight of 1. V5 has edges to V2 and V4 with weights of 1 and 8, respectively.   "
},
{
  "id": "graphs_an-adjacency-list",
  "level": "1",
  "url": "graphs_an-adjacency-list.html",
  "type": "Section",
  "number": "9.5",
  "title": "An Adjacency List",
  "body": " An Adjacency List  A more space-efficient way to implement a sparsely connected graph is to use an adjacency list. In an adjacency list implementation we keep a master list of all the vertices in the Graph object and then each vertex object in the graph maintains a list of the other vertices that it is connected to. In our implementation of the Vertex class we will use a dictionary rather than a list where the dictionary keys are the vertices, and the values are the weights. illustrates the adjacency list representation for the graph in .   Three Types of Logic Gates.   Image displaying an adjacency list representation of a graph. The illustration shows a table labeled 'Graph' with a column 'vertList' containing vertices 'V0' through 'V5'. Next to each vertex is a corresponding vertex object, with 'id' representing the vertex ID and 'adj' listing its adjacent vertices along with the edge weights. For example, 'V0' has an adjacent vertex 'V1' with a weight of 5 and 'V5' with a weight of 2, 'V1' is adjacent to 'V2' with a weight of 4, and so on. The bottom of the table states 'numVertices = 6', indicating the total number of vertices in the graph.    The advantage of the adjacency list implementation is that it allows us to compactly represent a sparse graph. The adjacency list also allows us to easily find all the links that are directly connected to a particular vertex.  "
},
{
  "id": "fig-adjlist",
  "level": "2",
  "url": "graphs_an-adjacency-list.html#fig-adjlist",
  "type": "Figure",
  "number": "9.5.1",
  "title": "",
  "body": " Three Types of Logic Gates.   Image displaying an adjacency list representation of a graph. The illustration shows a table labeled 'Graph' with a column 'vertList' containing vertices 'V0' through 'V5'. Next to each vertex is a corresponding vertex object, with 'id' representing the vertex ID and 'adj' listing its adjacent vertices along with the edge weights. For example, 'V0' has an adjacent vertex 'V1' with a weight of 5 and 'V5' with a weight of 2, 'V1' is adjacent to 'V2' with a weight of 4, and so on. The bottom of the table states 'numVertices = 6', indicating the total number of vertices in the graph.   "
},
{
  "id": "graphs_implementation",
  "level": "1",
  "url": "graphs_implementation.html",
  "type": "Section",
  "number": "9.6",
  "title": "Implementation",
  "body": " Implementation  Using a map, or dictionaries in Python, it is easy to implement the adjacency list. In our implementation of the Graph abstract data type we will create two classes (see and ), Graph , which holds the master list of vertices, and Vertex , which will represent each vertex in the graph.  Each Vertex uses a map to keep track of the vertices to which it is connected, and the weight of each edge. This map is called connectedTo . The listing below shows the code for the Vertex class. The constructor simply initializes the id , which will be an integer, and the connectedTo map. The addNeighbor method is used add a connection from this vertex to another. The getConnections method returns all of the vertices in the adjacency list, as represented by the connectedTo instance variable. The getWeight method returns the weight of the edge from this vertex to the vertex passed as a parameter.  We use operator overloading so that when we print our Vertex using the cout << function we get a list of its connections, instead of an error. This function must be initialized as a friend function within the class definition, but is required to be defined outside of the class. This is specific to operator overloading in C++.  Listing 1  class Vertex { public: int id; map<int, int> connectedTo; Vertex() { } Vertex(int key) { id = key; } void addNeighbor(int nbr, int weight = 0) { connectedTo[nbr] = weight; } vector<int> getConnections() { vector<int> keys; \/\/ Use of iterator to find all keys for (map<int, int>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } int getId() { return id; } int getWeight(int nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<int> connects = vert.getConnections(); for (unsigned int i = 0; i < connects.size(); i++) { stream << \"( \" << vert.id << \" , \" << connects[i] << \" ) \\n\"; } return stream; }   The Graph class, shown in the next listing, contains a map that maps vertex names (int) to vertex objects (Vertex). In this map object is represented by the shaded gray box. Graph also provides methods for adding vertices to a graph and connecting one vertex to another. The getVertices method returns the names of all of the vertices in the graph.  Listing 2  class Graph { public: map<int, Vertex> vertList; int numVertices; Graph() { numVertices = 0; } Vertex addVertex(int key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { \/\/ Forced to use pntr due to possibility of returning NULL Vertex *vpntr = &vertList[n]; return vpntr; } else { return NULL; } } } bool contains(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(int f, int t, int cost = 0) { if (!this->contains(f)) { cout << f << \" was not found, adding!\" << endl; this->addVertex(f); } if (!this->contains(t)) { cout << t << \" was not found, adding!\" << endl; } vertList[f].addNeighbor(t, cost); } vector<int> getVertices() { vector<int> verts; for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &); }; ostream &operator<<(ostream &stream, Graph &grph) { for (unsigned int i = 0; i < grph.vertList.size(); i++) { stream << grph.vertList[i]; } return stream; }   Using the Graph and Vertex classes just defined, the following Python session creates the graph in . First we create six vertices numbered 0 through 5. Then we display the vertex dictionary. Notice that for each key 0 through 5 we have created an instance of a Vertex . Next, we add the edges that connect the vertices together. Finally, a nested loop verifies that each edge in the graph is properly stored. You should check the output of the edge list at the end of this session against .    #include <iostream> #include <map> #include <vector> using namespace std; class Vertex { public: int id; map<int, int> connectedTo; \/\/Empty constructor. Vertex() { } \/\/Constructor that defines the key of the vertex. Vertex(int key) { id = key; } \/\/Adds a neighbor to this vertex with the specified ID and weight. void addNeighbor(int nbr, int weight = 0) { connectedTo[nbr] = weight; } \/\/Returns a vector (e.g, list) of vertices connected to this one. vector<int> getConnections() { vector<int> keys; \/\/ Use of iterator to find all keys for (map<int, int>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } \/\/Returns the ID of this vertex. int getId() { return id; } \/\/Returns the weight of the connection between this vertex and the specified neighbor. int getWeight(int nbr) { return connectedTo[nbr]; } \/\/Output stream overload operator for printing to the screen. friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<int> connects = vert.getConnections(); for (unsigned int i = 0; i < connects.size(); i++) { stream << \"( \" << vert.id << \" , \" << connects[i] << \" ) \\n\"; } return stream; } class Graph { public: map<int, Vertex> vertList; int numVertices; \/\/Empty constructor. Graph() { numVertices = 0; } \/\/Adds the specified vertex and returns a copy of it. Vertex addVertex(int key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } \/\/Returns the vertex with the specified ID. \/\/Will return NULl if the vertex doesn't exist. Vertex *getVertex(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { \/\/ Forced to use pntr due to possibility of returning NULL Vertex *vpntr = &vertList[n]; return vpntr; } else { return NULL; } } } \/\/Returns a boolean indicating if an index with the specified ID exists. bool contains(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } \/\/Adds an edge between vertices F and T with a weight equivalent to cost. void addEdge(int f, int t, int cost = 0) { if (!this->contains(f)) { cout << f << \" was not found, adding!\" << endl; this->addVertex(f); } if (!this->contains(t)) { cout << t << \" was not found, adding!\" << endl; } vertList[f].addNeighbor(t, cost); } \/\/Returns a vector (e.g, list) of all vertices in this graph. vector<int> getVertices() { vector<int> verts; for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } \/\/Overloaded Output stream operator for printing to the screen friend ostream &operator<<(ostream &, Graph &); }; ostream &operator<<(ostream &stream, Graph &grph) { for (unsigned int i = 0; i < grph.vertList.size(); i++) { stream << grph.vertList[i]; } return stream; } int main() { Graph g; for (int i = 0; i < 6; i++) { g.addVertex(i); } g.addEdge(0, 1, 5); g.addEdge(0, 5, 2); g.addEdge(1, 2, 4); g.addEdge(2, 3, 9); g.addEdge(3, 4, 7); g.addEdge(3, 5, 3); g.addEdge(4, 0, 1); g.addEdge(5, 4, 8); g.addEdge(5, 2, 1); cout << g << endl; return 0; }     class Vertex: # Contructor that specifies the key of the vertex. def __init__(self, key): self.id = key self.connectedTo = {} # Adds a neighbor with the specified weight. def addNeighbor(self, nbr, weight=0): self.connectedTo[nbr] = weight # Converts this vertex to a string representation. def __str__(self): return str(self.id) + ' connectedTo: ' + str( [x.id for x in self.connectedTo]) # Returns the list of vertex IDs that are connected to this one. def getConnections(self): return self.connectedTo.keys() # Returns the ID of this vertex. def getId(self): return self.id # Returns the weight of this vertex in relation to the specified neighbor. def getWeight(self, nbr): return self.connectedTo[nbr] class Graph: # Empty constructor. def __init__(self): self.vertList = {} self.numVertices = 0 # Adds a vertex with the specified ID (key) and returns it. def addVertex(self, key): self.numVertices = self.numVertices + 1 newVertex = Vertex(key) self.vertList[key] = newVertex return newVertex # Returns the vertex (or None if nonexistant) with the specified ID n. def getVertex(self, n): if n in self.vertList: return self.vertList[n] else: return None # Returns a boolean indicating if the specified vertex ID is in this graph. def __contains__(self, n): return n in self.vertList # Adds an edge between F and T with a weight of cost. def addEdge(self, f, t, cost=0): if f not in self.vertList: self.addVertex(f) if t not in self.vertList: self.addVertex(t) self.vertList[f].addNeighbor(self.vertList[t], cost) # Returns a list of all vertices in this graph. def getVertices(self): return self.vertList.keys() # Iteration overload (useful in python). def __iter__(self): return iter(self.vertList.values()) def main(): g = Graph() for i in range(6): g.addVertex(i) g.addEdge(0, 1, 5) g.addEdge(0, 5, 2) g.addEdge(1, 2, 4) g.addEdge(2, 3, 9) g.addEdge(3, 4, 7) g.addEdge(3, 5, 3) g.addEdge(4, 0, 1) g.addEdge(5, 4, 8) g.addEdge(5, 2, 1) for v in g: for w in v.getConnections(): print(\"( %s , %s )\" % (v.getId(), w.getId())) main()    "
},
{
  "id": "lst_vertex",
  "level": "2",
  "url": "graphs_implementation.html#lst_vertex",
  "type": "Listing",
  "number": "9.6.1",
  "title": "",
  "body": "Listing 1  class Vertex { public: int id; map<int, int> connectedTo; Vertex() { } Vertex(int key) { id = key; } void addNeighbor(int nbr, int weight = 0) { connectedTo[nbr] = weight; } vector<int> getConnections() { vector<int> keys; \/\/ Use of iterator to find all keys for (map<int, int>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } int getId() { return id; } int getWeight(int nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<int> connects = vert.getConnections(); for (unsigned int i = 0; i < connects.size(); i++) { stream << \"( \" << vert.id << \" , \" << connects[i] << \" ) \\n\"; } return stream; }  "
},
{
  "id": "lst_graph",
  "level": "2",
  "url": "graphs_implementation.html#lst_graph",
  "type": "Listing",
  "number": "9.6.2",
  "title": "",
  "body": "Listing 2  class Graph { public: map<int, Vertex> vertList; int numVertices; Graph() { numVertices = 0; } Vertex addVertex(int key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { \/\/ Forced to use pntr due to possibility of returning NULL Vertex *vpntr = &vertList[n]; return vpntr; } else { return NULL; } } } bool contains(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(int f, int t, int cost = 0) { if (!this->contains(f)) { cout << f << \" was not found, adding!\" << endl; this->addVertex(f); } if (!this->contains(t)) { cout << t << \" was not found, adding!\" << endl; } vertList[f].addNeighbor(t, cost); } vector<int> getVertices() { vector<int> verts; for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &); }; ostream &operator<<(ostream &stream, Graph &grph) { for (unsigned int i = 0; i < grph.vertList.size(); i++) { stream << grph.vertList[i]; } return stream; }  "
},
{
  "id": "graphs_the-word-ladder-problem",
  "level": "1",
  "url": "graphs_the-word-ladder-problem.html",
  "type": "Section",
  "number": "9.7",
  "title": "The Word Ladder Problem",
  "body": " The Word Ladder Problem  To begin our study of graph algorithms let's consider the following puzzle called a word ladder. Transform the word FOOL into the word SAGE . In a word ladder puzzle you must make the change occur gradually by changing one letter at a time. At each step you must transform one word into another word, you are not allowed to transform a word into a non-word. The word ladder puzzle was invented in 1878 by Lewis Carroll, the author of Alice in Wonderland . The following sequence of words shows one possible solution to the problem posed above.  FOOL POOL POLL POLE PALE SALE SAGE  There are many variations of the word ladder puzzle. For example you might be given a particular number of steps in which to accomplish the transformation, or you might need to use a particular word. In this section we are interested in figuring out the smallest number of transformations needed to turn the starting word into the ending word.  Not surprisingly, since this chapter is on graphs, we can solve this problem using a graph algorithm. Here is an outline of where we are going:    Represent the relationships between the words as a graph.    Use the graph algorithm known as breadth first search to find an efficient path from the starting word to the ending word.    "
},
{
  "id": "graphs_building-the-word-ladder-graph",
  "level": "1",
  "url": "graphs_building-the-word-ladder-graph.html",
  "type": "Section",
  "number": "9.8",
  "title": "Building the Word Ladder Graph",
  "body": " Building the Word Ladder Graph  Our first problem is to figure out how to turn a large collection of words into a graph. What we would like is to have an edge from one word to another if the two words are only different by a single letter. If we can create such a graph, then any path from one word to another is a solution to the word ladder puzzle. shows a small graph of some words that solve the FOOL to SAGE word ladder problem. Notice that the graph is an undirected graph and that the edges are unweighted.   A Small Word Ladder Graph.   Image of a word ladder graph showing connections between various words. The words 'fool' and 'sage' are highlighted in boxes, suggesting they are the start and end points. From 'fool', lines connect to 'foil', 'foul', 'cool', and 'pool'. From 'pool', there are connections to 'poll', 'pall', and 'pole', and 'pole' connects to 'pale' which in turn connects to 'page', 'sale', and 'sage'. Other words like 'fail', 'fall', and 'pope' are also connected in the graph. The graph demonstrates how each word can be transformed into another word by changing a single letter at a time.    We could use several different approaches to create the graph we need to solve this problem. Let's start with the assumption that we have a list of words that are all the same length. As a starting point, we can create a vertex in the graph for every word in the list. To figure out how to connect the words, we could compare each word in the list with every other. When we compare we are looking to see how many letters are different. If the two words in question are different by only one letter, we can create an edge between them in the graph. For a small set of words that approach would work fine; however let's suppose we have a list of 5,110 words. Roughly speaking, comparing one word to every other word on the list is an algorithm. For 5,110 words, is more than 26 million comparisons.  We can do much better by using the following approach. Suppose that we have a huge number of buckets, each of them with a four-letter word on the outside, except that one of the letters in the label has been replaced by an underscore. For example, consider , we might have a bucket labeled pop_. As we process each word in our list we compare the word with each bucket, using the ‘_' as a wildcard, so both pope and pops would match pop_. Every time we find a matching bucket, we put our word in that bucket. Once we have all the words in the appropriate buckets we know that all the words in the bucket must be connected.   Word Buckets for Words That are Different by One Letter.   Image illustrating word buckets for a group of words that differ by only one letter. There are four buckets, each labeled with a word pattern. The first bucket 'OPE' includes 'POPE', 'ROPE', 'NOPE', 'HOPE', 'LOPE', 'MOPE', and 'COPE'. The second bucket 'P_PE' contains 'POPE', 'PIPE', and 'PAPE'. The third bucket 'PO_E' lists 'POPE', 'POLE', 'PORE', 'POSE', and 'POKE'. The last bucket 'POP' includes 'POPE' and 'POPS'. Each bucket groups words that can be formed by changing the letter represented by the underscore.    In C++, we can implement the scheme we have just described by using a map. The labels on the buckets we have just described are the keys of our map. The values stored for those keys are a vector of words. Once we have the map built we can create the graph. We start our graph by creating a vertex for each word in the graph. Then we create edges between all the vertices we find for words found under the same key in the map. shows the C++ code required to build the graph.    #include <fstream> #include <iostream> #include <map> #include <string> #include <vector> using namespace std; class Vertex { public: string id; map<string, float> connectedTo; Vertex() { } Vertex(string key) { id = key; } void addNeighbor(string nbr, float weight = 1) { connectedTo[nbr] = weight; } vector<string> getConnections() { vector<string> keys; \/\/ Use of iterator to find all keys for (map<string, float>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } string getId() { return id; } float getWeight(string nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<string> connects = vert.getConnections(); stream << vert.id << \" -> \"; for (unsigned int i = 0; i < connects.size(); i++) { stream << connects[i] << endl << \"\\t\"; } return stream; } class Graph { public: map<string, Vertex> vertList; int numVertices; bool directional; Graph(bool directed = true) { directional = directed; numVertices = 0; } Vertex addVertex(string key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(string n) { for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { \/\/ Forced to use pntr due to possibility of returning NULL Vertex *vpntr = &vertList[n]; return vpntr; } else { return NULL; } } } bool contains(string n) { for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(string f, string t, float cost = 1) { if (!this->contains(f)) { this->addVertex(f); } if (!this->contains(t)) { this->addVertex(t); } vertList[f].addNeighbor(t, cost); if (!directional) { vertList[t].addNeighbor(f, cost); } } vector<string> getVertices() { vector<string> verts; for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &; }; ostream &operator<<(ostream &stream, Graph &grph) { for (map<string, Vertex>::iterator it = grph.vertList.begin(); it != grph.vertList.end(); ++it) { stream << grph.vertList[it->first]; cout<<endl; } return stream; } string getBlank(string str, int index) { string blank = str; blank[index] = '_'; return blank; } Graph buildGraph(vector<string> words) { Graph g(false); map<string, vector<string> > d; \/\/ Go through the words for (unsigned int i = 0; i < words.size(); i++) { \/\/ Go through each letter, making it blank for (unsigned int j = 0; j < words[i].length(); j++) { string bucket = getBlank(words[i], j); \/\/ Add the word to the map at the location of the blank d[bucket].push_back(words[i]); } } for (map<string, vector<string> >::iterator iter = d.begin(); iter != d.end(); ++iter) { for(unsigned int i=0; i<iter->second.size();i++) { for (unsigned int j=0; j<iter->second.size();j++) { if (iter->second[i]!=iter->second[j]) { g.addEdge(iter->second[i],iter->second[j]); } } } } return g; } int main() { \/\/ Vector Initialized with an array string arr[] = {\"fool\",\"cool\",\"pool\",\"poll\",\"pole\",\"pall\",\"fall\",\"fail\",\"foil\",\"foul\",\"pope\",\"pale\",\"sale\",\"sage\",\"page\"}; vector<string> words(arr,arr+(sizeof(arr)\/sizeof(arr[0]))); Graph g = buildGraph(words); cout << g << endl; return 0; }    Since this is our first real-world graph problem, you might be wondering how sparse is the graph? The list of four-letter words we have for this problem is 5,110 words long. If we were to use an adjacency matrix, the matrix would have 5,110 * 5,110 = 26,112,100 cells. The graph constructed by the buildGraph function has exactly 53,286 edges, so the matrix would have only 0.20% of the cells filled! That is a very sparse matrix indeed.  "
},
{
  "id": "fig-wordladder",
  "level": "2",
  "url": "graphs_building-the-word-ladder-graph.html#fig-wordladder",
  "type": "Figure",
  "number": "9.8.1",
  "title": "",
  "body": " A Small Word Ladder Graph.   Image of a word ladder graph showing connections between various words. The words 'fool' and 'sage' are highlighted in boxes, suggesting they are the start and end points. From 'fool', lines connect to 'foil', 'foul', 'cool', and 'pool'. From 'pool', there are connections to 'poll', 'pall', and 'pole', and 'pole' connects to 'pale' which in turn connects to 'page', 'sale', and 'sage'. Other words like 'fail', 'fall', and 'pope' are also connected in the graph. The graph demonstrates how each word can be transformed into another word by changing a single letter at a time.   "
},
{
  "id": "fig-wordbucket",
  "level": "2",
  "url": "graphs_building-the-word-ladder-graph.html#fig-wordbucket",
  "type": "Figure",
  "number": "9.8.2",
  "title": "",
  "body": " Word Buckets for Words That are Different by One Letter.   Image illustrating word buckets for a group of words that differ by only one letter. There are four buckets, each labeled with a word pattern. The first bucket 'OPE' includes 'POPE', 'ROPE', 'NOPE', 'HOPE', 'LOPE', 'MOPE', and 'COPE'. The second bucket 'P_PE' contains 'POPE', 'PIPE', and 'PAPE'. The third bucket 'PO_E' lists 'POPE', 'POLE', 'PORE', 'POSE', and 'POKE'. The last bucket 'POP' includes 'POPE' and 'POPS'. Each bucket groups words that can be formed by changing the letter represented by the underscore.   "
},
{
  "id": "graphs_wordbucket_cpp",
  "level": "2",
  "url": "graphs_building-the-word-ladder-graph.html#graphs_wordbucket_cpp",
  "type": "Listing",
  "number": "9.8.3",
  "title": "",
  "body": "  #include <fstream> #include <iostream> #include <map> #include <string> #include <vector> using namespace std; class Vertex { public: string id; map<string, float> connectedTo; Vertex() { } Vertex(string key) { id = key; } void addNeighbor(string nbr, float weight = 1) { connectedTo[nbr] = weight; } vector<string> getConnections() { vector<string> keys; \/\/ Use of iterator to find all keys for (map<string, float>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } string getId() { return id; } float getWeight(string nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<string> connects = vert.getConnections(); stream << vert.id << \" -> \"; for (unsigned int i = 0; i < connects.size(); i++) { stream << connects[i] << endl << \"\\t\"; } return stream; } class Graph { public: map<string, Vertex> vertList; int numVertices; bool directional; Graph(bool directed = true) { directional = directed; numVertices = 0; } Vertex addVertex(string key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(string n) { for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { \/\/ Forced to use pntr due to possibility of returning NULL Vertex *vpntr = &vertList[n]; return vpntr; } else { return NULL; } } } bool contains(string n) { for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(string f, string t, float cost = 1) { if (!this->contains(f)) { this->addVertex(f); } if (!this->contains(t)) { this->addVertex(t); } vertList[f].addNeighbor(t, cost); if (!directional) { vertList[t].addNeighbor(f, cost); } } vector<string> getVertices() { vector<string> verts; for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &; }; ostream &operator<<(ostream &stream, Graph &grph) { for (map<string, Vertex>::iterator it = grph.vertList.begin(); it != grph.vertList.end(); ++it) { stream << grph.vertList[it->first]; cout<<endl; } return stream; } string getBlank(string str, int index) { string blank = str; blank[index] = '_'; return blank; } Graph buildGraph(vector<string> words) { Graph g(false); map<string, vector<string> > d; \/\/ Go through the words for (unsigned int i = 0; i < words.size(); i++) { \/\/ Go through each letter, making it blank for (unsigned int j = 0; j < words[i].length(); j++) { string bucket = getBlank(words[i], j); \/\/ Add the word to the map at the location of the blank d[bucket].push_back(words[i]); } } for (map<string, vector<string> >::iterator iter = d.begin(); iter != d.end(); ++iter) { for(unsigned int i=0; i<iter->second.size();i++) { for (unsigned int j=0; j<iter->second.size();j++) { if (iter->second[i]!=iter->second[j]) { g.addEdge(iter->second[i],iter->second[j]); } } } } return g; } int main() { \/\/ Vector Initialized with an array string arr[] = {\"fool\",\"cool\",\"pool\",\"poll\",\"pole\",\"pall\",\"fall\",\"fail\",\"foil\",\"foul\",\"pope\",\"pale\",\"sale\",\"sage\",\"page\"}; vector<string> words(arr,arr+(sizeof(arr)\/sizeof(arr[0]))); Graph g = buildGraph(words); cout << g << endl; return 0; }   "
},
{
  "id": "graphs_implementing-breadth-first-search",
  "level": "1",
  "url": "graphs_implementing-breadth-first-search.html",
  "type": "Section",
  "number": "9.9",
  "title": "Implementing Breadth First Search",
  "body": " Implementing Breadth First Search  breadth first search  BFS With the graph constructed we can now turn our attention to the algorithm we will use to find the shortest solution to the word ladder problem. The graph algorithm we are going to use is called the breadth first search algorithm. Breadth first search ( BFS ) is one of the easiest algorithms for searching a graph. It also serves as a prototype for several other important graph algorithms that we will study later.  Given a graph and a starting vertex , a breadth first search proceeds by exploring edges in the graph to find all the vertices in for which there is a path from . The remarkable thing about a breadth first search is that it finds all the vertices that are a distance from before it finds any vertices that are a distance . One good way to visualize what the breadth first search algorithm does is to imagine that it is building a tree, one level of the tree at a time. A breadth first search adds all children of the starting vertex before it begins to discover any of the grandchildren.  To keep track of its progress, BFS colors each of the vertices white, gray, or black. All the vertices are initialized to white when they are constructed. A white vertex is an undiscovered vertex. When a vertex is initially discovered it is colored gray, and when BFS has completely explored a vertex it is colored black. This means that once a vertex is colored black, it has no white vertices adjacent to it. A gray node, on the other hand, may have some white vertices adjacent to it, indicating that there are still additional vertices to explore.  The breadth first search algorithm shown in below uses the adjacency list graph representation we developed earlier. In addition it uses a Queue , a crucial point as we will see, to decide which vertex to explore next.  In addition the BFS algorithm uses an extended version of the Vertex class. This new vertex class adds three new instance variables: distance, predecessor, and color.  BFS begins at the starting vertex s and colors start gray to show that it is currently being explored. Two other values, the distance and the predecessor, are initialized to 0 and NULL respectively for the starting vertex. Finally, start is placed on a Queue . The next step is to begin to systematically explore vertices at the front of the queue. We explore each new node at the front of the queue by iterating over its adjacency list. As each node on the adjacency list is examined its color is checked. If it is white, the vertex is unexplored, and four things happen:    The new, unexplored vertex nbr , is colored gray.    The predecessor of nbr is set to the current node currentVert .    The distance to nbr is set to the distance to currentVert + 1 .    nbr is added to the end of a queue. Adding nbr to the end of the queue effectively schedules this node for further exploration, but not until all the other vertices on the adjacency list of currentVert have been explored.    Listing 2  from pythonds.graphs import Graph, Vertex from pythonds.basic import Queue def bfs(g,start): start.setDistance(0) start.setPred(None) vertQueue = Queue() vertQueue.enqueue(start) while (vertQueue.size() > 0): currentVert = vertQueue.dequeue() for nbr in currentVert.getConnections(): if (nbr.getColor() == 'white'): nbr.setColor('gray') nbr.setDistance(currentVert.getDistance() + 1) nbr.setPred(currentVert) vertQueue.enqueue(nbr) currentVert.setColor('black') Graph bfs(Graph g, Vertex *start) { start->dist = 0; start->pred = NULL; queue<Vertex *> vertQueue; vertQueue.push(start); while (vertQueue.size() > 0) { Vertex *currentVert = vertQueue.front(); vertQueue.pop(); \/\/ For each neighbor of the current vertex for (unsigned int nbr = 0; nbr < currentVert->getConnections().size(); nbr++) { if (g.vertList[currentVert->getConnections()[nbr]].color == 'w') { g.vertList[currentVert->getConnections()[nbr]].color = 'g'; g.vertList[currentVert->getConnections()[nbr]].dist = currentVert->dist + 1; g.vertList[currentVert->getConnections()[nbr]].pred = currentVert; vertQueue.push(&g.vertList[currentVert->getConnections()[nbr]]); } } currentVert->color = 'b'; } return g; }   Let's look at how the bfs function would construct the breadth first tree corresponding to the graph in . Starting from fool we take all nodes that are adjacent to fool and add them to the tree. The adjacent nodes include pool, foil, foul, and cool. Each of these nodes are added to the queue of new nodes to expand. shows the state of the in-progress tree along with the queue after this step.   The First Step in the Breadth First Search.   Image of a graph and a queue representing the first step in the breadth-first search algorithm. The graph has a central node labeled 'fool', with arrows pointing to four connected nodes: 'pool', 'foil', a second 'foul', and 'cool', each marked with the number '1' to indicate a step or level. Below the graph, there's a depiction of a queue with the words 'pool', 'foil', 'foul', and 'cool' enqueued in that order. This illustrates how the algorithm explores the neighbors of the starting node 'fool' and adds them to the queue for further exploration.    In the next step bfs removes the next node (pool) from the front of the queue and repeats the process for all of its adjacent nodes. However, when bfs examines the node cool, it finds that the color of cool has already been changed to gray. This indicates that there is a shorter path to cool and that cool is already on the queue for further expansion. The only new node added to the queue while examining pool is poll. The new state of the tree and queue is shown in .   The Second Step in the Breadth First Search.   Image showing the second step in a breadth-first search algorithm on a word graph. The central node is labeled 'fool', with connections to four adjacent nodes: 'pool', 'foil', 'foul', and 'cool', each marked with a '1' indicating they were reached in the first step of the search. 'Pool' is further connected to a node labeled 'poll', marked with a '2' indicating it is reached in the second step. Below the graph, a queue is shown containing 'foil', 'foul', 'cool', and 'poll', reflecting the order in which they are visited. This demonstrates the process of exploring each node's neighbors and tracking the search progression through levels or layers.    The next vertex on the queue is foil. The only new node that foil can add to the tree is fail. As bfs continues to process the queue, neither of the next two nodes add anything new to the queue or the tree. shows the tree and the queue after expanding all the vertices on the second level of the tree.   Breadth First Search Tree After Completing One Level.   Image of a breadth-first search tree after completing one level. The tree starts at the top with the word 'fool'. Below 'fool', there are four nodes labeled 'pool', 'foil', 'foul', and 'cool', each marked with the number '1'. From 'foil', there is an additional node labeled 'fail', marked with the number '2'. Similarly, 'pool' connects to 'poll', also marked with '2'. The diagram indicates the sequence of words explored from the starting word 'fool' by changing one letter at a time. Below the tree, there is a queue with the words 'pole' and 'pall', representing the next words to be visited in the search.     Final Breadth First Search Tree.   Image showing the final breadth-first search tree. The root of the tree is the word 'fool' with four branches leading to the words 'pool', 'foil', 'foul', and 'cool', each marked with a '1' indicating the first level of connections. 'Pool' connects to 'poll' (level 2), which further connects to 'pole' (level 3), leading to 'pope' (level 4), then to 'page' (level 5), and finally to 'sage' (level 6). Similarly, 'foil' connects to 'fail' (level 2), and 'poll' also connects to 'pall' (level 3), leading to 'pale' (level 4) and 'sale' (level 5). The levels indicate the number of steps taken from the root word to reach each subsequent word by changing one letter at a time. An empty queue box is shown to the side, suggesting that the search has been completed.    You should continue to work through the algorithm on your own so that you are comfortable with how it works. shows the final breadth first search tree after all the vertices in have been expanded. The amazing thing about the breadth first search solution is that we have not only solved the FOOL–SAGE problem we started out with, but we have solved many other problems along the way. We can start at any vertex in the breadth first search tree and follow the predecessor arrows back to the root to find the shortest word ladder from any word back to fool. The function below ( ) shows how to follow the predecessor links to print out the word ladder.  Listing 3  void traverse(Vertex *y) { Vertex *x = y; while (x->pred) { cout << x->id << endl; x = x->pred; } cout << x->id << endl; } traverse(g.getVertex('sage'))   Below is a completed implementation of both the Vertex and Graph classes, along with an implementation for the breadth-first search shown above.  #include <fstream> #include <iostream> #include <map> #include <queue> #include <string> #include <vector> using namespace std; class Vertex { public: string id; map<string, float> connectedTo; \/\/ Added for Breadth-First Algorithm char color; float dist; Vertex *pred; Vertex() { \/\/ w for white, g for grey, b for black color = 'w'; dist = 0; pred = NULL; } Vertex(string key) { id = key; color = 'w'; dist = 0; pred = NULL; } void addNeighbor(string nbr, float weight = 1) { connectedTo[nbr] = weight; } vector<string> getConnections() { vector<string> keys; \/\/ Use of iterator to find all keys for (map<string, float>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } string getId() { return id; } float getWeight(string nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<string> connects = vert.getConnections(); stream << vert.id << \" -> \"; for (unsigned int i = 0; i < connects.size(); i++) { stream << connects[i] << endl << \"\\t\"; } return stream; } class Graph { public: map<string, Vertex> vertList; int numVertices; bool directional; Graph(bool directed = true) { directional = directed; numVertices = 0; } Vertex addVertex(string key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(string n) { return &vertList[n]; } bool contains(string n) { for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(string f, string t, float cost = 1) { if (!this->contains(f)) { this->addVertex(f); } if (!this->contains(t)) { this->addVertex(t); } vertList[f].addNeighbor(t, cost); if (!directional) { vertList[t].addNeighbor(f, cost); } } vector<string> getVertices() { vector<string> verts; for (map<string, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &); }; ostream &operator<<(ostream &stream, Graph &grph) { for (map<string, Vertex>::iterator it = grph.vertList.begin(); it != grph.vertList.end(); ++it) { stream << grph.vertList[it->first]; cout << endl; } return stream; } string getBlank(string str, int index) { string blank = str; blank[index] = '_'; return blank; } Graph buildGraph(vector<string> words) { Graph g(false); map<string, vector<string> > d; \/\/ Go through the words for (unsigned int i = 0; i < words.size(); i++) { \/\/ Go through each letter, making it blank for (unsigned int j = 0; j < words[i].length(); j++) { string bucket = getBlank(words[i], j); \/\/ Add the word to the map at the location of the blank d[bucket].push_back(words[i]); } } for (map<string, vector<string> >::iterator iter = d.begin(); iter != d.end(); ++iter) { for (unsigned int i = 0; i < iter->second.size(); i++) { for (unsigned int j = 0; j < iter->second.size(); j++) { if (iter->second[i] != iter->second[j]) { g.addEdge(iter->second[i], iter->second[j]); } } } } return g; } Graph bfs(Graph g, Vertex *start) { start->dist = 0; start->pred = NULL; queue<Vertex *> vertQueue; vertQueue.push(start); while (vertQueue.size() > 0) { Vertex *currentVert = vertQueue.front(); vertQueue.pop(); for (unsigned int nbr = 0; nbr < currentVert->getConnections().size(); nbr++) { if (g.vertList[currentVert->getConnections()[nbr]].color == 'w') { g.vertList[currentVert->getConnections()[nbr]].color = 'g'; g.vertList[currentVert->getConnections()[nbr]].dist = currentVert->dist + 1; g.vertList[currentVert->getConnections()[nbr]].pred = currentVert; vertQueue.push(&g.vertList[currentVert->getConnections()[nbr]]); } } currentVert->color = 'b'; } return g; } void traverse(Vertex *y) { Vertex *x = y; while (x->pred) { cout << x->id << endl; x = x->pred; } cout << x->id << endl; } int main() { \/\/ Vector Initialized with an array string arr[] = {\"fool\", \"cool\", \"pool\", \"poll\", \"pole\", \"pall\", \"fall\", \"fail\", \"foil\", \"foul\", \"pope\", \"pale\", \"sale\", \"sage\", \"page\"}; vector<string> words(arr, arr + (sizeof(arr) \/ sizeof(arr[0]))); \/\/ Graph g = buildGraph(words); Graph g(false); g = buildGraph(words); g = bfs(g, g.getVertex(\"fool\")); traverse(g.getVertex(\"pall\")); return 0; }  "
},
{
  "id": "graphs_implementing-breadth-first-search-2",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#graphs_implementing-breadth-first-search-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Breadth first search BFS "
},
{
  "id": "graphs_lst-wordbucket2",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#graphs_lst-wordbucket2",
  "type": "Listing",
  "number": "9.9.1",
  "title": "",
  "body": "Listing 2  from pythonds.graphs import Graph, Vertex from pythonds.basic import Queue def bfs(g,start): start.setDistance(0) start.setPred(None) vertQueue = Queue() vertQueue.enqueue(start) while (vertQueue.size() > 0): currentVert = vertQueue.dequeue() for nbr in currentVert.getConnections(): if (nbr.getColor() == 'white'): nbr.setColor('gray') nbr.setDistance(currentVert.getDistance() + 1) nbr.setPred(currentVert) vertQueue.enqueue(nbr) currentVert.setColor('black') Graph bfs(Graph g, Vertex *start) { start->dist = 0; start->pred = NULL; queue<Vertex *> vertQueue; vertQueue.push(start); while (vertQueue.size() > 0) { Vertex *currentVert = vertQueue.front(); vertQueue.pop(); \/\/ For each neighbor of the current vertex for (unsigned int nbr = 0; nbr < currentVert->getConnections().size(); nbr++) { if (g.vertList[currentVert->getConnections()[nbr]].color == 'w') { g.vertList[currentVert->getConnections()[nbr]].color = 'g'; g.vertList[currentVert->getConnections()[nbr]].dist = currentVert->dist + 1; g.vertList[currentVert->getConnections()[nbr]].pred = currentVert; vertQueue.push(&g.vertList[currentVert->getConnections()[nbr]]); } } currentVert->color = 'b'; } return g; }  "
},
{
  "id": "fig-bfs1",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#fig-bfs1",
  "type": "Figure",
  "number": "9.9.2",
  "title": "",
  "body": " The First Step in the Breadth First Search.   Image of a graph and a queue representing the first step in the breadth-first search algorithm. The graph has a central node labeled 'fool', with arrows pointing to four connected nodes: 'pool', 'foil', a second 'foul', and 'cool', each marked with the number '1' to indicate a step or level. Below the graph, there's a depiction of a queue with the words 'pool', 'foil', 'foul', and 'cool' enqueued in that order. This illustrates how the algorithm explores the neighbors of the starting node 'fool' and adds them to the queue for further exploration.   "
},
{
  "id": "fig-bfs2",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#fig-bfs2",
  "type": "Figure",
  "number": "9.9.3",
  "title": "",
  "body": " The Second Step in the Breadth First Search.   Image showing the second step in a breadth-first search algorithm on a word graph. The central node is labeled 'fool', with connections to four adjacent nodes: 'pool', 'foil', 'foul', and 'cool', each marked with a '1' indicating they were reached in the first step of the search. 'Pool' is further connected to a node labeled 'poll', marked with a '2' indicating it is reached in the second step. Below the graph, a queue is shown containing 'foil', 'foul', 'cool', and 'poll', reflecting the order in which they are visited. This demonstrates the process of exploring each node's neighbors and tracking the search progression through levels or layers.   "
},
{
  "id": "fig-bfs3",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#fig-bfs3",
  "type": "Figure",
  "number": "9.9.4",
  "title": "",
  "body": " Breadth First Search Tree After Completing One Level.   Image of a breadth-first search tree after completing one level. The tree starts at the top with the word 'fool'. Below 'fool', there are four nodes labeled 'pool', 'foil', 'foul', and 'cool', each marked with the number '1'. From 'foil', there is an additional node labeled 'fail', marked with the number '2'. Similarly, 'pool' connects to 'poll', also marked with '2'. The diagram indicates the sequence of words explored from the starting word 'fool' by changing one letter at a time. Below the tree, there is a queue with the words 'pole' and 'pall', representing the next words to be visited in the search.   "
},
{
  "id": "fig-bfsDone",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#fig-bfsDone",
  "type": "Figure",
  "number": "9.9.5",
  "title": "",
  "body": " Final Breadth First Search Tree.   Image showing the final breadth-first search tree. The root of the tree is the word 'fool' with four branches leading to the words 'pool', 'foil', 'foul', and 'cool', each marked with a '1' indicating the first level of connections. 'Pool' connects to 'poll' (level 2), which further connects to 'pole' (level 3), leading to 'pope' (level 4), then to 'page' (level 5), and finally to 'sage' (level 6). Similarly, 'foil' connects to 'fail' (level 2), and 'poll' also connects to 'pall' (level 3), leading to 'pale' (level 4) and 'sale' (level 5). The levels indicate the number of steps taken from the root word to reach each subsequent word by changing one letter at a time. An empty queue box is shown to the side, suggesting that the search has been completed.   "
},
{
  "id": "graphs_lst-wordbucket3",
  "level": "2",
  "url": "graphs_implementing-breadth-first-search.html#graphs_lst-wordbucket3",
  "type": "Listing",
  "number": "9.9.6",
  "title": "",
  "body": "Listing 3  void traverse(Vertex *y) { Vertex *x = y; while (x->pred) { cout << x->id << endl; x = x->pred; } cout << x->id << endl; } traverse(g.getVertex('sage'))  "
},
{
  "id": "graphs_breadth-first-search-analysis",
  "level": "1",
  "url": "graphs_breadth-first-search-analysis.html",
  "type": "Section",
  "number": "9.10",
  "title": "Breadth First Search Analysis",
  "body": " Breadth First Search Analysis  Breadth first search algorithm Before we continue with other graph algorithms let us analyze the run time performance of the breadth first search algorithm. The first thing to observe is that the while loop is executed, at most, one time for each vertex in the graph . You can see that this is true because a vertex must be white before it can be examined and added to the queue. This gives us for the while loop. The for loop, which is nested inside the while is executed at most once for each edge in the graph, . The reason is that every vertex is dequeued at most once and we examine an edge from node to node only when node is dequeued. This gives us for the for loop. combining the two loops gives us .  Of course doing the breadth first search is only part of the task. Following the links from the starting node to the goal node is the other part of the task. The worst case for this would be if the graph was a single long chain. In this case traversing through all of the vertices would be . The normal case is going to be some fraction of but we would still write .  Finally, at least for this problem, there is the time required to build the initial graph. We leave the analysis of the buildGraph function as an exercise for you.  "
},
{
  "id": "graphs_the-knights-tour-problem",
  "level": "1",
  "url": "graphs_the-knights-tour-problem.html",
  "type": "Section",
  "number": "9.11",
  "title": "The Knight’s Tour Problem",
  "body": " The Knight's Tour Problem  knight's tour Another classic problem that we can use to illustrate a second common graph algorithm is called the knight's tour. The knight's tour puzzle is played on a chess board with a single chess piece, the knight. The object of the puzzle is to find a sequence of moves that allow the knight to visit every square on the board exactly once. One such sequence is called a tour. The knight's tour puzzle has fascinated chess players, mathematicians and computer scientists alike for many years. The upper bound on the number of possible legal tours for an eight-by-eight chessboard is known to be ; however, there are even more possible dead ends. Clearly this is a problem that requires some real brains, some real computing power, or both.  Although researchers have studied many different algorithms to solve the knight's tour problem, a graph search is one of the easiest to understand and program. Once again we will solve the problem using two main steps:    Represent the legal moves of a knight on a chessboard as a graph.    Use a graph algorithm to find a path of length where every vertex on the graph is visited exactly once.    "
},
{
  "id": "graphs_building-the-knights-tour-graph",
  "level": "1",
  "url": "graphs_building-the-knights-tour-graph.html",
  "type": "Section",
  "number": "9.12",
  "title": "Building the Knight’s Tour Graph",
  "body": " Building the Knight's Tour Graph  To represent the knight's tour problem as a graph we will use the following two ideas: Each square on the chessboard can be represented as a node in the graph. Each legal move by the knight can be represented as an edge in the graph. illustrates the legal moves by a knight and the corresponding edges in a graph.   Legal Moves for a Knight on Square 12, and the Corresponding Graph.   Image depicting the legal moves for a knight on a chessboard and the corresponding graph. On the left, there is a 5x5 section of a chessboard with numbered squares from 1 to 25. The knight is placed on square 12, with its legal moves indicated by gray dots on squares 5, 9, 15, 19, 21, and 23. On the right, a graph illustrates the knight's moves as a network of connected nodes. The central node, labeled '12', represents the knight's position, and it is connected to nodes labeled '5', '9', '15', '19', '21', and '23', which correspond to the potential moves available to the knight from its current position.    To build the full graph for an n-by-n board we can use the C++ function shown in . The knightGraph function makes one pass over the entire board. At each square on the board the knightGraph function calls a helper, genLegalMoves , to create a list of legal moves for that position on the board. All legal moves are then converted into edges in the graph. Another helper function coordToNum converts a location on the board in terms of a row and a column into a linear vertex number similar to the vertex numbers shown in .  Listing 1  Listing 1  Graph knightGraph(int bdSize) { Graph ktGraph(false); for (int row = 0; row < bdSize; row++) { for (int col = 0; col < bdSize; col++) { int nodeId = coordToNum(row, col, bdSize); vector<int> newPositions = genLegalMoves(nodeId, bdSize); for (int i = 0; i < newPositions.size(); i++) { int newId = newPositions[i]; ktGraph.addEdge(nodeId, newId); } } } return ktGraph; }   The genLegalMoves function ( ) takes the position of the knight on the board and generates each of the eight possible moves. The legalCoord helper function ( ) makes sure that a particular move that is generated is still on the board.  Listing 2  Listing 2  int coordToNum(int x, int y, int bdSize) { \/\/ Takes the x y position and returns the id from 0 to (bdSize*2)-1 int id = 0; id += y * bdSize; id += x; return id; } pair<int, int> numToCoord(int id, int bdSize) { int x, y; x = id % bdSize; y = (id - x) \/ bdSize; return make_pair(x, y); } bool legalCoord(int x, int bdSize) { if (x >= 0 && x < bdSize) { return true; } else { return false; } } vector<int> genLegalMoves(int id, int bdSize) { pair<int, int> coords = numToCoord(id, bdSize); int x = coords.first; int y = coords.second; vector<int> newMoves; vector<pair<int, int>> myVec = { {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}, {1, -2}, {1, 2}, {2, -1}, {2, 1}}; for (unsigned int i = 0; i < myVec.size(); i++) { int newX = x + myVec[i].first; int newY = y + myVec[i].second; if (legalCoord(newX, bdSize) && legalCoord(newY, bdSize)) { newMoves.push_back(coordToNum(newX, newY, bdSize)); } } return newMoves; }   shows the complete graph of possible moves on an eight-by-eight board. There are exactly 336 edges in the graph. Notice that the vertices corresponding to the edges of the board have fewer connections (legal moves) than the vertices in the middle of the board. Once again we can see how sparse the graph is. If the graph was fully connected there would be 4,096 edges. Since there are only 336 edges, the adjacency matrix would be only 8.2 percent full.   All Legal Moves for a Knight on an Chessboard.   Complex graph showing all legal moves for a knight on an 8 x 8 chessboard, visualized as a network. The nodes are arranged in a grid pattern, numbered from 0 to 63, corresponding to the squares of a chessboard. The lines connecting the nodes represent the knight's potential moves, with each node being connected to others that a knight could reach in a single move based on the rules of chess. The myriad of crisscrossing lines create an intricate web, illustrating the complexity of the knight's movement possibilities across the entire board.    The full implementation of this is shown below, however the code must be ran in C++11 due to differences in Vector Initialization between C++ versions. In the below code, in the main function, we traverse using our previously created breadth-first search between two locations. In the next chapter, we will implement a different algorithm called a depth first search (DFS) to solve our knight's tour problem.  #include <fstream> #include <iostream> #include <map> #include <queue> #include <string> #include <vector> using namespace std; class Vertex { public: int id; map<int, float> connectedTo; \/\/ Added for Breadth-First Algorithm char color; float dist; Vertex *pred; Vertex() { \/\/ w for white, g for grey, b for black color = 'w'; dist = 0; pred = NULL; } Vertex(int key) { id = key; color = 'w'; dist = 0; pred = NULL; } void addNeighbor(int nbr, float weight = 1) { connectedTo[nbr] = weight; } vector<int> getConnections() { vector<int> keys; \/\/ Use of iterator to find all keys for (map<int, float>::iterator it = connectedTo.begin(); it != connectedTo.end(); ++it) { keys.push_back(it->first); } return keys; } int getId() { return id; } float getWeight(int nbr) { return connectedTo[nbr]; } friend ostream &operator<<(ostream &, Vertex &); }; ostream &operator<<(ostream &stream, Vertex &vert) { vector<int> connects = vert.getConnections(); stream << vert.id << \" -> \"; for (unsigned int i = 0; i < connects.size(); i++) { stream << connects[i] << endl << \"\\t\"; } return stream; } class Graph { public: map<int, Vertex> vertList; int numVertices; bool directional; Graph(bool directed = true) { directional = directed; numVertices = 0; } Vertex addVertex(int key) { numVertices++; Vertex newVertex = Vertex(key); this->vertList[key] = newVertex; return newVertex; } Vertex *getVertex(int n) { return &vertList[n]; } bool contains(int n) { for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { if (it->first == n) { return true; } } return false; } void addEdge(int f, int t, float cost = 1) { if (!this->contains(f)) { this->addVertex(f); } if (!this->contains(t)) { this->addVertex(t); } vertList[f].addNeighbor(t, cost); if (!directional) { vertList[t].addNeighbor(f, cost); } } vector<int> getVertices() { vector<int> verts; for (map<int, Vertex>::iterator it = vertList.begin(); it != vertList.end(); ++it) { verts.push_back(it->first); } return verts; } friend ostream &operator<<(ostream &, Graph &); }; ostream &operator<<(ostream &stream, Graph &grph) { for (map<int, Vertex>::iterator it = grph.vertList.begin(); it != grph.vertList.end(); ++it) { stream << grph.vertList[it->first]; cout << endl; } return stream; } Graph bfs(Graph g, Vertex *start) { start->dist = 0; start->pred = NULL; queue<Vertex *> vertQueue; vertQueue.push(start); while (vertQueue.size() > 0) { Vertex *currentVert = vertQueue.front(); vertQueue.pop(); for (unsigned int nbr = 0; nbr < currentVert->getConnections().size(); nbr++) { if (g.vertList[currentVert->getConnections()[nbr]].color == 'w') { g.vertList[currentVert->getConnections()[nbr]].color = 'g'; g.vertList[currentVert->getConnections()[nbr]].dist = currentVert->dist + 1; g.vertList[currentVert->getConnections()[nbr]].pred = currentVert; vertQueue.push(&g.vertList[currentVert->getConnections()[nbr]]); } } currentVert->color = 'b'; } return g; } void traverse(Vertex *y) { Vertex *x = y; int count = 1; while (x->pred) { cout << x->id << \" to \" << x->pred->id << endl; x = x->pred; count++; } } int coordToNum(int x, int y, int bdSize) { \/\/ Takes the x y position and returns the id from 0 to (bdSize*2)-1 int id = 0; id += y * bdSize; id += x; return id; } pair<int, int> numToCoord(int id, int bdSize) { int x, y; x = id % bdSize; y = (id - x) \/ bdSize; return make_pair(x, y); } bool legalCoord(int x, int bdSize) { if (x >= 0 && x < bdSize) { return true; } else { return false; } } vector<int> genLegalMoves(int id, int bdSize) { pair<int, int> coords = numToCoord(id, bdSize); int x = coords.first; int y = coords.second; vector<int> newMoves; vector<pair<int, int>> myVec = { {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}, {1, -2}, {1, 2}, {2, -1}, {2, 1}}; for (unsigned int i = 0; i < myVec.size(); i++) { int newX = x + myVec[i].first; int newY = y + myVec[i].second; if (legalCoord(newX, bdSize) && legalCoord(newY, bdSize)) { newMoves.push_back(coordToNum(newX, newY, bdSize)); } } return newMoves; } Graph knightGraph(int bdSize) { Graph ktGraph(false); for (int row = 0; row < bdSize; row++) { for (int col = 0; col < bdSize; col++) { int nodeId = coordToNum(row, col, bdSize); vector<int> newPositions = genLegalMoves(nodeId, bdSize); for (int i = 0; i < newPositions.size(); i++) { int newId = newPositions[i]; ktGraph.addEdge(nodeId, newId); } } } return ktGraph; } int main() { Graph kt = knightGraph(8); kt = bfs(kt, kt.getVertex(63)); traverse(kt.getVertex(0)); return 0; }  "
},
{
  "id": "fig-knightmoves",
  "level": "2",
  "url": "graphs_building-the-knights-tour-graph.html#fig-knightmoves",
  "type": "Figure",
  "number": "9.12.1",
  "title": "",
  "body": " Legal Moves for a Knight on Square 12, and the Corresponding Graph.   Image depicting the legal moves for a knight on a chessboard and the corresponding graph. On the left, there is a 5x5 section of a chessboard with numbered squares from 1 to 25. The knight is placed on square 12, with its legal moves indicated by gray dots on squares 5, 9, 15, 19, 21, and 23. On the right, a graph illustrates the knight's moves as a network of connected nodes. The central node, labeled '12', represents the knight's position, and it is connected to nodes labeled '5', '9', '15', '19', '21', and '23', which correspond to the potential moves available to the knight from its current position.   "
},
{
  "id": "graphs_lst-knighttour1",
  "level": "2",
  "url": "graphs_building-the-knights-tour-graph.html#graphs_lst-knighttour1",
  "type": "Listing",
  "number": "9.12.2",
  "title": "",
  "body": "Listing 1  Graph knightGraph(int bdSize) { Graph ktGraph(false); for (int row = 0; row < bdSize; row++) { for (int col = 0; col < bdSize; col++) { int nodeId = coordToNum(row, col, bdSize); vector<int> newPositions = genLegalMoves(nodeId, bdSize); for (int i = 0; i < newPositions.size(); i++) { int newId = newPositions[i]; ktGraph.addEdge(nodeId, newId); } } } return ktGraph; }  "
},
{
  "id": "graphs_lst-knighttour2",
  "level": "2",
  "url": "graphs_building-the-knights-tour-graph.html#graphs_lst-knighttour2",
  "type": "Listing",
  "number": "9.12.3",
  "title": "",
  "body": "Listing 2  int coordToNum(int x, int y, int bdSize) { \/\/ Takes the x y position and returns the id from 0 to (bdSize*2)-1 int id = 0; id += y * bdSize; id += x; return id; } pair<int, int> numToCoord(int id, int bdSize) { int x, y; x = id % bdSize; y = (id - x) \/ bdSize; return make_pair(x, y); } bool legalCoord(int x, int bdSize) { if (x >= 0 && x < bdSize) { return true; } else { return false; } } vector<int> genLegalMoves(int id, int bdSize) { pair<int, int> coords = numToCoord(id, bdSize); int x = coords.first; int y = coords.second; vector<int> newMoves; vector<pair<int, int>> myVec = { {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}, {1, -2}, {1, 2}, {2, -1}, {2, 1}}; for (unsigned int i = 0; i < myVec.size(); i++) { int newX = x + myVec[i].first; int newY = y + myVec[i].second; if (legalCoord(newX, bdSize) && legalCoord(newY, bdSize)) { newMoves.push_back(coordToNum(newX, newY, bdSize)); } } return newMoves; }  "
},
{
  "id": "fig-bigknight",
  "level": "2",
  "url": "graphs_building-the-knights-tour-graph.html#fig-bigknight",
  "type": "Figure",
  "number": "9.12.4",
  "title": "",
  "body": " All Legal Moves for a Knight on an Chessboard.   Complex graph showing all legal moves for a knight on an 8 x 8 chessboard, visualized as a network. The nodes are arranged in a grid pattern, numbered from 0 to 63, corresponding to the squares of a chessboard. The lines connecting the nodes represent the knight's potential moves, with each node being connected to others that a knight could reach in a single move based on the rules of chess. The myriad of crisscrossing lines create an intricate web, illustrating the complexity of the knight's movement possibilities across the entire board.   "
},
{
  "id": "graphs_implementing-knights-tour",
  "level": "1",
  "url": "graphs_implementing-knights-tour.html",
  "type": "Section",
  "number": "9.13",
  "title": "Implementing Knight’s Tour",
  "body": " Implementing Knight's Tour  depth first search DFS The search algorithm we will use to solve the knight's tour problem is called depth first search ( DFS ). Whereas the breadth first search algorithm discussed in the previous section builds a search tree one level at a time, a depth first search creates a search tree by exploring one branch of the tree as deeply as possible. In this section we will look at two algorithms that implement a depth first search. The first algorithm we will look at directly solves the knight's tour problem by explicitly forbidding a node to be visited more than once. The second implementation is more general, but allows nodes to be visited more than once as the tree is constructed. The second version is used in subsequent sections to develop additional graph algorithms.  The depth first exploration of the graph is exactly what we need in order to find a path that has exactly 63 edges. We will see that when the depth first search algorithm finds a dead end (a place in the graph where there are no more moves possible) it backs up the tree to the next deepest vertex that allows it to make a legal move.  The knightTour function takes four parameters: n , the current depth in the search tree; path , a list of vertices visited up to this point; u , the vertex in the graph we wish to explore; and limit the number of nodes in the path. The knightTour function is recursive. When the knightTour function is called, it first checks the base case condition. If we have a path that contains 64 vertices, we return from knightTour with a status of True , indicating that we have found a successful tour. If the path is not long enough we continue to explore one level deeper by choosing a new vertex to explore and calling knightTour recursively for that vertex.  DFS also uses colors to keep track of which vertices in the graph have been visited. Unvisited vertices are colored white, and visited vertices are colored gray. If all neighbors of a particular vertex have been explored and we have not yet reached our goal length of 64 vertices, we have reached a dead end. When we reach a dead end we must backtrack. Backtracking happens when we return from knightTour with a status of False . In the breadth first search we used a queue to keep track of which vertex to visit next. Since depth first search is recursive, we are implicitly using a stack to help us with our backtracking. When we return from a call to knightTour with a status of False , in line 11, we remain inside the while loop and look at the next vertex in nbrList .  Listing 3  from pythonds.graphs import Graph, Vertex def knightTour(n,path,u,limit): u.setColor('gray') path.append(u) if n < limit: nbrList = list(u.getConnections()) i = 0 done = False while i < len(nbrList) and not done: if nbrList[i].getColor() == 'white': done = knightTour(n+1, path, nbrList[i], limit) i = i + 1 if not done: # prepare to backtrack path.pop() u.setColor('white') else: done = True return done  Let's look at a simple example of knightTour in action. You can refer to the figures below to follow the steps of the search. For this example we will assume that the call to the getConnections method on line 6 orders the nodes in alphabetical order. We begin by calling knightTour(0,path,A,6) .  knightTour starts with node A . The nodes adjacent to A are B and D. Since B is before D alphabetically, DFS selects B to expand next as shown in . Exploring B happens when knightTour is called recursively. B is adjacent to C and D, so knightTour elects to explore C next. However, as you can see in node C is a dead end with no adjacent white nodes. At this point we change the color of node C back to white. The call to knightTour returns a value of False . The return from the recursive call effectively backtracks the search to vertex B (see ). The next vertex on the list to explore is vertex D, so knightTour makes a recursive call moving to node D (see ). From vertex D on, knightTour can continue to make recursive calls until we get to node C again (see , , and ). However, this time when we get to node C the test n < limit fails so we know that we have exhausted all the nodes in the graph. At this point we can return True to indicate that we have made a successful tour of the graph. When we return the list, path has the values [A,B,D,E,F,C] , which is the the order we need to traverse the graph to visit each node exactly once.   Start with node A.   Graph with node 'fool' as the central node connected to four adjacent nodes labeled 'pool', 'foil', 'foul', and 'cool', each marked with the number '1'. Below the graph is a visual representation of a queue with the nodes 'pool', 'foil', 'foul', and 'cool' lined up in order.     Explore B.   Graph with nodes A, B, C, D, E, and F, with node B highlighted, indicating exploration from node B to nodes A and E.     Node C is a dead end.   Graph highlighting node C, showing no further connections, indicating that C is a dead end in the search process.     Backtrack to B.   Graph with a backtrack path from node C to node B, illustrating the step of returning to node B to continue the search.     Explore D.   Graph with node D highlighted, indicating the exploration is continuing from node D to nodes A and E.     Explore E.   Graph focusing on node E, with exploration proceeding from node E to nodes B and D.     Explore F.   Graph with node F highlighted, representing the search exploring potential paths from node F to node C.     Finish.   Final graph with all nodes no longer highlighted, representing the completion of the depth-first search process.    shows you what a complete tour around an eight-by-eight board looks like. There are many possible tours; some are symmetric. With some modification you can make circular tours that start and end at the same square.   A Complete Tour of the Board.   Image depicting a graph overlaid on an 8x8 chessboard grid representing a complete Knight's Tour. The nodes, numbered from 0 to 63, correspond to the squares of the chessboard. Lines crisscross the grid, mapping the knight's moves in a sequential path that visits each square exactly once. The complex web of lines indicates the knight's route, creating a Hamiltonian circuit where the start and end points are connected. Captioned 'Figure 11: A Complete Tour of the Board'.     Reading Questions   True\/False: The Knight's Tour Graph contains as many vertices as there are tiles on a chessboard.     True    You are correct!      False    No; remember the implementation of Matrix graphs.     What line denotes the base case of the Knight's Tour function? Remember, the base case is usually the first comparison in the function!  def knightTour(n,path,u,limit): :  u.setColor('gray') :  path.append(u) :  if n < limit: :   nbrList = list(u.getConnections()) :   i = 0 :   done = False :   while i < len(nbrList) and not done: :   if nbrList[i].getColor() == 'white': :   done = knightTour(n+1, path, nbrList[i], limit) :   i = i + 1 :   if not done: # prepare to backtrack :   path.pop() :   u.setColor('white') :  else: :   done = True :  return done :    "
},
{
  "id": "graphs_implementing-knights-tour-2",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#graphs_implementing-knights-tour-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "depth first search DFS "
},
{
  "id": "graphs_implementing-knights-tour-6",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#graphs_implementing-knights-tour-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 3 "
},
{
  "id": "fig-kta",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-kta",
  "type": "Figure",
  "number": "9.13.1",
  "title": "",
  "body": " Start with node A.   Graph with node 'fool' as the central node connected to four adjacent nodes labeled 'pool', 'foil', 'foul', and 'cool', each marked with the number '1'. Below the graph is a visual representation of a queue with the nodes 'pool', 'foil', 'foul', and 'cool' lined up in order.   "
},
{
  "id": "fig-ktb",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-ktb",
  "type": "Figure",
  "number": "9.13.2",
  "title": "",
  "body": " Explore B.   Graph with nodes A, B, C, D, E, and F, with node B highlighted, indicating exploration from node B to nodes A and E.   "
},
{
  "id": "fig-ktc",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-ktc",
  "type": "Figure",
  "number": "9.13.3",
  "title": "",
  "body": " Node C is a dead end.   Graph highlighting node C, showing no further connections, indicating that C is a dead end in the search process.   "
},
{
  "id": "fig-ktd",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-ktd",
  "type": "Figure",
  "number": "9.13.4",
  "title": "",
  "body": " Backtrack to B.   Graph with a backtrack path from node C to node B, illustrating the step of returning to node B to continue the search.   "
},
{
  "id": "fig-kte",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-kte",
  "type": "Figure",
  "number": "9.13.5",
  "title": "",
  "body": " Explore D.   Graph with node D highlighted, indicating the exploration is continuing from node D to nodes A and E.   "
},
{
  "id": "fig-ktf",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-ktf",
  "type": "Figure",
  "number": "9.13.6",
  "title": "",
  "body": " Explore E.   Graph focusing on node E, with exploration proceeding from node E to nodes B and D.   "
},
{
  "id": "fig-ktg",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-ktg",
  "type": "Figure",
  "number": "9.13.7",
  "title": "",
  "body": " Explore F.   Graph with node F highlighted, representing the search exploring potential paths from node F to node C.   "
},
{
  "id": "fig-kth",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-kth",
  "type": "Figure",
  "number": "9.13.8",
  "title": "",
  "body": " Finish.   Final graph with all nodes no longer highlighted, representing the completion of the depth-first search process.   "
},
{
  "id": "fig-completeTour",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#fig-completeTour",
  "type": "Figure",
  "number": "9.13.9",
  "title": "",
  "body": " A Complete Tour of the Board.   Image depicting a graph overlaid on an 8x8 chessboard grid representing a complete Knight's Tour. The nodes, numbered from 0 to 63, correspond to the squares of the chessboard. Lines crisscross the grid, mapping the knight's moves in a sequential path that visits each square exactly once. The complex web of lines indicates the knight's route, creating a Hamiltonian circuit where the start and end points are connected. Captioned 'Figure 11: A Complete Tour of the Board'.   "
},
{
  "id": "KnightsTour",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#KnightsTour",
  "type": "Reading Question",
  "number": "9.13.1",
  "title": "",
  "body": " True\/False: The Knight's Tour Graph contains as many vertices as there are tiles on a chessboard.     True    You are correct!      False    No; remember the implementation of Matrix graphs.    "
},
{
  "id": "clickKnight",
  "level": "2",
  "url": "graphs_implementing-knights-tour.html#clickKnight",
  "type": "Reading Question",
  "number": "9.13.2",
  "title": "",
  "body": "What line denotes the base case of the Knight's Tour function? Remember, the base case is usually the first comparison in the function!  def knightTour(n,path,u,limit): :  u.setColor('gray') :  path.append(u) :  if n < limit: :   nbrList = list(u.getConnections()) :   i = 0 :   done = False :   while i < len(nbrList) and not done: :   if nbrList[i].getColor() == 'white': :   done = knightTour(n+1, path, nbrList[i], limit) :   i = i + 1 :   if not done: # prepare to backtrack :   path.pop() :   u.setColor('white') :  else: :   done = True :  return done :  "
},
{
  "id": "graphs_knights-tour-analysis",
  "level": "1",
  "url": "graphs_knights-tour-analysis.html",
  "type": "Section",
  "number": "9.14",
  "title": "Knight’s Tour Analysis",
  "body": " Knight's Tour Analysis  There is one last interesting topic regarding the knight's tour problem, then we will move on to the general version of the depth first search. The topic is performance. In particular, knightTour is very sensitive to the method you use to select the next vertex to visit. For example, on a five-by-five board you can produce a path in about 1.5 seconds on a reasonably fast computer. But what happens if you try an eight-by-eight board? In this case, depending on the speed of your computer, you may have to wait up to a half hour to get the results! The reason for this is that the knight's tour problem as we have implemented it so far is an exponential algorithm of size , where N is the number of squares on the chess board, and k is a small constant. can help us visualize why this is so. The root of the tree represents the starting point of the search. From there the algorithm generates and checks each of the possible moves the knight can make. As we have noted before the number of moves possible depends on the position of the knight on the board. In the corners there are only two legal moves, on the squares adjacent to the corners there are three and in the middle of the board there are eight. shows the number of moves possible for each position on a board. At the next level of the tree there are once again between 2 and 8 possible next moves from the position we are currently exploring. The number of possible positions to examine corresponds to the number of nodes in the search tree.   A Search Tree for the Knight's Tour.   Image of a search tree representing the possible sequences of moves for a Knight's Tour on a chessboard. The tree structure fans out from a single root node at the top, branching out to successive levels that represent each move of the knight. Each node represents a position on the chessboard, with the links between them representing legal moves of the knight. The breadth of the tree at each level indicates the growing complexity of the tour as more moves are made. The tree is a visual representation of the decision process in computing the tour, with the expansive spread of nodes illustrating the many possible paths the knight can take.     Number of Possible Moves for Each Square.   Diagram showing an 8x8 chessboard grid, each square labeled with a number indicating the total possible moves a knight can make from that position. The numbers range from '2' on the corners, up to '8' in the central squares, with varying numbers like '3', '4', and '6' on other squares based on their position. The layout demonstrates the accessibility of each square for a knight, with central squares being the most accessible. This visualization aids in understanding the knight's range of movement on a standard chessboard.    We have already seen that the number of nodes in a binary tree of height N is . For a tree with nodes that may have up to eight children instead of two the number of nodes is much larger. Because the branching factor of each node is variable, we could estimate the number of nodes using an average branching factor. The important thing to note is that this algorithm is exponential: , where is the average branching factor for the board. Let's look at how rapidly this grows! For a board that is 5x5 the tree will be 25 levels deep, or N = 24 counting the first level as level 0. The average branching factor is So the number of nodes in the search tree is or . For a 6x6 board, , there are nodes, and for a regular 8x8 chess board, , there are . Of course, since there are multiple solutions to the problem we won't have to explore every single node, but the fractional part of the nodes we do have to explore is just a constant multiplier which does not change the exponential nature of the problem. We will leave it as an exercise for you to see if you can express as a function of the board size.  Luckily there is a way to speed up the eight-by-eight case so that it runs in under one second. In the listing below we show the code that speeds up the knightTour . This function (see ), called orderbyAvail will be used in place of the call to u.getConnections in the code previously shown above. The critical line in the orderByAvail function is line 10. This line ensures that we select the vertex to go next that has the fewest available moves. You might think this is really counter productive; why not select the node that has the most available moves? You can try that approach easily by running the program yourself and inserting the line resList.reverse() right after the sort.  The problem with using the vertex with the most available moves as your next vertex on the path is that it tends to have the knight visit the middle squares early on in the tour. When this happens it is easy for the knight to get stranded on one side of the board where it cannot reach unvisited squares on the other side of the board. On the other hand, visiting the squares with the fewest available moves first pushes the knight to visit the squares around the edges of the board first. This ensures that the knight will visit the hard-to-reach corners early and can use the middle squares to hop across the board only when necessary. Utilizing this kind of knowledge to speed up an algorithm is called a heuristic. Humans use heuristics every day to help make decisions, heuristic searches are often used in the field of artificial intelligence. This particular heuristic is called Warnsdorff's algorithm, named after H. C. Warnsdorff who published his idea in 1823.  The visualization in depicts the full process of a Knight's Tour solution. It portrays the visitation of every spot on the chess board and an analysis on all neighboring locations, and finishes by showing the final solution wherein all locations on the chess board have been visited. The Warnsdorff heuristic is used in this visualization, so all neighbors with less moves are prioritized over neighbors with more moves. The individual components of the visualization are indicated by color and shape, which is described below.    The currently focused point on the chess board is a black circle.    Neighbors of that point that are being examined are higlighted in blue hexagon.    Distant neighbors are orange or brown triangles.    Triangles are orange if the spot on the chess board has not been visited yet.    Triangles are brown if the spot on the chess board has already been visited.       Knights tour visualization    Listing 4  Listing 4  def orderByAvail(n): resList = [] for v in n.getConnections(): if v.getColor() == 'white': c = 0 for w in v.getConnections(): if w.getColor() == 'white': c = c + 1 resList.append((c,v)) resList.sort(key=lambda x: x[0]) return [y[1] for y in resList]    Reading Question   What is the big O of the Knight's Tour function?     O(k^n)    You are correct! K is a small constant, and N is the total number of vertices (or spaces on a chessboard).      O(n)    No, the Knight's Tour is not linear.      O(n^2)    No, the Knight's Tour does not have a nested loop that iterates through all values twice.      O(n!)    No, the input is not processed in a fashion indicative of a factorial.      "
},
{
  "id": "fig-8array",
  "level": "2",
  "url": "graphs_knights-tour-analysis.html#fig-8array",
  "type": "Figure",
  "number": "9.14.1",
  "title": "",
  "body": " A Search Tree for the Knight's Tour.   Image of a search tree representing the possible sequences of moves for a Knight's Tour on a chessboard. The tree structure fans out from a single root node at the top, branching out to successive levels that represent each move of the knight. Each node represents a position on the chessboard, with the links between them representing legal moves of the knight. The breadth of the tree at each level indicates the growing complexity of the tour as more moves are made. The tree is a visual representation of the decision process in computing the tour, with the expansive spread of nodes illustrating the many possible paths the knight can take.   "
},
{
  "id": "fig-nummoves",
  "level": "2",
  "url": "graphs_knights-tour-analysis.html#fig-nummoves",
  "type": "Figure",
  "number": "9.14.2",
  "title": "",
  "body": " Number of Possible Moves for Each Square.   Diagram showing an 8x8 chessboard grid, each square labeled with a number indicating the total possible moves a knight can make from that position. The numbers range from '2' on the corners, up to '8' in the central squares, with varying numbers like '3', '4', and '6' on other squares based on their position. The layout demonstrates the accessibility of each square for a knight, with central squares being the most accessible. This visualization aids in understanding the knight's range of movement on a standard chessboard.   "
},
{
  "id": "graphs_knighttour-figvideo",
  "level": "2",
  "url": "graphs_knights-tour-analysis.html#graphs_knighttour-figvideo",
  "type": "Figure",
  "number": "9.14.3",
  "title": "",
  "body": " Knights tour visualization   "
},
{
  "id": "graphs_lst-avail",
  "level": "2",
  "url": "graphs_knights-tour-analysis.html#graphs_lst-avail",
  "type": "Listing",
  "number": "9.14.4",
  "title": "",
  "body": "Listing 4  def orderByAvail(n): resList = [] for v in n.getConnections(): if v.getColor() == 'white': c = 0 for w in v.getConnections(): if w.getColor() == 'white': c = c + 1 resList.append((c,v)) resList.sort(key=lambda x: x[0]) return [y[1] for y in resList]  "
},
{
  "id": "knightO",
  "level": "2",
  "url": "graphs_knights-tour-analysis.html#knightO",
  "type": "Reading Question",
  "number": "9.14.1",
  "title": "",
  "body": " What is the big O of the Knight's Tour function?     O(k^n)    You are correct! K is a small constant, and N is the total number of vertices (or spaces on a chessboard).      O(n)    No, the Knight's Tour is not linear.      O(n^2)    No, the Knight's Tour does not have a nested loop that iterates through all values twice.      O(n!)    No, the input is not processed in a fashion indicative of a factorial.    "
},
{
  "id": "graphs_general-depth-first-search",
  "level": "1",
  "url": "graphs_general-depth-first-search.html",
  "type": "Section",
  "number": "9.15",
  "title": "General Depth First Search",
  "body": " General Depth First Search  The knight's tour is a special case of a depth first search where the goal is to create the deepest depth first tree, without any branches. The more general depth first search is actually easier. Its goal is to search as deeply as possible, connecting as many nodes in the graph as possible and branching where necessary.   depth first forest It is even possible that a depth first search will create more than one tree. When the depth first search algorithm creates a group of trees we call this a depth first forest . As with the breadth first search our depth first search makes use of predecessor links to construct the tree. In addition, the depth first search will make use of two additional instance variables in the Vertex class. The new instance variables are the discovery and finish times. The discovery time tracks the number of steps in the algorithm before a vertex is first encountered. The finish time is the number of steps in the algorithm before a vertex is colored black. As we will see after looking at the algorithm, the discovery and finish times of the nodes provide some interesting properties we can use in later algorithms.  The code for our depth first search is shown in Listing 5 . Since the two functions dfs and its helper dfsvisit use a variable to keep track of the time across calls to dfsvisit we chose to implement the code as methods of a class that inherits from the Graph class. This implementation extends the graph class by adding a time instance variable and the two methods dfs and dfsvisit . Looking at line 11 you will notice that the dfs method iterates over all of the vertices in the graph calling dfsvisit on the nodes that are white. The reason we iterate over all the nodes, rather than simply searching from a chosen starting node, is to make sure that all nodes in the graph are considered and that no vertices are left out of the depth first forest. It may look unusual to see the statement for aVertex in self , but remember that in this case self is an instance of the DFSGraph class, and iterating over all the vertices in an instance of a graph is a natural thing to do.  Listing 5    #include <list> \/\/std::list #include <utility> \/\/std::pair #include <algorithm> \/\/std::find #include <map> \/\/std::map #include <iostream> \/\/std::cout class DFSGraph{ typedef std::pair<int, std::list<int>> vertex_t; typedef std::map<int, vertex_t> graph_t; public: const bool directional; DFSGraph(bool directional) : directional(directional){} bool containsVertex(int id){ return vertices.count(id); } std::list<int>& getVertexConnections(int id){ return vertices[id].second; } void addVertex(int id){ if(containsVertex(id)){ vertices[id].second.clear(); }else{ vertices[id] = std::make_pair(id, std::list<int>()); } } vertex_t& getVertex(int id){ return vertices[id]; } void addEdge(int fromID, int toID){ if(!containsVertex(fromID)) addVertex(fromID); if(!containsVertex(toID)) addVertex(toID); getVertexConnections(fromID).push_back(toID); if(!directional) getVertexConnections(toID).push_back(fromID); } void dfs(){ std::list<int> visitedList; for(auto& cur : vertices){ if(std::find(visitedList.begin(), visitedList.end(), cur.first) == visitedList.end()){ dfsvisit(visitedList, cur.second); } } } void dfsvisit(std::list<int>& visitedList, vertex_t& vertex){ visitedList.push_back(vertex.first); std::cout << \"Visited Vertex With ID#: \" << vertex.first << std::endl; for(int neighborID : vertex.second){ if(std::find(visitedList.begin(), visitedList.end(), neighborID) != visitedList.end()){ dfsvisit(visitedList, getVertex(neighborID)); } } } private: graph_t vertices; }; int main(int argc, char** argv){ DFSGraph graph(true); graph.addEdge(0, 1); graph.addEdge(0, 2); graph.addEdge(0, 5); graph.addEdge(3, 4); graph.addEdge(3, 2); graph.addEdge(1, 5); graph.addEdge(1, 2); graph.addEdge(5, 4); graph.addEdge(5, 3); graph.dfs(); return 0; }     from pythonds.graphs import Graph class DFSGraph(Graph): def __init__(self): super().__init__() self.time = 0 def dfs(self): for aVertex in self: aVertex.setColor('white') aVertex.setPred(-1) for aVertex in self: if aVertex.getColor() == 'white': self.dfsvisit(aVertex) def dfsvisit(self,startVertex): startVertex.setColor('gray') print(\"Visiting vertex with ID# \" + str(startVertex.id)) self.time += 1 startVertex.setDiscovery(self.time) for nextVertex in startVertex.getConnections(): if nextVertex.getColor() == 'white': nextVertex.setPred(startVertex) self.dfsvisit(nextVertex) startVertex.setColor('black') self.time += 1 startVertex.setFinish(self.time) def main(): graph = DFSGraph() graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(0, 5) graph.addEdge(3, 4) graph.addEdge(3, 2) graph.addEdge(1, 5) graph.addEdge(1, 2) graph.addEdge(5, 4) graph.addEdge(5, 3) graph.dfs() main()    Although our implementation of bfs was only interested in considering nodes for which there was a path leading back to the start, it is possible to create a breadth first forest that represents the shortest path between all pairs of nodes in the graph. We leave this as an exercise. In our next two algorithms we will see why keeping track of the depth first forest is important.  The dfsvisit method starts with a single vertex called startVertex and explores all of the neighboring white vertices as deeply as possible. If you look carefully at the code for dfsvisit and compare it to breadth first search, what you should notice is that the dfsvisit algorithm is almost identical to bfs except that on the last line of the inner for loop, dfsvisit calls itself recursively to continue the search at a deeper level, whereas bfs adds the node to a queue for later exploration. It is interesting to note that where bfs uses a queue, dfsvisit uses a stack. You don't see a stack in the code, but it is implicit in the recursive call to dfsvisit .  The following sequence of figures illustrates the depth first search algorithm in action for a small graph. In these figures, the dotted lines indicate edges that are checked, but the node at the other end of the edge has already been added to the depth first tree. In the code this test is done by checking that the color of the other node is non-white.  The search begins at vertex A of the graph ( ). Since all of the vertices are white at the beginning of the search the algorithm visits vertex A. The first step in visiting a vertex is to set the color to gray, which indicates that the vertex is being explored and the discovery time is set to 1. Since vertex A has two adjacent vertices (B, D) each of those need to be visited as well. We'll make the arbitrary decision that we will visit the adjacent vertices in alphabetical order.  Vertex B is visited next ( ), so its color is set to gray and its discovery time is set to 2. Vertex B is also adjacent to two other nodes (C, D) so we will follow the alphabetical order and visit node C next.  Visiting vertex C ( ) brings us to the end of one branch of the tree. After coloring the node gray and setting its discovery time to 3, the algorithm also determines that there are no adjacent vertices to C. This means that we are done exploring node C and so we can color the vertex black, and set the finish time to 4. You can see the state of our search at this point in .  Since vertex C was the end of one branch we now return to vertex B and continue exploring the nodes adjacent to B. The only additional vertex to explore from B is D, so we can now visit D ( ) and continue our search from vertex D. Vertex D quickly leads us to vertex E ( ). Vertex E has two adjacent vertices, B and F. Normally we would explore these adjacent vertices alphabetically, but since B is already colored gray the algorithm recognizes that it should not visit B since doing so would put the algorithm in a loop! So exploration continues with the next vertex in the list, namely F ( ).  Vertex F has only one adjacent vertex, C, but since C is colored black there is nothing else to explore, and the algorithm has reached the end of another branch. From here on, you will see in through   that the algorithm works its way back to the first node, setting finish times and coloring vertices black.   Constructing the Depth First Search Tree-10.   A graph with six nodes labeled A through F. Node A is marked as the starting point with a '1' and has directed edges to nodes B and D, showing the initial branching in a depth-first search tree.     Constructing the Depth First Search Tree-11.   The graph extends from Figure 14, showing node B as the next node visited in the search, indicated by a '2'. Nodes E and C are shown as subsequent nodes, but not yet visited.     Constructing the Depth First Search Tree-12.   Continuing the sequence, node C is now marked with a '3', showing the progression of the depth-first search moving to the next unvisited node in the tree.     Constructing the Depth First Search Tree-13.   The graph further expands with node C's child nodes, marked as '3\/4', indicating the depth-first search is exploring the deeper levels of the tree     Constructing the Depth First Search Tree-14.   Depth-first search progression with node D marked '5', indicating its visit after nodes A, B, and C, and before node E.     Constructing the Depth First Search Tree-15.   Node E is visited, labeled '6' in the search sequence, following the exploration from node D in the depth-first search tree.     Constructing the Depth First Search Tree-16.   The search continues with node F now visited, labeled with '7', and an unvisited node is connected to node C with a directed edge.     Constructing the Depth First Search Tree-17.   The final stage of the depth-first search, with nodes F and B marked as '7\/8', showing the completion of the tree traversal.     Constructing the Depth First Search Tree-18.   A depth-first search tree diagram with nodes A to F, where nodes A, B, and C are sequentially numbered 1 to 3\/4, and nodes D, E, and F are numbered 5, 6, and 7\/8 respectively, showing the order of traversal.     Constructing the Depth First Search Tree-19.   Continuation of the depth-first search tree, with node E now having two numbers, 6\/9, indicating the backtracking process and further search.     Constructing the Depth First Search Tree-20.   Further progress in the depth-first search tree, node B is now numbered 2\/11, showing that the search has returned to this node after exploring other branches.     Constructing the Depth First Search Tree-21.   The final stage in the depth-first search process with node A labeled as 1\/12, completing the full traversal of the search tree.     parenthesis property The starting and finishing times for each node display a property called the parenthesis property . This property means that all the children of a particular node in the depth first tree have a later discovery time and an earlier finish time than their parent. shows the tree constructed by the depth first search algorithm.   The Resulting Depth First Search Tree.   A completed depth first search tree with six nodes labeled A to F. The nodes are interconnected with arrows indicating the path of the search. Each node is annotated with two numbers; the first number represents the order in which the node was first visited, and the second number represents the order in which the final visit occurred, marking the node’s completion in the search. Node A is labeled \"1\/12\", B \"2\/11\", C \"3\/4\", D \"5\/10\", E \"6\/9\", and F \"7\/8\". This indicates the starting point of the search at node A, the backtracking steps, and the overall path taken to explore all the nodes.    The visualization in shows the entire traversal of the example graph shown above. Nodes attached to an orange line are connected to the node attached with a brown line. This relationship is directional, and mirrors what can be observed above.   DFS Visualization    "
},
{
  "id": "graphs_general-depth-first-search-3",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#graphs_general-depth-first-search-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "depth first forest "
},
{
  "id": "graphs_general-depth-first-search-4",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#graphs_general-depth-first-search-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 5 "
},
{
  "id": "lst-dfsgeneral",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#lst-dfsgeneral",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 5 "
},
{
  "id": "fig-gdfsa",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsa",
  "type": "Figure",
  "number": "9.15.1",
  "title": "",
  "body": " Constructing the Depth First Search Tree-10.   A graph with six nodes labeled A through F. Node A is marked as the starting point with a '1' and has directed edges to nodes B and D, showing the initial branching in a depth-first search tree.   "
},
{
  "id": "fig-gdfsb",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsb",
  "type": "Figure",
  "number": "9.15.2",
  "title": "",
  "body": " Constructing the Depth First Search Tree-11.   The graph extends from Figure 14, showing node B as the next node visited in the search, indicated by a '2'. Nodes E and C are shown as subsequent nodes, but not yet visited.   "
},
{
  "id": "fig-gdfsc",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsc",
  "type": "Figure",
  "number": "9.15.3",
  "title": "",
  "body": " Constructing the Depth First Search Tree-12.   Continuing the sequence, node C is now marked with a '3', showing the progression of the depth-first search moving to the next unvisited node in the tree.   "
},
{
  "id": "fig-gdfsd",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsd",
  "type": "Figure",
  "number": "9.15.4",
  "title": "",
  "body": " Constructing the Depth First Search Tree-13.   The graph further expands with node C's child nodes, marked as '3\/4', indicating the depth-first search is exploring the deeper levels of the tree   "
},
{
  "id": "fig-gdfse",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfse",
  "type": "Figure",
  "number": "9.15.5",
  "title": "",
  "body": " Constructing the Depth First Search Tree-14.   Depth-first search progression with node D marked '5', indicating its visit after nodes A, B, and C, and before node E.   "
},
{
  "id": "fig-gdfsf",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsf",
  "type": "Figure",
  "number": "9.15.6",
  "title": "",
  "body": " Constructing the Depth First Search Tree-15.   Node E is visited, labeled '6' in the search sequence, following the exploration from node D in the depth-first search tree.   "
},
{
  "id": "fig-gdfsg",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsg",
  "type": "Figure",
  "number": "9.15.7",
  "title": "",
  "body": " Constructing the Depth First Search Tree-16.   The search continues with node F now visited, labeled with '7', and an unvisited node is connected to node C with a directed edge.   "
},
{
  "id": "fig-gdfsh",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsh",
  "type": "Figure",
  "number": "9.15.8",
  "title": "",
  "body": " Constructing the Depth First Search Tree-17.   The final stage of the depth-first search, with nodes F and B marked as '7\/8', showing the completion of the tree traversal.   "
},
{
  "id": "fig-gdfsi",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsi",
  "type": "Figure",
  "number": "9.15.9",
  "title": "",
  "body": " Constructing the Depth First Search Tree-18.   A depth-first search tree diagram with nodes A to F, where nodes A, B, and C are sequentially numbered 1 to 3\/4, and nodes D, E, and F are numbered 5, 6, and 7\/8 respectively, showing the order of traversal.   "
},
{
  "id": "fig-gdfsj",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsj",
  "type": "Figure",
  "number": "9.15.10",
  "title": "",
  "body": " Constructing the Depth First Search Tree-19.   Continuation of the depth-first search tree, with node E now having two numbers, 6\/9, indicating the backtracking process and further search.   "
},
{
  "id": "fig-gdfsk",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsk",
  "type": "Figure",
  "number": "9.15.11",
  "title": "",
  "body": " Constructing the Depth First Search Tree-20.   Further progress in the depth-first search tree, node B is now numbered 2\/11, showing that the search has returned to this node after exploring other branches.   "
},
{
  "id": "fig-gdfsl",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-gdfsl",
  "type": "Figure",
  "number": "9.15.12",
  "title": "",
  "body": " Constructing the Depth First Search Tree-21.   The final stage in the depth-first search process with node A labeled as 1\/12, completing the full traversal of the search tree.   "
},
{
  "id": "graphs_general-depth-first-search-28",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#graphs_general-depth-first-search-28",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "parenthesis property "
},
{
  "id": "fig-dfstree",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#fig-dfstree",
  "type": "Figure",
  "number": "9.15.13",
  "title": "",
  "body": " The Resulting Depth First Search Tree.   A completed depth first search tree with six nodes labeled A to F. The nodes are interconnected with arrows indicating the path of the search. Each node is annotated with two numbers; the first number represents the order in which the node was first visited, and the second number represents the order in which the final visit occurred, marking the node’s completion in the search. Node A is labeled \"1\/12\", B \"2\/11\", C \"3\/4\", D \"5\/10\", E \"6\/9\", and F \"7\/8\". This indicates the starting point of the search at node A, the backtracking steps, and the overall path taken to explore all the nodes.   "
},
{
  "id": "graphs_general_depth-dfs-vis",
  "level": "2",
  "url": "graphs_general-depth-first-search.html#graphs_general_depth-dfs-vis",
  "type": "Figure",
  "number": "9.15.14",
  "title": "",
  "body": " DFS Visualization   "
},
{
  "id": "graphs_depth-first-search-analysis",
  "level": "1",
  "url": "graphs_depth-first-search-analysis.html",
  "type": "Section",
  "number": "9.16",
  "title": "Depth First Search Analysis",
  "body": " Depth First Search Analysis  The general running time for depth first search is as follows. The loops in dfs both run in , not counting what happens in dfsvisit , since they are executed once for each vertex in the graph. In dfsvisit the loop is executed once for each edge in the adjacency list of the current vertex. Since dfsvisit is only called recursively if the vertex is white, the loop will execute a maximum of once for every edge in the graph or . So, the total time for depth first search is .  "
},
{
  "id": "graphs_topological-sorting",
  "level": "1",
  "url": "graphs_topological-sorting.html",
  "type": "Section",
  "number": "9.17",
  "title": "Topological Sorting",
  "body": " Topological Sorting  To demonstrate that computer scientists can turn just about anything into a graph problem, let's consider the difficult problem of stirring up a batch of pancakes. The recipe is really quite simple: 1 egg, 1 cup of pancake mix, 1 tablespoon oil, and cup of milk. To make pancakes you must heat the griddle, mix all the ingredients together and spoon the mix onto a hot griddle. When the pancakes start to bubble you turn them over and let them cook until they are golden brown on the bottom. Before you eat your pancakes you are going to want to heat up some syrup. illustrates this process as a graph.   The Steps for Making Pancakes.   A flowchart detailing the steps for making pancakes. The process begins with three separate ingredients: 3\/4 cup of milk, 1 egg, and 1 Tbl of oil, converging into a central step labeled '1 cup mix'. From there, the flowchart indicates to 'heat griddle', followed by 'pour 1\/4 cup' of the mix onto the griddle. The next step is to 'turn when bubbly', indicating when to flip the pancakes. Two concurrent final steps are 'heat syrup' and 'eat', signifying the end of the pancake-making process. The flowchart effectively outlines the sequence of actions required to make pancakes from the initial ingredient preparation to the final eating stage.    The difficult thing about making pancakes is knowing what to do first. As you can see from you might start by heating the griddle or by adding any of the ingredients to the pancake mix. To help us decide the precise order in which we should do each of the steps required to make our pancakes we turn to a graph algorithm called the topological sort .   topological sort A topological sort takes a directed acyclic graph and produces a linear ordering of all its vertices such that if the graph contains an edge then the vertex comes before the vertex in the ordering. Directed acyclic graphs are used in many applications to indicate the precedence of events. Making pancakes is just one example; other examples include software project schedules, precedence charts for optimizing database queries, and multiplying matrices.  The topological sort is a simple but useful adaptation of a depth first search. The algorithm for the topological sort is as follows:    Call dfs(g) for some graph g . The main reason we want to call depth first search is to compute the finish times for each of the vertices.    Store the vertices in a list in decreasing order of finish time.    Return the ordered list as the result of the topological sort.    shows the depth first forest constructed by dfs on the pancake-making graph shown in .   Result of Depth First Search on the Pancake Graph.   The image depicts the result of a depth-first search on a pancake recipe graph. It starts with \"3\/4 cup milk\" at step 1\/12, which along with \"1 egg\" at step 15\/16 and \"1 Tbl Oil\" at step 17\/18, feeds into \"1 cup mix\" at step 2\/11. This leads to \"heat griddle\" at step 13\/14, followed by \"pour 1\/4 cup\" at step 3\/8. The next action is \"turn when bubbly\" at step 4\/7, and the final steps are \"heat syrup\" at step 9\/10 and \"eat\" at step 5\/6. Each step is represented by an oval, with directed edges showing the sequence of the recipe steps, and numbers indicating the search progression.    Finally, shows the results of applying the topological sort algorithm to our graph. Now all the ambiguity has been removed and we know exactly the order in which to perform the pancake making steps.   Result of Depth First Search on the Pancake Graph.   Alt text for Figure 29: This image shows the result of a topological sort on a directed acyclic graph representing the steps for making pancakes. The sequence begins with \"1 Tbl Oil\" at step 17\/18, followed by \"1 egg\" at step 15\/16, \"3\/4 cup milk\" at step 1\/12, and \"1 cup mix\" at step 2\/11. The next steps are \"heat griddle\" at step 13\/14, \"heat syrup\" at step 9\/10, \"pour 1\/4 cup\" at step 3\/8, and \"turn when bubbly\" at step 4\/7. The final action is \"eat\" at step 5\/6. Each step is depicted as an oval, connected by directed paths that indicate the order of operations, with numbers denoting the order in the topological sort.    "
},
{
  "id": "fig-pancakes",
  "level": "2",
  "url": "graphs_topological-sorting.html#fig-pancakes",
  "type": "Figure",
  "number": "9.17.1",
  "title": "",
  "body": " The Steps for Making Pancakes.   A flowchart detailing the steps for making pancakes. The process begins with three separate ingredients: 3\/4 cup of milk, 1 egg, and 1 Tbl of oil, converging into a central step labeled '1 cup mix'. From there, the flowchart indicates to 'heat griddle', followed by 'pour 1\/4 cup' of the mix onto the griddle. The next step is to 'turn when bubbly', indicating when to flip the pancakes. Two concurrent final steps are 'heat syrup' and 'eat', signifying the end of the pancake-making process. The flowchart effectively outlines the sequence of actions required to make pancakes from the initial ingredient preparation to the final eating stage.   "
},
{
  "id": "graphs_topological-sorting-4",
  "level": "2",
  "url": "graphs_topological-sorting.html#graphs_topological-sorting-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "topological sort "
},
{
  "id": "fig-pancakesdfs",
  "level": "2",
  "url": "graphs_topological-sorting.html#fig-pancakesdfs",
  "type": "Figure",
  "number": "9.17.2",
  "title": "",
  "body": " Result of Depth First Search on the Pancake Graph.   The image depicts the result of a depth-first search on a pancake recipe graph. It starts with \"3\/4 cup milk\" at step 1\/12, which along with \"1 egg\" at step 15\/16 and \"1 Tbl Oil\" at step 17\/18, feeds into \"1 cup mix\" at step 2\/11. This leads to \"heat griddle\" at step 13\/14, followed by \"pour 1\/4 cup\" at step 3\/8. The next action is \"turn when bubbly\" at step 4\/7, and the final steps are \"heat syrup\" at step 9\/10 and \"eat\" at step 5\/6. Each step is represented by an oval, with directed edges showing the sequence of the recipe steps, and numbers indicating the search progression.   "
},
{
  "id": "fig-pancakesTS",
  "level": "2",
  "url": "graphs_topological-sorting.html#fig-pancakesTS",
  "type": "Figure",
  "number": "9.17.3",
  "title": "",
  "body": " Result of Depth First Search on the Pancake Graph.   Alt text for Figure 29: This image shows the result of a topological sort on a directed acyclic graph representing the steps for making pancakes. The sequence begins with \"1 Tbl Oil\" at step 17\/18, followed by \"1 egg\" at step 15\/16, \"3\/4 cup milk\" at step 1\/12, and \"1 cup mix\" at step 2\/11. The next steps are \"heat griddle\" at step 13\/14, \"heat syrup\" at step 9\/10, \"pour 1\/4 cup\" at step 3\/8, and \"turn when bubbly\" at step 4\/7. The final action is \"eat\" at step 5\/6. Each step is depicted as an oval, connected by directed paths that indicate the order of operations, with numbers denoting the order in the topological sort.   "
},
{
  "id": "graphs_strongly-connected-components",
  "level": "1",
  "url": "graphs_strongly-connected-components.html",
  "type": "Section",
  "number": "9.18",
  "title": "Strongly Connected Components",
  "body": " Strongly Connected Components  For the remainder of this chapter we will turn our attention to some extremely large graphs. The graphs we will use to study some additional algorithms are the graphs produced by the connections between hosts on the Internet and the links between web pages. We will begin with web pages.  Search engines like Google and Bing exploit the fact that the pages on the web form a very large directed graph. To transform the World Wide Web into a graph, we will treat a page as a vertex, and the hyperlinks on the page as edges connecting one vertex to another. shows a very small part of the graph produced by following the links from one page to the next, beginning at Luther College's Computer Science home page. Of course, this graph could be huge, so we have limited it to web sites that are no more than 10 links away from the CS home page.   The Graph Produced by Links from the Luther Computer Science Home Page.   This image depicts a complex network graph that visualizes the web of links from the Luther Computer Science Home Page. The graph is a cluster of interconnected nodes, each representing a different page or external link. Central nodes like \"Luther College History Department\" have multiple connections radiating out to related nodes such as \"Loyola College in Maryland\" and \"Iowa State University.\" Peripheral nodes link to a variety of topics, including \"Recreational Sports - Luther College,\" \"Luther College Administration,\" and \"Cornell College - Chemistry.\" The links create a dense web, illustrating the interconnected nature of the website's structure. The graph is used to demonstrate the relationships and pathways between various academic departments, programs, and external educational institutions.    If you study the graph in you might make some interesting observations. First you might notice that many of the other web sites on the graph are other Luther College web sites. Second, you might notice that there are several links to other colleges in Iowa. Third, you might notice that there are several links to other liberal arts colleges. You might conclude from this that there is some underlying structure to the web that clusters together web sites that are similar on some level.   strongly connected component One graph algorithm that can help find clusters of highly interconnected vertices in a graph is called the strongly connected components algorithm ( SCC ). We formally define a strongly connected component , , of a graph , as the largest subset of vertices such that for every pair of vertices we have a path from to and a path from to . shows a simple graph with three strongly connected components. The strongly connected components are identified by the different shaded areas.   A Directed Graph with Three Strongly Connected Components.   The image shows a directed graph composed of three strongly connected components, each highlighted in a separate shaded area. The graph contains nine nodes labeled A through I. Nodes A, B, and C form the first component, with arrows indicating directed edges from A to B, B to A, and B to C. The second component consists of nodes D, E, and G, with directed edges connecting D to E, E to D, and D to G. The third component includes nodes F, H, and I, with edges from F to H, H to I, and I to F. Each component is a self-contained subgraph where every node is reachable from every other node within the same component, illustrating the concept of strong connectivity in graph theory.    Once the strongly connected components have been identified we can show a simplified view of the graph by combining all the vertices in one strongly connected component into a single larger vertex. The simplified version of the graph in is shown in .   The Reduced Graph.   The image depicts a simplified or reduced graph consisting of three nodes, which are labeled with the combined letters of the nodes from the strongly connected components they represent. The first node contains the letters \"ABDEG,\" indicating it is a merged node of the first component. The second node is labeled \"C,\" and the third node contains \"FHI,\" representing the second and third components, respectively. There are directed edges from the \"ABDEG\" node to \"C\" and from \"C\" to \"FHI,\" showing the flow between these combined nodes. This reduced graph emphasizes the hierarchical structure and the dependencies between the strongly connected components of the original directed graph.    Once again we will see that we can create a very powerful and efficient algorithm by making use of a depth first search. Before we tackle the main SCC algorithm we must look at one other definition. The transposition of a graph is defined as the graph where all the edges in the graph have been reversed. That is, if there is a directed edge from node A to node B in the original graph then will contain and edge from node B to node A. and show a simple graph and its transposition.   A Graph .   The image illustrates a directed graph G with four nodes labeled A, B, C, and D. There is a directed edge from A to B, indicating a one-way relationship, and two other directed edges, one from B to D and another from C to D, suggesting that both B and C can independently reach D.     Its Transpose .   The image shows the transpose of the graph from Figure 33, where the direction of all the edges in the original graph G has been reversed. In this transposed graph, there is a directed edge from B to A, and two other directed edges, one from D to B and another from D to C, indicating that D can reach both B and C. This represents the inverse relationships compared to the original graph G.    Look at the figures again. Notice that the graph in has two strongly connected components. Now look at . Notice that it has the same two strongly connected components.  We can now describe the algorithm to compute the strongly connected components for a graph.    Call dfs for the graph to compute the finish times for each vertex.    Compute .    Call dfs for the graph but in the main loop of DFS explore each vertex in decreasing order of finish time.    Each tree in the forest computed in step 3 is a strongly connected component. Output the vertex ids for each vertex in each tree in the forest to identify the component.    Let's trace the operation of the steps described above on the example graph in . shows the starting and finishing times computed for the original graph by the DFS algorithm. shows the starting and finishing times computed by running DFS on the transposed graph.   Starting and finishing times for the original graph .   The image displays a directed graph G consisting of nine nodes labeled A through I. Each node is annotated with a pair of numbers, representing the finishing times in the format 'start\/finish'. The edges indicate the direction of connection between nodes. Solid arrows represent direct connections, while dashed arrows signify connections that are part of the graph but are not the primary path in the context shown. This graph is likely used to demonstrate an algorithmic concept such as Depth-First Search (DFS), where the numbers indicate the order in which nodes are fully processed.     Starting and finishing times for .   This image depicts a directed graph, labeled G^T, which is the transpose of a previous graph G. It consists of nine nodes labeled A through I. Each node is marked with two numbers, indicating the finishing times, in a format that suggests the order in which they were processed, with the first number likely representing the start time and the second the finish time. The graph is interconnected with solid and dashed arrows indicating the direction of the edges, where the dashed arrows might represent the reverse of the original connections inG. This graph is typically used to demonstrate concepts such as the calculation of finishing times in a Depth-First Search (DFS) on the transposed graph for algorithms like Kosaraju's or other strong component identification algorithms.    Finally, shows the forest of three trees produced in step 3 of the strongly connected component algorithm. You will notice that we do not provide you with the Python code for the SCC algorithm, we leave writing this program as an exercise.   Strongly Connected Components.   The diagram shows a directed graph illustrating the concept of strongly connected components within a network of nodes. Each node is labeled with a letter from A to I and a pair of numbers, which could represent the sequence in which a depth-first search algorithm processed them. The graph is organized with directed edges forming paths between the nodes, suggesting the presence of subgraphs where each node is reachable from every other node within the same subgraph. This kind of representation is commonly used in computer science to illustrate algorithms that identify strongly connected components within a graph, which are maximal sets of vertices with a path to every other vertex in the set.    "
},
{
  "id": "fig-cshome",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-cshome",
  "type": "Figure",
  "number": "9.18.1",
  "title": "",
  "body": " The Graph Produced by Links from the Luther Computer Science Home Page.   This image depicts a complex network graph that visualizes the web of links from the Luther Computer Science Home Page. The graph is a cluster of interconnected nodes, each representing a different page or external link. Central nodes like \"Luther College History Department\" have multiple connections radiating out to related nodes such as \"Loyola College in Maryland\" and \"Iowa State University.\" Peripheral nodes link to a variety of topics, including \"Recreational Sports - Luther College,\" \"Luther College Administration,\" and \"Cornell College - Chemistry.\" The links create a dense web, illustrating the interconnected nature of the website's structure. The graph is used to demonstrate the relationships and pathways between various academic departments, programs, and external educational institutions.   "
},
{
  "id": "graphs_strongly-connected-components-6",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#graphs_strongly-connected-components-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "SCC strongly connected component "
},
{
  "id": "fig-scc1",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-scc1",
  "type": "Figure",
  "number": "9.18.2",
  "title": "",
  "body": " A Directed Graph with Three Strongly Connected Components.   The image shows a directed graph composed of three strongly connected components, each highlighted in a separate shaded area. The graph contains nine nodes labeled A through I. Nodes A, B, and C form the first component, with arrows indicating directed edges from A to B, B to A, and B to C. The second component consists of nodes D, E, and G, with directed edges connecting D to E, E to D, and D to G. The third component includes nodes F, H, and I, with edges from F to H, H to I, and I to F. Each component is a self-contained subgraph where every node is reachable from every other node within the same component, illustrating the concept of strong connectivity in graph theory.   "
},
{
  "id": "fig-scc2",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-scc2",
  "type": "Figure",
  "number": "9.18.3",
  "title": "",
  "body": " The Reduced Graph.   The image depicts a simplified or reduced graph consisting of three nodes, which are labeled with the combined letters of the nodes from the strongly connected components they represent. The first node contains the letters \"ABDEG,\" indicating it is a merged node of the first component. The second node is labeled \"C,\" and the third node contains \"FHI,\" representing the second and third components, respectively. There are directed edges from the \"ABDEG\" node to \"C\" and from \"C\" to \"FHI,\" showing the flow between these combined nodes. This reduced graph emphasizes the hierarchical structure and the dependencies between the strongly connected components of the original directed graph.   "
},
{
  "id": "fig-transpose1",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-transpose1",
  "type": "Figure",
  "number": "9.18.4",
  "title": "",
  "body": " A Graph .   The image illustrates a directed graph G with four nodes labeled A, B, C, and D. There is a directed edge from A to B, indicating a one-way relationship, and two other directed edges, one from B to D and another from C to D, suggesting that both B and C can independently reach D.   "
},
{
  "id": "fig-transpose2",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-transpose2",
  "type": "Figure",
  "number": "9.18.5",
  "title": "",
  "body": " Its Transpose .   The image shows the transpose of the graph from Figure 33, where the direction of all the edges in the original graph G has been reversed. In this transposed graph, there is a directed edge from B to A, and two other directed edges, one from D to B and another from D to C, indicating that D can reach both B and C. This represents the inverse relationships compared to the original graph G.   "
},
{
  "id": "fig-scc1a",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-scc1a",
  "type": "Figure",
  "number": "9.18.6",
  "title": "",
  "body": " Starting and finishing times for the original graph .   The image displays a directed graph G consisting of nine nodes labeled A through I. Each node is annotated with a pair of numbers, representing the finishing times in the format 'start\/finish'. The edges indicate the direction of connection between nodes. Solid arrows represent direct connections, while dashed arrows signify connections that are part of the graph but are not the primary path in the context shown. This graph is likely used to demonstrate an algorithmic concept such as Depth-First Search (DFS), where the numbers indicate the order in which nodes are fully processed.   "
},
{
  "id": "fig-scc1b",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-scc1b",
  "type": "Figure",
  "number": "9.18.7",
  "title": "",
  "body": " Starting and finishing times for .   This image depicts a directed graph, labeled G^T, which is the transpose of a previous graph G. It consists of nine nodes labeled A through I. Each node is marked with two numbers, indicating the finishing times, in a format that suggests the order in which they were processed, with the first number likely representing the start time and the second the finish time. The graph is interconnected with solid and dashed arrows indicating the direction of the edges, where the dashed arrows might represent the reverse of the original connections inG. This graph is typically used to demonstrate concepts such as the calculation of finishing times in a Depth-First Search (DFS) on the transposed graph for algorithms like Kosaraju's or other strong component identification algorithms.   "
},
{
  "id": "fig-sccforest",
  "level": "2",
  "url": "graphs_strongly-connected-components.html#fig-sccforest",
  "type": "Figure",
  "number": "9.18.8",
  "title": "",
  "body": " Strongly Connected Components.   The diagram shows a directed graph illustrating the concept of strongly connected components within a network of nodes. Each node is labeled with a letter from A to I and a pair of numbers, which could represent the sequence in which a depth-first search algorithm processed them. The graph is organized with directed edges forming paths between the nodes, suggesting the presence of subgraphs where each node is reachable from every other node within the same subgraph. This kind of representation is commonly used in computer science to illustrate algorithms that identify strongly connected components within a graph, which are maximal sets of vertices with a path to every other vertex in the set.   "
},
{
  "id": "graphs_shortest-path-problems",
  "level": "1",
  "url": "graphs_shortest-path-problems.html",
  "type": "Section",
  "number": "9.19",
  "title": "Shortest Path Problems",
  "body": " Shortest Path Problems  When you surf the web, send an email, or log in to a laboratory computer from another location on campus a lot of work is going on behind the scenes to get the information on your computer transferred to another computer. The in-depth study of how information flows from one computer to another over the Internet is the primary topic for a class in computer networking. However, we will talk about how the Internet works just enough to understand another very important graph algorithm.   Overview of Connectivity in the Internet.   This image represents a simplified network diagram, showing an overview of connectivity in the internet. Two routers, labeled as Router A and Router B, serve as the central connection points. Router A is connected to a cloud labeled \"Internet,\" which symbolizes the global network. On the right side of Router A, there are connections leading to a desktop computer and a laptop, representing end-user devices. On the left side of Router B, connected to the same internet cloud, are two server icons, indicating server machines. The diagram visually explains how different types of hardware devices interface with the internet through routers, depicting a basic structure of network connectivity.    shows you a high-level overview of how communication on the Internet works. When you use your browser to request a web page from a server, the request must travel over your local area network and out onto the Internet through a router. The request travels over the Internet and eventually arrives at a router for the local area network where the server is located. The web page you requested then travels back through the same routers to get to your browser. Inside the cloud labelled Internet in are additional routers. The job of all of these routers is to work together to get your information from place to place. You can see there are many routers for yourself if your computer supports the traceroute command. The text below shows the output of the traceroute command which illustrates that there are 13 routers between the web server at Luther College and the mail server at the University of Minnesota.  1 192.203.196.1 2 hilda.luther.edu (216.159.75.1) 3 ICN-Luther-Ether.icn.state.ia.us (207.165.237.137) 4 ICN-ISP-1.icn.state.ia.us (209.56.255.1) 5 p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13) 6 ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97) 7 so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214) 8 ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18) 9 p1-0.minnesota.bbnplanet.net (4.24.226.74) 10 TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37) 11 TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1) 12 TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158) 13 baldrick.cs.umn.edu (128.101.80.129)(N!) 88.631 ms (N!) Routers from One Host to the Next over the Internet  Each router on the Internet is connected to one or more other routers. So if you run the traceroute command at different times of the day, you are likely to see that your information flows through different routers at different times. This is because there is a cost associated with each connection between a pair of routers that depends on the volume of traffic, the time of day, and many other factors. By this time it will not surprise you to learn that we can represent the network of routers as a graph with weighted edges.   Connections and Weights between Routers in the Internet.   The image displays a weighted graph that models the connections and weights between routers in the Internet. The graph consists of six nodes, each representing a router labeled as u, v, w, x, y, and z. The nodes are interconnected by lines that signify the network links between routers. Each line is annotated with a number, representing the weight of the connection, which could indicate the cost, distance, or quality of the link. For instance, router u is connected to router x with a weight of 2, and router x is connected to router v with a weight of 2 and to router y with a weight of 1. This type of graph is typically used to represent the efficiency of data transfer paths in network routing algorithms.    shows a small example of a weighted graph that represents the interconnection of routers in the Internet. The problem that we want to solve is to find the path with the smallest total weight along which to route any given message. This problem should sound familiar because it is similar to the problem we solved using a breadth first search, except that here we are concerned with the total weight of the path rather than the number of hops in the path. It should be noted that if all the weights are equal, the problem is the same.  "
},
{
  "id": "fig-inet",
  "level": "2",
  "url": "graphs_shortest-path-problems.html#fig-inet",
  "type": "Figure",
  "number": "9.19.1",
  "title": "",
  "body": " Overview of Connectivity in the Internet.   This image represents a simplified network diagram, showing an overview of connectivity in the internet. Two routers, labeled as Router A and Router B, serve as the central connection points. Router A is connected to a cloud labeled \"Internet,\" which symbolizes the global network. On the right side of Router A, there are connections leading to a desktop computer and a laptop, representing end-user devices. On the left side of Router B, connected to the same internet cloud, are two server icons, indicating server machines. The diagram visually explains how different types of hardware devices interface with the internet through routers, depicting a basic structure of network connectivity.   "
},
{
  "id": "fig-network",
  "level": "2",
  "url": "graphs_shortest-path-problems.html#fig-network",
  "type": "Figure",
  "number": "9.19.2",
  "title": "",
  "body": " Connections and Weights between Routers in the Internet.   The image displays a weighted graph that models the connections and weights between routers in the Internet. The graph consists of six nodes, each representing a router labeled as u, v, w, x, y, and z. The nodes are interconnected by lines that signify the network links between routers. Each line is annotated with a number, representing the weight of the connection, which could indicate the cost, distance, or quality of the link. For instance, router u is connected to router x with a weight of 2, and router x is connected to router v with a weight of 2 and to router y with a weight of 1. This type of graph is typically used to represent the efficiency of data transfer paths in network routing algorithms.   "
},
{
  "id": "graphs_dijkstras-algorithm",
  "level": "1",
  "url": "graphs_dijkstras-algorithm.html",
  "type": "Section",
  "number": "9.20",
  "title": "Dijkstra’s Algorithm",
  "body": " Dijkstra's Algorithm  dijkstra's algorithm The algorithm we are going to use to determine the shortest path is called Dijkstra's algorithm. Dijkstra's algorithm is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph. Again this is similar to the results of a breadth first search.  To keep track of the total cost from the start node to each destination we will make use of the dist variable in the Vertex class. The dist variable will contain the current total weight of the smallest weight path from the start to the vertex in question. The algorithm iterates once for every vertex in the graph; however, the order that we iterate over the vertices is controlled by a priority queue. The value that is used to determine the order of the objects in the priority queue is dist . When a vertex is first created dist is set to a very large number. Theoretically you would set dist to infinity, but in practice we just set it to a number that is larger than any real distance we would have in the problem we are trying to solve.  The code for Dijkstra's algorithm is shown in . When the algorithm finishes the distances are set correctly as are the predecessor links for each vertex in the graph.   Dijkstra's Algorithm  from pythonds.graphs import PriorityQueue, Graph, Vertex def dijkstra(aGraph,start): pq = PriorityQueue() start.setDistance(0) pq.buildHeap([(v.getDistance(),v) for v in aGraph]) while not pq.isEmpty(): currentVert = pq.delMin() for nextVert in currentVert.getConnections(): newDist = currentVert.getDistance() \\ + currentVert.getWeight(nextVert) if newDist < nextVert.getDistance(): nextVert.setDistance( newDist ) nextVert.setPred(currentVert) pq.decreaseKey(nextVert,newDist)   Dijkstra's algorithm uses a priority queue. You may recall that a priority queue is based on the heap that we implemented in the Tree Chapter. There are a couple of differences between that simple implementation and the implementation we use for Dijkstra's algorithm. First, the PriorityQueue class stores tuples of key, value pairs. This is important for Dijkstra's algorithm as the key in the priority queue must match the key of the vertex in the graph. Secondly the value is used for deciding the priority, and thus the position of the key in the priority queue. In this implementation we use the distance to the vertex as the priority because as we will see when we are exploring the next vertex, we always want to explore the vertex that has the smallest distance. The second difference is the addition of the decreaseKey method. As you can see, this method is used when the distance to a vertex that is already in the queue is reduced, and thus moves that vertex toward the front of the queue.  Let's walk through an application of Dijkstra's algorithm one vertex at a time using the following sequence of figures as our guide. We begin with the vertex . The three vertices adjacent to are and . Since the initial distances to and are all initialized to sys.maxint , the new costs to get to them through the start node are all their direct costs. So we update the costs to each of these three nodes. We also set the predecessor for each node to and we add each node to the priority queue. We use the distance as the key for the priority queue. The state of the algorithm is shown in .  In the next iteration of the while loop we examine the vertices that are adjacent to . The vertex is next because it has the lowest overall cost and therefore bubbled its way to the beginning of the priority queue. At we look at its neighbors and . For each neighboring vertex we check to see if the distance to that vertex through is smaller than the previously known distance. Obviously this is the case for since its distance was sys.maxint . It is not the case for or since their distances are 0 and 2 respectively. However, we now learn that the distance to is smaller if we go through than from directly to . Since that is the case we update with a new distance and change the predecessor for from to . See for the state of all the vertices.  The next step is to look at the vertices neighboring (see ). This step results in no changes to the graph, so we move on to node . At node (see ) we discover that it is cheaper to get to both and , so we adjust the distances and predecessor links accordingly. Finally we check nodes and (see see and see ). However, no additional changes are found and so the priority queue is empty and Dijkstra's algorithm exits.   Tracing Dijkstra's Algorithm.   The image illustrates the initial state of Dijkstra's Algorithm being traced on a weighted graph. The graph includes six nodes: u, v, w, x, y, and z. Node u is marked as the starting point with a tentative distance of zero (d=0), while other nodes are yet to be visited and have undefined distances. Edges connecting the nodes have varying weights, such as the edge from u to x has a weight of 2, and the edge from x to v has a weight of 1. A priority queue (PQ) is depicted at the bottom, currently holding nodes x, v, and w, which will be processed according to the algorithm.     Tracing Dijkstra's Algorithm.   This image further traces Dijkstra's Algorithm on the same weighted graph. The priority queue (PQ) at the bottom has been updated to contain only nodes v and w. Node x has been visited with the shortest distance from u determined (d=1), indicated by a solid line. Other nodes have tentative distances, like node v with a distance of 2 (d=2). Dashed lines indicate unconfirmed paths that are still under consideration.     Tracing Dijkstra's Algorithm.   The image continues the progression of Dijkstra's Algorithm on the graph. Node v has now been confirmed with the shortest path from u (d=2) and is connected by solid lines. The priority queue (PQ) at the bottom now includes only node w. Node x shows the confirmed shortest path from u, and node y has a tentative distance of 2 (d=2). The algorithm visually demonstrates the process of finding the shortest paths from a single source to all other nodes in the graph.     Tracing Dijkstra's Algorithm.   The image shows a continuation of Dijkstra's Algorithm on a weighted graph. The graph's nodes u, v, w, x, y, and z are connected by directed edges with weights. Node w is the current focus, indicated by the priority queue (PQ) containing only w. Nodes u, x, and v have confirmed shortest paths with solid lines leading to them, and their distances from the starting node u are marked as d=0, d=1, and d=2, respectively. Dashed lines suggest potential paths still under consideration.     Tracing Dijkstra's Algorithm.   This step in Dijkstra's Algorithm shows node w with a confirmed shortest path from the starting node (d=3). The priority queue (PQ) at the bottom now contains only node z. The graph is further resolved with nodes u, x, v, and y having confirmed shortest paths, displayed with solid lines and distances marked. The algorithm's process is nearing completion, with almost all nodes having the shortest paths determined.     Tracing Dijkstra's Algorithm.   The final image depicts the weighted graph after the completion of Dijkstra's Algorithm. All nodes have confirmed shortest paths from the starting node u, which are shown with solid lines. The priority queue (PQ) is now empty, indicating that the algorithm has finished running. Each node has a definitive shortest distance from u (d=0, d=1, d=2, d=3, etc.), and the pathfinding process is complete, showcasing the algorithm's effectiveness in solving the shortest path problem.    It is important to note that Dijkstra's algorithm works only when the weights are all positive. You should convince yourself that if you introduced a negative weight on one of the edges to the graph that the algorithm would never exit.  We will note that to route messages through the Internet, other algorithms are used for finding the shortest path. One of the problems with using Dijkstra's algorithm on the Internet is that you must have a complete representation of the graph in order for the algorithm to run. The implication of this is that every router has a complete map of all the routers in the Internet. In practice this is not the case and other variations of the algorithm allow each router to discover the graph as they go. One such algorithm that you may want to read about is called the distance vector routing algorithm.   Reading Question   What purpose does the Priority Queue in the Dijkstra's algorithm serve?     It only holds a series of vertices to traverse.    Not quite, Priority Queues serve a purpose beyond storage.      It holds an unsorted list of unvisited vertices.    No, the vertices will be sorted.      It notes what vertices have been visited.    No, it does not store any visited vertices.      It holds an appropriately sorted list of vertices to traverse.    Correct!      "
},
{
  "id": "graphs_lst-shortpath",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#graphs_lst-shortpath",
  "type": "Listing",
  "number": "9.20.1",
  "title": "",
  "body": " Dijkstra's Algorithm  from pythonds.graphs import PriorityQueue, Graph, Vertex def dijkstra(aGraph,start): pq = PriorityQueue() start.setDistance(0) pq.buildHeap([(v.getDistance(),v) for v in aGraph]) while not pq.isEmpty(): currentVert = pq.delMin() for nextVert in currentVert.getConnections(): newDist = currentVert.getDistance() \\ + currentVert.getWeight(nextVert) if newDist < nextVert.getDistance(): nextVert.setDistance( newDist ) nextVert.setPred(currentVert) pq.decreaseKey(nextVert,newDist)  "
},
{
  "id": "fig-dija",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dija",
  "type": "Figure",
  "number": "9.20.2",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   The image illustrates the initial state of Dijkstra's Algorithm being traced on a weighted graph. The graph includes six nodes: u, v, w, x, y, and z. Node u is marked as the starting point with a tentative distance of zero (d=0), while other nodes are yet to be visited and have undefined distances. Edges connecting the nodes have varying weights, such as the edge from u to x has a weight of 2, and the edge from x to v has a weight of 1. A priority queue (PQ) is depicted at the bottom, currently holding nodes x, v, and w, which will be processed according to the algorithm.   "
},
{
  "id": "fig-dijb",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dijb",
  "type": "Figure",
  "number": "9.20.3",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   This image further traces Dijkstra's Algorithm on the same weighted graph. The priority queue (PQ) at the bottom has been updated to contain only nodes v and w. Node x has been visited with the shortest distance from u determined (d=1), indicated by a solid line. Other nodes have tentative distances, like node v with a distance of 2 (d=2). Dashed lines indicate unconfirmed paths that are still under consideration.   "
},
{
  "id": "fig-dijc",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dijc",
  "type": "Figure",
  "number": "9.20.4",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   The image continues the progression of Dijkstra's Algorithm on the graph. Node v has now been confirmed with the shortest path from u (d=2) and is connected by solid lines. The priority queue (PQ) at the bottom now includes only node w. Node x shows the confirmed shortest path from u, and node y has a tentative distance of 2 (d=2). The algorithm visually demonstrates the process of finding the shortest paths from a single source to all other nodes in the graph.   "
},
{
  "id": "fig-dijd",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dijd",
  "type": "Figure",
  "number": "9.20.5",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   The image shows a continuation of Dijkstra's Algorithm on a weighted graph. The graph's nodes u, v, w, x, y, and z are connected by directed edges with weights. Node w is the current focus, indicated by the priority queue (PQ) containing only w. Nodes u, x, and v have confirmed shortest paths with solid lines leading to them, and their distances from the starting node u are marked as d=0, d=1, and d=2, respectively. Dashed lines suggest potential paths still under consideration.   "
},
{
  "id": "fig-dije",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dije",
  "type": "Figure",
  "number": "9.20.6",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   This step in Dijkstra's Algorithm shows node w with a confirmed shortest path from the starting node (d=3). The priority queue (PQ) at the bottom now contains only node z. The graph is further resolved with nodes u, x, v, and y having confirmed shortest paths, displayed with solid lines and distances marked. The algorithm's process is nearing completion, with almost all nodes having the shortest paths determined.   "
},
{
  "id": "fig-dijf",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#fig-dijf",
  "type": "Figure",
  "number": "9.20.7",
  "title": "",
  "body": " Tracing Dijkstra's Algorithm.   The final image depicts the weighted graph after the completion of Dijkstra's Algorithm. All nodes have confirmed shortest paths from the starting node u, which are shown with solid lines. The priority queue (PQ) is now empty, indicating that the algorithm has finished running. Each node has a definitive shortest distance from u (d=0, d=1, d=2, d=3, etc.), and the pathfinding process is complete, showcasing the algorithm's effectiveness in solving the shortest path problem.   "
},
{
  "id": "dijkstraq1",
  "level": "2",
  "url": "graphs_dijkstras-algorithm.html#dijkstraq1",
  "type": "Reading Question",
  "number": "9.20.1",
  "title": "",
  "body": " What purpose does the Priority Queue in the Dijkstra's algorithm serve?     It only holds a series of vertices to traverse.    Not quite, Priority Queues serve a purpose beyond storage.      It holds an unsorted list of unvisited vertices.    No, the vertices will be sorted.      It notes what vertices have been visited.    No, it does not store any visited vertices.      It holds an appropriately sorted list of vertices to traverse.    Correct!    "
},
{
  "id": "graphs_analysis-of-dijkstras-algorithm",
  "level": "1",
  "url": "graphs_analysis-of-dijkstras-algorithm.html",
  "type": "Section",
  "number": "9.21",
  "title": "Analysis of Dijkstra’s Algorithm",
  "body": " Analysis of Dijkstra's Algorithm  Finally, let us look at the running time of Dijkstra's algorithm. We first note that building the priority queue takes time since we initially add every vertex in the graph to the priority queue. Once the queue is constructed the while loop is executed once for every vertex since vertices are all added at the beginning and only removed after that. Within that loop each call to delMin , takes time. Taken together that part of the loop and the calls to delMin take . The for loop is executed once for each edge in the graph, and within the for loop the call to decreaseKey takes time So the combined running time is  "
},
{
  "id": "graphs_prims-spanning-tree-algorithm",
  "level": "1",
  "url": "graphs_prims-spanning-tree-algorithm.html",
  "type": "Section",
  "number": "9.22",
  "title": "Prim’s Spanning Tree Algorithm",
  "body": " Prim's Spanning Tree Algorithm  For our last graph algorithm let's consider a problem that online game designers and Internet radio providers face. The problem is that they want to efficiently transfer a piece of information to anyone and everyone who may be listening. This is important in gaming so that all the players know the very latest position of every other player. This is important for Internet radio so that all the listeners that are tuned in are getting all the data they need to reconstruct the song they are listening to. illustrates the broadcast problem.   The Broadcast Problem.   The image illustrates a network graph representing the Broadcast Problem. It features seven nodes labeled A through G, with node A designated as the broadcast host. Directed edges connect the nodes, indicating the flow of the broadcast signal, with weights on the edges representing the cost or time of transmission. Four of the nodes are marked as listeners, depicted with computer icons. These listeners are at the terminus of the broadcast paths, showing the direction and flow of information from the host to the listeners through the network.    There are some brute force solutions to this problem, so let's look at them first to help understand the broadcast problem better. This will also help you appreciate the solution that we will propose when we are done. To begin, the broadcast host has some information that the listeners all need to receive. The simplest solution is for the broadcasting host to keep a list of all of the listeners and send individual messages to each. In we show a small network with a broadcaster and some listeners. Using this first approach, four copies of every message would be sent. Assuming that the least cost path is used, let's see how many times each router would handle the same message.  All messages from the broadcaster go through router A, so A sees all four copies of every message. Router C sees only one copy of each message for its listener. However, routers B and D would see three copies of every message since routers B and D are on the cheapest path for listeners 1, 2, and 3. When you consider that the broadcast host must send hundreds of messages each second for a radio broadcast, that is a lot of extra traffic.  uncontrolled flooding A brute force solution is for the broadcast host to send a single copy of the broadcast message and let the routers sort things out. In this case, the easiest solution is a strategy called uncontrolled flooding . The flooding strategy works as follows. Each message starts with a time to live ( ttl ) value set to some number greater than or equal to the number of edges between the broadcast host and its most distant listener. Each router gets a copy of the message and passes the message on to all of its neighboring routers. When the message is passed on the ttl is decreased. Each router continues to send copies of the message to all its neighbors until the ttl value reaches 0. It is easy to convince yourself that uncontrolled flooding generates many more unnecessary messages than our first strategy.  minimum weight spanning tree The solution to this problem lies in the construction of a minimum weight spanning tree . Formally we define the minimum spanning tree for a graph as follows. is an acyclic subset of that connects all the vertices in . The sum of the weights of the edges in T is minimized.  shows a simplified version of the broadcast graph and highlights the edges that form a minimum spanning tree for the graph. Now to solve our broadcast problem, the broadcast host simply sends a single copy of the broadcast message into the network. Each router forwards the message to any neighbor that is part of the spanning tree, excluding the neighbor that just sent it the message. In this example A forwards the message to B. B forwards the message to D and C. D forwards the message to E, which forwards it to F, which forwards it to G. No router sees more than one copy of any message, and all the listeners that are interested see a copy of the message.   Minimum Spanning Tree for the Broadcast Graph.   This image depicts a network graph titled \"Minimum Spanning Tree for the Broadcast Graph\". It consists of seven circular nodes labeled A through G, connected by lines which represent the edges of the tree. Each edge is marked with a number indicating the weight or cost associated with that connection. The structure is tree-like, with no cycles, starting from node A and branching out to all other nodes through the path of minimum total weight. Nodes B, C, E, F, and G are connected with the least number of edges to ensure coverage of the entire network, illustrating the concept of a minimum spanning tree in graph theory.    The algorithm we will use to solve this problem is called Prim's algorithm. Prim's algorithm belongs to a family of algorithms called the greedy algorithms because at each step we will choose the cheapest next step. In this case the cheapest next step is to follow the edge with the lowest weight. Our last step is to develop Prim's algorithm.  The basic idea in constructing a spanning tree is as follows:  While T is not yet a spanning tree Find an edge that is safe to add to the tree Add the new edge to T  The trick is in the step that directs us to find an edge that is safe. We define a safe edge as any edge that connects a vertex that is in the spanning tree to a vertex that is not in the spanning tree. This ensures that the tree will always remain a tree and therefore have no cycles.  The Python code to implement Prim's algorithm is shown in Listing 2 . Prim's algorithm is similar to Dijkstra's algorithm in that they both use a priority queue to select the next vertex to add to the growing graph.  Listing 2  from pythonds.graphs import PriorityQueue, Graph, Vertex def prim(G,start): pq = PriorityQueue() for v in G: v.setDistance(sys.maxsize) v.setPred(None) start.setDistance(0) pq.buildHeap([(v.getDistance(),v) for v in G]) while not pq.isEmpty(): currentVert = pq.delMin() for nextVert in currentVert.getConnections(): newCost = currentVert.getWeight(nextVert) if nextVert in pq and newCost<nextVert.getDistance(): nextVert.setPred(currentVert) nextVert.setDistance(newCost) pq.decreaseKey(nextVert,newCost)  The following sequence of figures ( through ) shows the algorithm in operation on our sample tree. We begin with the starting vertex as A. The distances to all the other vertices are initialized to infinity. Looking at the neighbors of A we can update distances to two of the additional vertices B and C because the distances to B and C through A are less than infinite. This moves B and C to the front of the priority queue. Update the predecessor links for B and C by setting them to point to A. It is important to note that we have not formally added B or C to the spanning tree yet. A node is not considered to be part of the spanning tree until it is removed from the priority queue.  Since B has the smallest distance we look at B next. Examining B's neighbors we see that D and E can be updated. Both D and E get new distance values and their predecessor links are updated. Moving on to the next node in the priority queue we find C. The only node C is adjacent to that is still in the priority queue is F, thus we can update the distance to F and adjust F's position in the priority queue.  Now we examine the vertices adjacent to node D. We find that we can update E and reduce the distance to E from 6 to 4. When we do this we change the predecessor link on E to point back to D, thus preparing it to be grafted into the spanning tree but in a different location. The rest of the algorithm proceeds as you would expect, adding each new node to the tree.   Tracing Prim's Algorithm.   This image illustrates the process of Prim's algorithm applied to a graph. The graph has seven circular nodes labeled A through G, connected by lines with numbers indicating the weight of the edges. The algorithm starts at node A and progressively selects the edge with the lowest weight that connects a node inside the tree to a node outside the tree. As a result, the nodes are incrementally connected in a way that keeps the total weight of the tree at a minimum. The letters B, C, D, E, F, and G at the bottom signify the order in which the nodes are added to the growing tree.     Tracing Prim's Algorithm.   The image continues to detail Prim's algorithm, showing a partially completed minimum spanning tree. Nodes A, B, C, E, and F are connected with the shortest edges, marked with their respective weights and dashed lines indicating the edges considered at the current step. The remaining nodes D and G are yet to be connected. The bottom notation \"PQ = C, D, E, F, G\" lists the nodes in the priority queue awaiting to be connected.     Tracing Prim's Algorithm.   The final image in the sequence demonstrates a further step in Prim's algorithm. The minimum spanning tree now includes all nodes except for G, which is about to be connected. The edges between the nodes are highlighted, and the weights are updated to reflect the shortest paths from the tree to the remaining unconnected nodes. The bottom notation \"PQ = D, E, F, G\" updates the priority queue.     Tracing Prim's Algorithm.   This image shows a further stage in Prim's algorithm on a graph with seven nodes labeled A through G. The tree is almost complete, with solid lines connecting nodes A to F, and node G about to be connected. Each connection is annotated with the weight of the edge. The priority queue at the bottom, \"PQ = E, F, G,\" lists the nodes considered for the next connection step.     Tracing Prim's Algorithm.   The image depicts the penultimate step in Prim's algorithm, where node G is the only one not yet included in the minimum spanning tree. The graph shows nodes A to F connected with the lowest weight edges, and the priority queue \"PQ = F, G\" indicates the next nodes to be considered for connection.     Tracing Prim's Algorithm.   IThe final image represents the completion of Prim's algorithm, where all nodes A through G are connected, forming the minimum spanning tree. Each edge's weight is displayed, reflecting the algorithm's choice of the shortest paths to connect all nodes without forming any cycles. The priority queue at the bottom, \"PQ = G,\" shows the last node that was connected to complete the tree.     Tracing Prim's Algorithm.   This image shows the final step of Prim's algorithm where the minimum spanning tree is completed. All the nodes labeled from A to G are connected with the shortest paths indicated by the edge weights. The distances from the starting node are labeled next to each node with the letter 'd' followed by the distance value. The priority queue (PQ) is empty, indicating that all nodes have been visited and the algorithm is complete.     Reading Question    Tracing Prim's Algorithm.   Undirected graph with five nodes labeled A to E. Edges connect the nodes with the following weights: A-B with 1, A-D with 4, B-C with 2, C-D with 3, D-E with 6, and C-E with 5, forming a pentagon shape with a cross-connection between B and D.    Beginning at node E, how will Prim's algorithm span across the graph?     {E, D, A, B, C}    Not quite, remember, this is a is a greedy algorithm, so it will try to choose the cheapest next step.      {E, C, B, A, D}    Correct!      {E, C, B, D, A}    Not quite, try again!      Both B and C    No, there is only one correct answer!      "
},
{
  "id": "fig-bcast1",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-bcast1",
  "type": "Figure",
  "number": "9.22.1",
  "title": "",
  "body": " The Broadcast Problem.   The image illustrates a network graph representing the Broadcast Problem. It features seven nodes labeled A through G, with node A designated as the broadcast host. Directed edges connect the nodes, indicating the flow of the broadcast signal, with weights on the edges representing the cost or time of transmission. Four of the nodes are marked as listeners, depicted with computer icons. These listeners are at the terminus of the broadcast paths, showing the direction and flow of information from the host to the listeners through the network.   "
},
{
  "id": "graphs_prims-spanning-tree-algorithm-6",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#graphs_prims-spanning-tree-algorithm-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "uncontrolled flooding "
},
{
  "id": "graphs_prims-spanning-tree-algorithm-7",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#graphs_prims-spanning-tree-algorithm-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "spanning tree "
},
{
  "id": "fig-mst1",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-mst1",
  "type": "Figure",
  "number": "9.22.2",
  "title": "",
  "body": " Minimum Spanning Tree for the Broadcast Graph.   This image depicts a network graph titled \"Minimum Spanning Tree for the Broadcast Graph\". It consists of seven circular nodes labeled A through G, connected by lines which represent the edges of the tree. Each edge is marked with a number indicating the weight or cost associated with that connection. The structure is tree-like, with no cycles, starting from node A and branching out to all other nodes through the path of minimum total weight. Nodes B, C, E, F, and G are connected with the least number of edges to ensure coverage of the entire network, illustrating the concept of a minimum spanning tree in graph theory.   "
},
{
  "id": "graphs_prims-spanning-tree-algorithm-14",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#graphs_prims-spanning-tree-algorithm-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Listing 2 "
},
{
  "id": "fig-prima",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-prima",
  "type": "Figure",
  "number": "9.22.3",
  "title": "",
  "body": " Tracing Prim's Algorithm.   This image illustrates the process of Prim's algorithm applied to a graph. The graph has seven circular nodes labeled A through G, connected by lines with numbers indicating the weight of the edges. The algorithm starts at node A and progressively selects the edge with the lowest weight that connects a node inside the tree to a node outside the tree. As a result, the nodes are incrementally connected in a way that keeps the total weight of the tree at a minimum. The letters B, C, D, E, F, and G at the bottom signify the order in which the nodes are added to the growing tree.   "
},
{
  "id": "fig-primb",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-primb",
  "type": "Figure",
  "number": "9.22.4",
  "title": "",
  "body": " Tracing Prim's Algorithm.   The image continues to detail Prim's algorithm, showing a partially completed minimum spanning tree. Nodes A, B, C, E, and F are connected with the shortest edges, marked with their respective weights and dashed lines indicating the edges considered at the current step. The remaining nodes D and G are yet to be connected. The bottom notation \"PQ = C, D, E, F, G\" lists the nodes in the priority queue awaiting to be connected.   "
},
{
  "id": "fig-primc",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-primc",
  "type": "Figure",
  "number": "9.22.5",
  "title": "",
  "body": " Tracing Prim's Algorithm.   The final image in the sequence demonstrates a further step in Prim's algorithm. The minimum spanning tree now includes all nodes except for G, which is about to be connected. The edges between the nodes are highlighted, and the weights are updated to reflect the shortest paths from the tree to the remaining unconnected nodes. The bottom notation \"PQ = D, E, F, G\" updates the priority queue.   "
},
{
  "id": "fig-primd",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-primd",
  "type": "Figure",
  "number": "9.22.6",
  "title": "",
  "body": " Tracing Prim's Algorithm.   This image shows a further stage in Prim's algorithm on a graph with seven nodes labeled A through G. The tree is almost complete, with solid lines connecting nodes A to F, and node G about to be connected. Each connection is annotated with the weight of the edge. The priority queue at the bottom, \"PQ = E, F, G,\" lists the nodes considered for the next connection step.   "
},
{
  "id": "fig-prime",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-prime",
  "type": "Figure",
  "number": "9.22.7",
  "title": "",
  "body": " Tracing Prim's Algorithm.   The image depicts the penultimate step in Prim's algorithm, where node G is the only one not yet included in the minimum spanning tree. The graph shows nodes A to F connected with the lowest weight edges, and the priority queue \"PQ = F, G\" indicates the next nodes to be considered for connection.   "
},
{
  "id": "fig-primf",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-primf",
  "type": "Figure",
  "number": "9.22.8",
  "title": "",
  "body": " Tracing Prim's Algorithm.   IThe final image represents the completion of Prim's algorithm, where all nodes A through G are connected, forming the minimum spanning tree. Each edge's weight is displayed, reflecting the algorithm's choice of the shortest paths to connect all nodes without forming any cycles. The priority queue at the bottom, \"PQ = G,\" shows the last node that was connected to complete the tree.   "
},
{
  "id": "fig-primg",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#fig-primg",
  "type": "Figure",
  "number": "9.22.9",
  "title": "",
  "body": " Tracing Prim's Algorithm.   This image shows the final step of Prim's algorithm where the minimum spanning tree is completed. All the nodes labeled from A to G are connected with the shortest paths indicated by the edge weights. The distances from the starting node are labeled next to each node with the letter 'd' followed by the distance value. The priority queue (PQ) is empty, indicating that all nodes have been visited and the algorithm is complete.   "
},
{
  "id": "primswhims",
  "level": "2",
  "url": "graphs_prims-spanning-tree-algorithm.html#primswhims",
  "type": "Reading Question",
  "number": "9.22.1",
  "title": "",
  "body": "  Tracing Prim's Algorithm.   Undirected graph with five nodes labeled A to E. Edges connect the nodes with the following weights: A-B with 1, A-D with 4, B-C with 2, C-D with 3, D-E with 6, and C-E with 5, forming a pentagon shape with a cross-connection between B and D.    Beginning at node E, how will Prim's algorithm span across the graph?     {E, D, A, B, C}    Not quite, remember, this is a is a greedy algorithm, so it will try to choose the cheapest next step.      {E, C, B, A, D}    Correct!      {E, C, B, D, A}    Not quite, try again!      Both B and C    No, there is only one correct answer!    "
},
{
  "id": "graphs_summary",
  "level": "1",
  "url": "graphs_summary.html",
  "type": "Section",
  "number": "9.23",
  "title": "Summary",
  "body": " Summary  In this chapter we have looked at the graph abstract data type, and some implementations of a graph. A graph enables us to solve many problems provided we can transform the original problem into something that can be represented by a graph. In particular, we have seen that graphs are useful to solve problems in the following general areas.    Breadth first search for finding the unweighted shortest path.    Dijkstra's algorithm for weighted shortest path.    Depth first search for graph exploration.    Strongly connected components for simplifying a graph.    Topological sort for ordering tasks.    Minimum weight spanning trees for broadcasting messages.    "
},
{
  "id": "graphs_discussion-questions",
  "level": "1",
  "url": "graphs_discussion-questions.html",
  "type": "Section",
  "number": "9.24",
  "title": "Discussion Questions",
  "body": " Discussion Questions    Draw the graph corresponding to the following adjacency matrix.     Adjacency matrix.   Adjacency matrix with weighted edges between nodes A to F. A connects to B with 7, to E with 5, and to F with 1. B connects to A with 2, to D with 7, and to E with 3. C connects to B with 2 and to F with 8. D connects to A with 1, to C with 2, and to E with 4. E connects to A with 6 and to C with 5. F connects to A with 1 and to C with 8.      Draw the graph corresponding to the following list of edges.    from  to  cost    1  2  10    1  3  15    1  6  5    2  3  7    3  4  7    3  6  10    4  5  7    6  4  5    5  6  13      Ignoring the weights, perform a breadth first search on the graph from the previous question.    What is the Big-O running time of the buildGraph function?    Derive the Big-O running time for the topological sort algorithm.    Derive the Big-O running time for the strongly connected components algorithm.    Show each step in applying Dijkstra's algorithm to the graph shown above.    Using Prim's algorithm, find the minimum weight spanning tree for the graph shown above.    Draw a dependency graph illustrating the steps needed to send an email. Perform a topological sort on your graph.    Derive an expression for the base of the exponent used in expressing the running time of the knights tour.    Explain why the general DFS algorithm is not suitable for solving the knights tour problem.    What is the Big-O running time for Prim's minimum spanning tree algorithm?    "
},
{
  "id": "fig-adjMatEX",
  "level": "2",
  "url": "graphs_discussion-questions.html#fig-adjMatEX",
  "type": "Figure",
  "number": "9.24.1",
  "title": "",
  "body": " Adjacency matrix.   Adjacency matrix with weighted edges between nodes A to F. A connects to B with 7, to E with 5, and to F with 1. B connects to A with 2, to D with 7, and to E with 3. C connects to B with 2 and to F with 8. D connects to A with 1, to C with 2, and to E with 4. E connects to A with 6 and to C with 5. F connects to A with 1 and to C with 8.   "
},
{
  "id": "graphs_discussion-questions-4-1-1-2",
  "level": "2",
  "url": "graphs_discussion-questions.html#graphs_discussion-questions-4-1-1-2",
  "type": "Table",
  "number": "9.24.2",
  "title": "",
  "body": "  from  to  cost    1  2  10    1  3  15    1  6  5    2  3  7    3  4  7    3  6  10    4  5  7    6  4  5    5  6  13   "
},
{
  "id": "graphs_programming-exercises",
  "level": "1",
  "url": "graphs_programming-exercises.html",
  "type": "Section",
  "number": "9.25",
  "title": "Programming Exercises",
  "body": " Programming Exercises    Modify the depth first search function to produce a topological sort.    Modify the depth first search to produce strongly connected components.    Write the transpose method for the Graph class.    Using breadth first search write an algorithm that can determine the shortest path from each vertex to every other vertex. This is called the all pairs shortest path problem.    Using breadth first search revise the maze program from the recursion chapter to find the shortest path out of a maze.    Write a program to solve the following problem: You have two jugs, a 4-gallon and a 3-gallon. Neither of the jugs has markings on them. There is a pump that can be used to fill the jugs with water. How can you get exactly two gallons of water in the 4 gallon jug?    Generalize the problem above so that the parameters to your solution include the sizes of each jug and the final amount of water to be left in the larger jug.    Write a program that solves the following problem: Three missionaries and three cannibals come to a river and find a boat that holds two people. Everyone must get across the river to continue on the journey. However, if the cannibals ever outnumber the missionaries on either bank, the missionaries will be eaten. Find a series of crossings that will get everyone safely to the other side of the river.    "
},
{
  "id": "graphs_glossary",
  "level": "1",
  "url": "graphs_glossary.html",
  "type": "Section",
  "number": "9.26",
  "title": "Glossary",
  "body": " Glossary    acyclic graph  A graph with no cycles.    adjacency list  A list implementation where we keep a master list of all the vertices in the Graph object and then each vertex object in the graph maintains a list of the other vertices that it is connected to.    adjacency matrix  A matrix implementation where each of the rows and columns represent a vertex in the graph, and where if two vertices are connected by an edge, they are considered adjacent.    adjacent  When two vertices are connected by an edge.    breadth first search (BFS)  A search that proceeds to look through the edges in a graph to find all the vertices in that graph for which there is a path from the starting point.    cycle  A cycle in a directed graph is a path that starts and ends at the same vertex.    cyclic graph  A graph with at least one cycle in it.    depth first forest  The result of the groups of trees produced by a depth first search algorithm.    depth first search (DFS)  A search type where the goal is to create the deepest depth first tree, without any branches.    digraph  see directed graph.    directed acyclic graph (DAG)  A directed acyclic graph, which is a directed graph with no cycles.    directed graph  A graph in which all the edges are one-way.    edge cost  The weight associated with an arc in a graph.    edge  An edge (also called an arc ) connects two vertices to show that there is a relationship between them. Edges may be one-way or two-way.    parenthesis property  All the children of a particular node in the depth first tree have a later discovery time and an earlier finish time than their parent.    path  A path in a graph is a sequence of vertices that are connected by edges.    shortest path  The most succinct passage from one edge to another.    spanning tree  An acyclic subset of edges that connects all the vertices.    strongly connected components (SCC)  The largest subset of vertices C⊂V such that for every pair of vertices v,w∈C we have a path from v to w and a path from w to v.    topological sorting  A topological sort takes a directed acyclic graph and produces a linear ordering of all its vertices such that if the graph G contains an edge (v,w) then the vertex v comes before the vertex w in the ordering.    uncontrolled flooding  Each message starts with a time to live ( ttl ) value set to some number greater than or equal to the number of edges between the broadcast host and its most distant listener. Each router gets a copy of the message and passes the message on to all of its neighboring routers. When the message is passed on the ttl is decreased. Each router continues to send copies of the message to all its neighbors until the ttl value reaches 0.    vertex  A vertex (also called a node ) is a fundamental part of a graph. It can have a name (also called a Key ). A vertex may also have additional information also called a ( payload ).    weight  Shows that there is a cost to go from one vertex to another.    "
},
{
  "id": "graphs_graphs_matching",
  "level": "1",
  "url": "graphs_graphs_matching.html",
  "type": "Section",
  "number": "9.27",
  "title": "Matching",
  "body": " Matching   Drag the word on the left to its corresponding definition (Note not all words in the glossary are here)   Look at your glossary    weight  Shows that there is a cost to go from one vertex to another    breadth first search (BFS)  A search that proceeds to look through the edges in a graph to find all the vertices in that graph for which there is a path from the starting point.    cycle  In a directed graph, a path that starts and ends at the same vertex.    depth first search (DFS)  A search type where the goal is to create the deepest tree first, without any branches.    adjacency matrix  A matrix implementation where each of the rows and columns represent a vertex in the graph, and where if two vertices are connected by an edge, they are considered adjacent.    vertex  Also called a “node” this is a fundamental part of a graph. It can have a “key.” This may also have additional information. We will call this additional information the “payload.”    spanning tree  An acyclic subset of edges that connects all the vertices.    path  A sequence of vertices that are connected by edges.    parenthesis property  All the children of a particular node in the depth first tree have a later discovery time and an earlier finish time than their parent.    edge cost  The weight associated with an arc in a graph.    edge  An “arc” connects two vertices to show that there is a relationship between them and it may be one-way or two-way.    directed graph  A graph in which all the edges are one-way.    adjacency list  A list implementation where we keep a master list of all the vertices in the Graph object and then each vertex object in the graph maintains a list of the other vertices that it is connected to.    "
},
{
  "id": "matching_graphs",
  "level": "2",
  "url": "graphs_graphs_matching.html#matching_graphs",
  "type": "Checkpoint",
  "number": "9.27.1",
  "title": "",
  "body": " Drag the word on the left to its corresponding definition (Note not all words in the glossary are here)   Look at your glossary    weight  Shows that there is a cost to go from one vertex to another    breadth first search (BFS)  A search that proceeds to look through the edges in a graph to find all the vertices in that graph for which there is a path from the starting point.    cycle  In a directed graph, a path that starts and ends at the same vertex.    depth first search (DFS)  A search type where the goal is to create the deepest tree first, without any branches.    adjacency matrix  A matrix implementation where each of the rows and columns represent a vertex in the graph, and where if two vertices are connected by an edge, they are considered adjacent.    vertex  Also called a “node” this is a fundamental part of a graph. It can have a “key.” This may also have additional information. We will call this additional information the “payload.”    spanning tree  An acyclic subset of edges that connects all the vertices.    path  A sequence of vertices that are connected by edges.    parenthesis property  All the children of a particular node in the depth first tree have a later discovery time and an earlier finish time than their parent.    edge cost  The weight associated with an arc in a graph.    edge  An “arc” connects two vertices to show that there is a relationship between them and it may be one-way or two-way.    directed graph  A graph in which all the edges are one-way.    adjacency list  A list implementation where we keep a master list of all the vertices in the Graph object and then each vertex object in the graph maintains a list of the other vertices that it is connected to.   "
},
{
  "id": "cppds2-12-1",
  "level": "1",
  "url": "cppds2-12-1.html",
  "type": "Index",
  "number": "",
  "title": "Index",
  "body": "  "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')
  this.metadataWhitelist = ['position']

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
