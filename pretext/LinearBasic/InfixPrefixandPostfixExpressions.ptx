<?xml version="1.0" ?><section xml:id="linear-basic_infix-prefix-and-postfix-expressions">
        <title>Infix, Prefix and Postfix Expressions</title>
    <introduction>
    <definition xml:id="def-infix-expression">
    <idx>infix expression</idx>
      <statement>
       <p>
        An <term>infix expression</term> is a standard mathematical notation in which operators are written between the operands they act on. It is the most commonly used expression format in most programming languages, including C++. In this format, the operator is placed between the two operands. For example, the addition of two numbers a and b is represented as a + b.

        Example: (a + b) * c
       </p>
      </statement>
    </definition>
        <p>When you write an arithmetic expression such as B * C, the form of the
            expression provides you with information so that you can interpret it
            correctly. In this case we know that the variable B is being multiplied
            by the variable C since the multiplication operator * appears between
            them in the expression. This type of notation is referred to as
            <term>infix</term> since the operator is <em>in between</em> the two operands that it is
            working on.</p>
        <p>Consider another infix example, A + B * C. The operators + and * still
            appear between the operands, but there is a problem. Which operands do
            they work on first? Does the + work on A and B or does the * take B and C?
            The expression seems ambiguous.</p>
        <p>In fact, you have been reading and writing these types of expressions
            for a long time and they do not cause you any problem. The reason for
            this is that you know something about the operators + and *. Each
            operator has a <term>precedence</term> level. Operators of higher precedence are
            used before operators of lower precedence. The only thing that can
            change that order is the presence of parentheses. The precedence order
            for arithmetic operators places multiplication and division above
            addition and subtraction. If two operators of equal precedence appear,
            then a left-to-right ordering or associativity is used.</p>
        <p>Let's interpret the troublesome expression A + B * C using operator
            precedence. B and C are multiplied first, and A is then added to that
            result. (A + B) * C would force the addition of A and B to be done
            first before the multiplication. In expression A + B + C, by precedence
            (via associativity), the leftmost + would be done first.</p>
        <p>Although all this may be obvious to you, remember that computers need to
            know exactly what operators to perform and in what order. One way to
            write an expression that guarantees there will be no confusion with
            respect to the order of operations is to create what is called a <term>fully
                parenthesized</term> expression. This type of expression uses one pair of
            parentheses for each operator. The parentheses dictate the order of
            operations; there is no ambiguity. There is also no need to remember any
            precedence rules.</p>
        <p>The expression A + B * C + D can be rewritten as ((A + (B * C)) + D)
            to show that the multiplication happens first, followed by the leftmost
            addition. A + B + C + D can be written as (((A + B) + C) + D) since the
            addition operations associate from left to right.</p>
        <p>There are two other very important expression formats that may not seem
            obvious to you at first. Consider the infix expression A + B. What would
            happen if we moved the operator before the two operands? The resulting
            expression would be + A B. Likewise, we could move the operator to the
            end. We would get A B +. These look a bit strange.</p>
        <p>These changes to the position of the operator with respect to the
            operands create two new expression formats, <term>prefix</term> and <term>postfix</term>.
            Prefix expression notation requires that all operators precede the two
            operands that they work on. Postfix, on the other hand, requires that
            its operators come after the corresponding operands. A few more examples
            should help to make this a bit clearer (see <xref ref="linear-basic_xfix_examples"/>).</p>
        <p>In prefix, A + B * C would be written as + A * B C . The multiplication
            operator comes immediately before the operands B and C, denoting that *
            has precedence over +. The addition operator then appears before the A
            and the result of the multiplication.</p>
        <p>In postfix, the expression  A + B * C would be A B C * +. Again, the order of
            operations is preserved since the * appears immediately after the B and
            the C, denoting that * has precedence, with + coming after. Although
            the operators moved and now appear either before or after their
            respective operands, the order of the operands stayed exactly the same
            relative to one another.</p>
        
        <table xml:id="linear-basic_xfix_examples">
            <title>Examples of Infix, Prefix, and Postfix</title>
            <tabular>
                    <row header="yes">
                        <cell>
                            <term>Infix Expression</term>
                        </cell>
                        <cell>
                            <term>Prefix Expression</term>
                        </cell>
                        <cell>
                            <term>Postfix Expression</term>
                        </cell>
                    </row>
                
                
                    <row>
                        <cell>
                            A + B
                        </cell>
                        <cell>
                            + A B
                        </cell>
                        <cell>
                            A B +
                        </cell>
                    </row>
                    <row>
                        <cell>
                            A + B * C
                        </cell>
                        <cell>
                            + A * B C
                        </cell>
                        <cell>
                            A B C * +
                        </cell>
                    </row>
                
            
        </tabular></table>
        <p>Now consider the infix expression (A + B) * C. Recall that in this
            case, infix requires the parentheses to force the performance of the
            addition before the multiplication. However, when A + B was written in
            prefix, the addition operator was simply moved before the operands, + A
            B. The result of this operation becomes the first operand for the
            multiplication. The multiplication operator is moved in front of the
            entire expression, giving us * + A B C. Likewise, in postfix A B +
            forces the addition to happen first. The multiplication can be done to
            that result and the remaining operand C. The proper postfix expression
            is then A B + C *.</p>
        <p>Consider these three expressions again (see <xref ref="linear-basic_tbl-parexample"/>).
            Something very important has happened. Where did the parentheses go? Why
            don't we need them in prefix and postfix? The answer is that the
            operators are no longer ambiguous with respect to the operands that they
            work on. Only infix notation requires the additional symbols. The order
            of operations within prefix and postfix expressions is completely
            determined by the position of the operator and nothing else. In many
            ways, this makes infix the least desirable notation to use.</p>
        
        <table xml:id="linear-basic_tbl-parexample">
            <title>An Expression with Parentheses</title>
            <tabular>
                    <row header="yes">
                        <cell>
                            <term>Infix Expression</term>
                        </cell>
                        <cell>
                            <term>Prefix Expression</term>
                        </cell>
                        <cell>
                            <term>Postfix Expression</term>
                        </cell>
                    </row>
                
                
                    <row>
                        <cell>
                            (A + B) * C
                        </cell>
                        <cell>
                            * + A B C
                        </cell>
                        <cell>
                            A B + C *
                        </cell>
                    </row>
                
            
        </tabular></table>
        <p><xref ref="linear-basic_tbl-example3"/> shows some additional examples of infix expressions and
            the equivalent prefix and postfix expressions. Be sure that you
            understand how they are equivalent in terms of the order of the
            operations being performed.</p>
        
        <table xml:id="linear-basic_tbl-example3">
            <title>Additional Examples of Infix, Prefix, and Postfix</title>
            <tabular>
            
                
                
                
                
                    <row header="yes">
                        <cell>
                            <term>Infix Expression</term>
                        </cell>
                        <cell>
                            <term>Prefix Expression</term>
                        </cell>
                        <cell>
                            <term>Postfix Expression</term>
                        </cell>
                    </row>
                
                
                    <row>
                        <cell>
                            A + B * C + D
                        </cell>
                        <cell>
                            + + A * B C D
                        </cell>
                        <cell>
                            A B C * + D +
                        </cell>
                    </row>
                    <row>
                        <cell>
                            (A + B) * (C + D)
                        </cell>
                        <cell>
                            * + A B + C D
                        </cell>
                        <cell>
                            A B + C D + *
                        </cell>
                    </row>
                    <row>
                        <cell>
                            A * B + C * D
                        </cell>
                        <cell>
                            + * A B * C D
                        </cell>
                        <cell>
                            A B * C D * +
                        </cell>
                    </row>
                    <row>
                        <cell>
                            A + B + C + D
                        </cell>
                        <cell>
                            + + + A B C D
                        </cell>
                        <cell>
                            A B + C + D +
                        </cell>
                    </row>
                
            
        </tabular></table>
    </introduction>
        <subsection xml:id="linear-basic_conversion-of-infix-expressions-to-prefix-and-postfix">
            <title>Conversion of Infix Expressions to Prefix and Postfix</title>
            <definition xml:id="def-prefix-expression">
            <idx>prefix expression</idx>
            <statement>
            <p>
                A prefix expression, also known as Polish notation, is a mathematical notation in which every operator follows all of its operands. The primary advantage of prefix notation is that it completely eliminates the need for parentheses to indicate orders of operations. The order in which operations are to be performed is evident from the position of the operators and operands.

                Example: For the infix expression (a + b) * c, the corresponding prefix notation is * + a b c.


            </p>
            </statement>
            </definition>
            <p>So far, we have used ad hoc methods to convert between infix expressions
                and the equivalent prefix and postfix expression notations. As you might
                expect, there are algorithmic ways to perform the conversion that allow
                any expression of any complexity to be correctly transformed.</p>
            <p>The first technique that we will consider uses the notion of a fully
                parenthesized expression that was discussed earlier. Recall that A + B
                * C can be written as (A + (B * C)) to show explicitly that the
                multiplication has precedence over the addition. On closer observation,
                however, you can see that each parenthesis pair also denotes the
                beginning and the end of an operand pair with the corresponding operator
                in the middle.</p>
            <p>Look at the right parenthesis in the subexpression (B * C) above. If we
                were to move the multiplication symbol to that position and remove the
                matching left parenthesis, giving us B C *, we would in effect have
                converted the subexpression to postfix notation. If the addition
                operator were also moved to its corresponding right parenthesis position
                and the matching left parenthesis were removed, the complete postfix
                expression would result (see <xref ref="xfix_fig-moveright"/>).</p>
            
            <figure align="center" xml:id="xfix_fig-moveright">
                <caption>Moving Operators to the Right for Postfix Notation</caption>
                <image source="LinearBasic/moveright.png" width="50%"> 
                    <description>
                         <p>
                            The image shows an annotated mathematical expression illustrating the conversion of an infix expression A + (B * C) to postfix notation. 
                            Arrows indicate the movement of operators + and * to the right, near their corresponding right parentheses, resulting in B C * A +.
                        </p>
                    </description>                
                </image>
            </figure>
            <p>If we do the same thing but instead of moving the symbol to the position
                of the right parenthesis, we move it to the left, we get prefix notation
                (see <xref ref="xfix_fig-moveleft"/>). The position of the parenthesis pair is
                actually a clue to the final position of the enclosed operator.</p>
            
            <figure align="center" xml:id="xfix_fig-moveleft">
                <caption>Moving Operators to the Left for Prefix Notation</caption>
                <image source="LinearBasic/moveleft.png" width="50%"> 
                    <description>
                        <p>
                            The image shows an annotated mathematical expression illustrating the conversion of an infix expression A + (B * C) to prefix notation. 
                            Arrows indicate the movement of operators + and * to the left, near their corresponding left parentheses, resulting in + A * B C.
                        </p>
                    </description>
                </image>
            </figure>
            <p>So in order to convert an expression, no matter how complex, to either
                prefix or postfix notation, fully parenthesize the expression using the
                order of operations. Then move the enclosed operator to the position of
                either the left or the right parenthesis depending on whether you want
                prefix or postfix notation.</p>
            <p>Here is a more complex expression: (A + B) * C - (D - E) * (F + G).
                <xref ref="xfix_fig-complexmove"/> shows the conversion to postfix and prefix
                notations.</p>
            
            <figure align="center" xml:id="xfix_fig-complexmove">
                <caption>Converting a Complex Expression to Prefix and Postfix Notations</caption>
                <image source="LinearBasic/complexmove.png" width="50%">
                    <description>
                    <p>
                        The image illustrates the conversion of a complex infix expression (A + B) * C - (D - E) * (F + G) into both prefix and postfix notations. 
                        At the center, the fully parenthesized infix expression is displayed: (((A + B) * C) - ((D - E) * (F + G))). 
                        Two arrows branch out from the central expression. The first arrow points to the prefix notation, 
                        where the operators are moved to the left of their operands, resulting in:
                        <math display="inline">-*+A B C *-D E +F G</math>. 
                        The second arrow points to the postfix notation, where the operators are moved to the right of their operands, resulting in:
                        <math display="inline">A B + C * D E - F G + * -</math>. 
                        This image demonstrates how to systematically rearrange operators based on the desired notation by using the position of parentheses as a guide.
 
                    </p>
                    </description>
                </image>
            </figure>
   </subsection>
        <subsection xml:id="linear-basic_general-infix-to-postfix-conversion">
            <title>General Infix-to-Postfix Conversion</title>

            <definition xml:id="def-postfix-expression">
            <idx>postfix expression</idx>
            <statement>
            <p>
            A postfix expression, commonly known as Reverse Polish notation (RPN), is a mathematical notation in which every operator follows its operands. Postfix notation has the advantage of being able to represent a mathematical expression without the need for parentheses, which simplifies the algorithm to process the expression. The order of operations is determined by the position of the operator in relation to its operands.

            Example: For the infix expression (a + b) * c, the corresponding postfix notation is a b + c *.


            </p>
            </statement>
            </definition>
            <p>We need to develop an algorithm to convert any infix expression to a
                postfix expression. To do this we will look closer at the conversion
                process.</p>
            <p>Consider once again the expression A + B * C. As shown above,
                A B C * + is the postfix equivalent. We have already noted that the
                operands A, B, and C stay in their relative positions. It is only the
                operators that change position. Let's look again at the operators in the
                infix expression. The first operator that appears from left to right is
                +. However, in the postfix expression, + is at the end since the next
                operator, *, has precedence over addition. The order of the operators
                in the original expression is reversed in the resulting postfix
                expression.</p>
            <p>As we process the expression, the operators have to be saved somewhere
                since their corresponding right operands have not yet been seen. Additionally,
                because of their priority, the order of these saved operators might need
                to be changed, which is the case for the multiplication and addition in
                this example. Since the addition operator comes before the
                multiplication operator and has lower precedence, it needs to appear
                after the multiplication operator is used. Because of this reversal of
                order, it makes sense to consider using a stack to keep the operators
                until they are needed.</p>
            <p>What about (A + B) * C? Recall that A B + C * is the postfix
                equivalent. Again, processing this infix expression from left to right,
                we see + first. In this case, when we see *, + has already been placed
                in the result expression because it has precedence over * by virtue of
                the parentheses. We can now start to see how the conversion algorithm
                will work. When we see a left parenthesis, we will save it to denote
                that another operator of high precedence will be coming. That operator
                will need to wait until the corresponding right parenthesis appears to
                denote its position (recall the fully parenthesized technique). When
                that right parenthesis does appear, the operator can be popped from the
                stack.</p>
            <p>As we scan the infix expression from left to right, we will use a stack
                to keep the operators. This will provide the reversal that we noted in
                the first example. The top of the stack will always be the most recently
                saved operator. Whenever we read a new operator, we will need to
                consider how that operator compares in precedence with the operators, if
                any, already on the stack.</p>
            <p>Assume the infix expression is a string of tokens delimited by spaces.
                The operator tokens are *, /, +, and -, along with the left and right
                parentheses, ( and ). The operand tokens are the single-character
                identifiers A, B, C, and so on. The following steps will produce a
                string of tokens in postfix order.</p>
            <p><ol marker="1">
                <li>
                    <p>Create an empty stack called <c>opstack</c> for keeping operators.
                        Create an empty vector for output.</p>
                </li>
                <li>
                    <p>Scan the current token of the input vector from left to right (using a loop).</p>
                    <p><ul>
                        <li>
                            <p>If the token is an operand, append it to the end of the output
                                list(vector).</p>
                        </li>
                        <li>
                            <p>If the token is a left parenthesis, push it on the <c>opstack</c>.</p>
                        </li>
                        <li>
                            <p>If the token is a right parenthesis, pop the <c>opstack</c> until the
                                corresponding left parenthesis is removed. Append each operator to
                                the end of the output vector.</p>
                        </li>
                        <li>
                            <p>If the token is an operator, *, /, +, or -, push it on the
                                <c>opstack</c>. However, first remove any operators already on the
                                <c>opstack</c> that have higher or equal precedence and append them
                                to the output vector.</p>
                        </li>
                    </ul></p>
                </li>
                <li>
                    <p>When the input expression has been completely processed, check the
                        <c>opstack</c>. Any operators still on the stack can be removed and
                        appended to the end of the output vector.</p>
                </li>
            </ol></p>
            <p><xref ref="xfix_fig-intopost"/> shows the conversion algorithm working on the
                expression A * B + C * D. Note that the first * operator is removed
                upon seeing the + operator. Also, + stays on the stack when the second
                * occurs, since multiplication has precedence over addition. At the end
                of the infix expression the stack is popped twice, removing both
                operators and placing + as the last operator in the postfix expression.</p>
            
            <figure align="center" xml:id="xfix_fig-intopost">
                <caption>Converting A * B + C * D to Postfix Notation</caption>
                <image source="LinearBasic/intopost.png" width="50%">
                    <description>
                        <p>
                            The image visually represents the step-by-step conversion of the infix expression A * B + C * D into postfix notation. 
                            It shows the operands A, B, C, D being added directly to the output, while the operators * and + are temporarily stored in a stack. 
                            The process demonstrates how * is removed from the stack upon encountering +, due to operator precedence. 
                            Later, both * operators are popped, followed by +, resulting in the final postfix expression A B * C D * +. 
                            The diagram uses arrows to indicate the movement of operands and operators between the input, stack, and output.
                        </p>
                    </description>
                </image>
            </figure>
            <p>In order to code the algorithm in C++, we will use a hash map
                called <c>prec</c> to hold the precedence values for the operators
                which will be implemented with an unordered map.
                This hash map will map each operator char to an integer that can be compared
                against the precedence levels of other operators (we have arbitrarily
                used the integers 3, 2, and 1). The left parenthesis will receive the
                lowest value possible. This way any operator that is compared against it
                will have higher precedence and will be placed on top of it.
                Line 18 defines the operands to be any upper-case character or digit.
                The complete conversion function is
                shown in <xref ref="lst-intopost-cpp"/>.</p>
            
            <exploration xml:id="expl-lst-intopost-cpp">
                <title>Infix to Postfix Conversion</title>
                <task xml:id="lst-intopost-cpp" label="lst-intopost-cpp">
                    <title>C++ Implementation</title>
                    <statement><program xml:id="intpost_cpp" interactive="activecode" language="cpp" label="intpost_cpp-prog"><code>
//Converts an infix expression to a postfix expression.

#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

string infixToPostfix(string infixexpr) {
    //performs the postfix process.
    unordered_map &lt;char,int&gt; prec;
    prec['*']=3;
    prec['/']=3;
    prec['+']=2;
    prec['-']=2;
    prec['(']=1;
    stack&lt;char&gt; opStack;
    vector&lt;char&gt; postfixVector;
    string letsnums = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;

    for (char token:infixexpr) {
        //for each character in infixexpr
        if (token == ' ') {
            continue;
        }
        else if (letsnums.find(token)&lt;=letsnums.length()) { //finds if the token is inside of letsnums
            postfixVector.emplace_back(token); // appends to the end of the container.
        } else if (token == '(') {
            opStack.push(token);
        } else if (token == ')') {
            char topToken;
            topToken = opStack.top();
            opStack.pop();
            while (topToken != '(') {
                postfixVector.emplace_back(topToken);
                topToken=opStack.top();
                opStack.pop();
            }
        } else { //if the token is not inside of letsnums.
            while (!opStack.empty() &amp;&amp; (prec[opStack.top()]&gt;=prec[token])) //while the stack is not empty and
                                                                           //the top item of the stack is on a
                                                                           //higher level of PEMDAS than token.
            {
                postfixVector.emplace_back(opStack.top());
                opStack.pop();
                }
            opStack.push(token);
        }
    }
    while (!opStack.empty()) {
        postfixVector.emplace_back(opStack.top());
        opStack.pop();
    }

    string s(postfixVector.begin(),postfixVector.end());

    return s;
}

int main() {
    cout &lt;&lt;&quot;infix: A * B + C * D\n&quot; &lt;&lt; &quot;postfix: &quot;;
    cout &lt;&lt; infixToPostfix(&quot;A * B + C * D&quot;) &lt;&lt; endl;
    cout &lt;&lt; &quot;infix: ( A + B ) * C - ( D - E ) * ( F + G )\n&quot; &lt;&lt; &quot;postfix: &quot;;
    cout &lt;&lt; infixToPostfix(&quot;( A + B ) * C - ( D - E ) * ( F + G )&quot;) &lt;&lt; endl;

    return 0;
}
                    </code></program></statement>
                </task>
                <task xml:id="lst-intopost-py" label="lst-intopost-py">
                    <title>Python Implementation</title>
                    <statement><program xml:id="intopost" interactive="activecode" language="python" label="intopost-prog"><code>
#Converts an infix expression to a postfix expression.

from pythonds.basic.stack import Stack

def infixToPostfix(infixexpr):
    #performs the postfix process.
    prec = {}
    prec[&quot;*&quot;] = 3
    prec[&quot;/&quot;] = 3
    prec[&quot;+&quot;] = 2
    prec[&quot;-&quot;] = 2
    prec[&quot;(&quot;] = 1
    opStack = Stack()
    postfixList = []
    tokenList = infixexpr.split()

    for token in tokenList:
        #for each character in infixexpr
        if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and (prec[opStack.peek()] &gt;= prec[token]): #while the stack is not empty and
                                                                                     #the top item of the stack is on a
                                                                                     #higher level of PEMDAS than token.
                  postfixList.append(opStack.pop())
            opStack.push(token)

    while not opStack.isEmpty():
        postfixList.append(opStack.pop())
    return &quot; &quot;.join(postfixList)

def main():
    print(infixToPostfix(&quot;A * B + C * D&quot;))
    print(infixToPostfix(&quot;( A + B ) * C - ( D - E ) * ( F + G )&quot;))
main()
                    </code></program></statement>
                </task>
            </exploration>
            <transition/>
            <p>A few more results of execution are shown below.</p>
            <pre>&gt;&gt;&gt; infixtopostfix(&quot;( A + B ) * ( C + D )&quot;)
'A B + C D + *'
&gt;&gt;&gt; infixtopostfix(&quot;( A + B ) * C&quot;)
'A B + C *'
&gt;&gt;&gt; infixtopostfix(&quot;A + B * C&quot;)
'A B C * +'
&gt;&gt;&gt;</pre>
        </subsection>
        <subsection xml:id="linear-basic_postfix-evaluation">
            <title>Postfix Evaluation</title>
            <p>As a final stack example, we will consider the evaluation of an
                expression that is already in postfix notation. In this case, a stack is
                again the data structure of choice. However, as you scan the postfix
                expression, it is the operands that must wait, not the operators as in
                the conversion algorithm above. Another way to think about the solution
                is that whenever an operator is seen on the input, the two most recent
                operands will be used in the evaluation.</p>
            <p>To see this in more detail, consider the postfix expression
                <c>4 5 6 * +</c>. As you scan the expression from left to right, you first
                encounter the operands 4 and 5. At this point, you are still unsure what
                to do with them until you see the next symbol. Placing each on the stack
                ensures that they are available if an operator comes next.</p>
            <p>In this case, the next symbol is another operand. So, as before, push it
                and check the next symbol. Now we see an operator, *. This means that
                the two most recent operands need to be used in a multiplication
                operation. By popping the stack twice, we can get the proper operands
                and then perform the multiplication (in this case getting the result
                30).</p>
            <p>We can now handle this result by placing it back on the stack so that it
                can be used as an operand for the later operators in the expression.
                When the final operator is processed, there will be only one value left
                on the stack. Pop and return it as the result of the expression.
                <xref ref="xfix_fig-evalpost1"/> shows the stack contents as this entire example
                expression is being processed.</p>
            
            <figure align="center" xml:id="xfix_fig-evalpost1">
                <caption>Stack Contents During Evaluation</caption>
                <image source="LinearBasic/evalpostfix1.png" width="50%"> 
                    <description>
                        <p>
                            The image illustrates the step-by-step evaluation of the postfix expression 4 5 6 * + using a stack. 
                            The evaluation is performed from left to right. Initially, the operands 4, 5, and 6 are pushed onto the stack in sequence. 
                            When the multiplication operator (*) is encountered, the two most recent operands (5 and 6) are popped from the stack, 
                            multiplied to produce 30, and the result is pushed back onto the stack. Next, the addition operator (+) is processed. 
                            The two most recent values (4 and 30) are popped, added to produce 34, and the result is pushed back onto the stack. 
                            The diagram uses arrows and labeled stack snapshots to show the changes at each step, culminating in the final result of 34.
                        </p>
                    </description>
                </image>
            </figure>
            <p><xref ref="xfix_fig-evalpost2"/> shows a slightly more complex example, 7 8 + 3 2
                + /. There are two things to note in this example. First, the stack size
                grows, shrinks, and then grows again as the subexpressions are
                evaluated. Second, the division operation needs to be handled carefully.
                Recall that the operands in the postfix expression are in their original
                order since postfix changes only the placement of operators. When the
                operands for the division are popped from the stack, they are reversed.
                Since division is <em>not</em> a commutative operator, in other words
                <m>15/5</m> is not the same as <m>5/15</m>, we must be sure that
                the order of the operands is not switched.</p>
            
            <figure align="center" xml:id="xfix_fig-evalpost2">
                <caption>A More Complex Example of Evaluation</caption>
                <image source="LinearBasic/evalpostfix2.png" width="50%"> 
                    <description>
                        <p>
                            The image demonstrates the evaluation of a more complex postfix expression 7 8 + 3 2 + / using a stack.
                            It shows the operands and operators being processed step by step. Initially, 7 and 8 are pushed onto the stack. 
                            When the addition operator (+) is encountered, 7 and 8 are popped, added to produce 15, and the result is pushed back onto the stack. 
                            Next, 3 and 2 are pushed onto the stack, and when the addition operator (+) is encountered, 3 and 2 are popped, added to produce 5, 
                            and the result is pushed back onto the stack. Finally, the division operator (/) is encountered, and the two values 15 and 5 are popped, divided as 15 / 5 to produce 3, 
                            which is pushed back onto the stack as the final result. The image uses arrows and stack snapshots to illustrate the growth and reduction of the stack at each step of the evaluation.
                        </p>
                    </description>
                </image>
            </figure>
            <p>Assume the postfix expression is a string of tokens delimited by spaces.
                The operators are *, /, +, and - and the operands are assumed to be
                single-digit integer values. The output will be an integer result.</p>
            <p><ol marker="1">
                <li>
                    <p>Create an empty stack called <c>operandStack</c>.</p>
                </li>
                <li>
                    <p>Iterate across the input using a for loop.</p>
                </li>
                <li>
                    <p>Scan the token vector from left to right.</p>
                    <p><ul>
                        <li>
                            <p>If the token is an operand, convert it from a string to an integer
                                and push the value onto the <c>operandStack</c>. (Using the ASCII, you can get this by subtracting 48)</p>
                        </li>
                        <li>
                            <p>If the token is an operator, *, /, +, or -, it will need two
                                operands. Pop the <c>operandStack</c> twice. The first pop is the
                                second operand and the second pop is the first operand. Perform
                                the arithmetic operation. Push the result back on the
                                <c>operandStack</c>.</p>
                        </li>
                    </ul></p>
                </li>
                <li>
                    <p>When the input expression has been completely processed, the result
                        is on the stack. Pop the <c>operandStack</c> and return the value.</p>
                </li>
            </ol></p>
            <p>The complete function for the evaluation of postfix expressions is shown
                in <xref ref="lst-postfixeval-cpp"/>. To assist with the arithmetic, a helper
                function <c>doMath</c> is defined that will take two operands and an
                operator and then perform the proper arithmetic operation.</p>

            <exploration xml:id="expl-lst-postfixeval-cpp">
                <title>Postfix Expression Evaluator</title>
                <task xml:id="lst-postfixeval-cpp" label="lst-postfixeval-cpp">
                    <title>C++ Implementation</title>
                    <statement><program xml:id="postfixeval_cpp" interactive="activecode" language="cpp" label="postfixeval_cpp-prog"><code>
//Solves a postfix math problem.

#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;

using namespace std;

int doMath(char op, int op1, int op2) {
    //Does math based on what op is passed as.
    if (op == '*') {
        return (op1 * op2);
    } else if (op == '/') {
        return (op1 / op2);
    } else if (op == '+') {
        return (op1 + op2);
    } else {
        return (op1 - op2);
    }
}

int postfixEval(string postfixExpr) {
    stack&lt;int&gt; operandStack;
    string nums = &quot;0123456789&quot;;

    for (char i : postfixExpr) {
        if ((nums.find(i) &lt;= nums.length())) { // Check if the current char is a number
            operandStack.push(int(i) - 48); // conversion from char to ascii
            // then subtract 48 to get the int value
            } else if (i != ' ') {
                          int operand2 = operandStack.top();
                          operandStack.pop();
                          int operand1 = operandStack.top();
                          operandStack.pop();
                          int result = doMath(i, operand1, operand2);
                          operandStack.push(result);
                  }
    }
    return operandStack.top();
}

int main() {
    cout &lt;&lt; &quot;7 8 + 3 2 + /&quot; &lt;&lt; endl;
    cout &lt;&lt; postfixEval(&quot;7 8 + 3 2 + /&quot;) &lt;&lt; endl;

    return 0;
}
                    </code></program></statement>
                </task>
                <task xml:id="lst-postfixeval-py" label="lst-postfixeval-py">
                    <title>Python Implementation</title>
                    <statement><program xml:id="postfixeval" interactive="activecode" language="python" label="postfixeval-prog"><code>
#Solves a postfix math problem.

from pythonds.basic.stack import Stack

def postfixEval(postfixExpr):
    operandStack = Stack()
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token in &quot;0123456789&quot;:
            operandStack.push(int(token))
        else:
            operand2 = operandStack.pop()
            operand1 = operandStack.pop()
            result = doMath(token,operand1,operand2)
            operandStack.push(result)
    return operandStack.pop()

def doMath(op, op1, op2):
    #Does math based on what op is passed as.
    if op == &quot;*&quot;:
        return op1 * op2
    elif op == &quot;/&quot;:
        return op1 / op2
    elif op == &quot;+&quot;:
        return op1 + op2
    else:
        return op1 - op2

def main():
    print(postfixEval('7 8 + 3 2 + /'))
main()
                    </code></program></statement>
                </task>
            </exploration>
            <p>It is important to note that in both the postfix conversion and the
                postfix evaluation programs we assumed that there were no errors in the
                input expression. Using these programs as a starting point, you can
                easily see how error detection and reporting can be included. We leave
                this as an exercise at the end of the chapter.</p>
          

<reading-questions xml:id="rq-decimal-to-binary">
    <title>
        Reading Questions
    </title>

                <exercise label="question1_100_4" indent="show" language="python"><statement>
                    <p>What does the prefix expression of this infix expression look like: ((A+B)*(C-D)) if this were modeled using a stack with the top being the end of the expression and the bottom being the beginning of the expression?</p>
        </statement>
        <blocks><block order="1">
        <cline>D</cline>
        <cline>C</cline>
        <cline>-</cline>
        <cline>B</cline>
        <cline>A</cline>
        <cline>+</cline>
        <cline>*</cline>
        </block></blocks></exercise>     
        <exercise label="infix-1">
            <statement>
    <p>Without using the activecode infixToPostfix function, convert the following expression to postfix  <c>10 + 3 * 5 / (16 - 4)</c> . <var/>  </p></statement><setup><var><p><BlankNode/></p><condition string="^\s*10\s+3\s+5\s*\*\s*16\s+4\s*-\s*/\s*\+\s*$"><feedback><p>Correct.</p></feedback></condition><condition string="^\s*10.*3.*5.*16.*4\s+[\s+/+*-]*\s*$"><feedback><p>The numbers appear to be in the correct order check your operators</p></feedback></condition>
        <condition string="^\s*.*\s*$">
                        <feedback>
                            <p>Remember the numbers will be in the same order as the original equation</p>
                        </feedback>
                    </condition></var></setup></exercise>
        <exercise label="infix-2">
            <statement>
            <p>What is the result of evaluating the following: <c>17 10 + 3 * 9 / =</c> <var/>  </p>
            </statement>
            <setup>
                <var>
                    <condition number="[9]">
                        <feedback>
                            <p>Correct.</p>
                        </feedback>
                    </condition>
                    <condition string="^\s*.*\s*$">
                        <feedback>
                            <p>Remember to push each intermediate result back on the stack</p>
                        </feedback>
                    </condition>
                </var>
            </setup></exercise>
        <exercise label="infix-3">
            <statement>
    <p>Modify the infixToPostfix function above so that it can convert the following expression. Once you have the answer from the code put it in the blank below:  <c>5 * 3 /(4 - 2)</c>. <var/>  </p></statement><setup><var><p><BlankNode/></p><condition string="^\s*5\s+3\s*\*\s*4\s+2\s*\-\s*\/\s*$"><feedback><p>Correct.</p></feedback></condition><condition string="^\s*5.*3.*5.*4.*2\s+[-/*]*\s*$"><feedback><p>The numbers appear to be in the correct order check your operators</p></feedback></condition>
    <condition string="^\s*.*\s*$">
        <feedback>
            <p>Hint: You just need to change one line of code</p>
        </feedback>
    </condition>
        </var></setup></exercise> 
</reading-questions>           
        </subsection>
<conclusion><p>
    <!-- extra space before the progress bar -->
</p></conclusion>
</section>
