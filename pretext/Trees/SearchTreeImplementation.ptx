<?xml version="1.0" ?><section xml:id="trees_search-tree-implementation">
        <title>Search Tree Implementation</title>
        <p><idx>bst property</idx>A binary search tree relies on the property that
            keys that are less than the parent are found in the left subtree, and
            keys that are greater than the parent are found in the right subtree. We
            will call this the <term>bst property</term>. As we implement the Map interface
            as described above, the bst property will guide our implementation.
            <xref ref="bst_fig-simplebst"/> illustrates this property of a binary search
            tree, showing the keys without any associated values. Notice that the
            property holds for each parent and child. All of the keys in the left
            subtree are less than the key in the root. All of the keys in the right
            subtree are greater than the root.</p>
        
        <figure align="center" xml:id="bst_fig-simplebst">
            <caption>A Simple Binary Search Tree.</caption>
            <image source="Trees/simpleBST.png" width="50%">
            <description>
                <p>
                    A diagram illustrating a simple binary search tree (BST) structure with the root node labeled &quot;70.&quot; 
                    The left child of the root is labeled &quot;31,&quot; and the right child is labeled &quot;93.&quot; Node &quot;31&quot; has a left child 
                    labeled &quot;14,&quot; which in turn has a left child labeled &quot;23.&quot; Node &quot;93&quot; has two children: &quot;73&quot; as its left child 
                    and &quot;94&quot; as its right child.
                    This structure adheres to the BST property: each node’s left subtree contains keys less than the node’s key, 
                    and each node’s right subtree contains keys greater than the node’s key.
                </p>
            </description>
            </image>
        </figure>
        <p>Now that you know what a binary search tree is, we will look at how a
            binary search tree is constructed. The search tree in
            <xref ref="bst_fig-simplebst"/> represents the nodes that exist after we have
            inserted the following keys in the order shown:
            <m>70,31,93,94,14,23,73</m>. Since 70 was the first key inserted into
            the tree, it is the root. Next, 31 is less than 70, so it becomes the
            left child of 70. Next, 93 is greater than 70, so it becomes the right
            child of 70. Now we have two levels of the tree filled, so the next key
            is going to be the left or right child of either 31 or 93. Since 94 is
            greater than 70 and 93, it becomes the right child of 93. Similarly 14
            is less than 70 and 31, so it becomes the left child of 31. 23 is also
            less than 31, so it must be in the left subtree of 31. However, it is
            greater than 14, so it becomes the right child of 14.</p>
        <p>To implement the binary search tree, we will use the nodes and
            references approach similar to the one we used to implement the linked
            list, and the expression tree. To effectively manage scenerios where the binary
            search tree might be empty, we use two separate classes.
            The first class we will call <c>BinarySearchTree</c>,
            and the second class we will call <c>TreeNode</c>. The <c>BinarySearchTree</c>
            class has a reference to the <c>TreeNode</c> that is the root of the binary
            search tree. In most cases the external methods defined in the outer
            class simply check to see if the tree is empty. If there are nodes in
            the tree, the request is just passed on to a private method defined in
            the <c>BinarySearchTree</c> class that takes the root as a parameter. In
            the case where the tree is empty or we want to delete the key at the
            root of the tree, we must take special action. The code for the
            <c>BinarySearchTree</c> class constructor along with a few other
            miscellaneous functions is shown in <xref ref="bst_lst-bst1"/>.</p>
        
        <listing xml:id="bst_lst-bst1">
            <caption><c>BinarySearchTree</c> Class and Constructor</caption>
            <program language="cpp" label="bst_lst-bst1-prog"><code>
class BinarySearchTree{
    private:
        TreeNode *root;
        int size;

    public:
        BinarySearchTree(){
            root = nullptr;
            size = 0;
        }

        int length(){
            return size;
        }
}
            </code></program>
        </listing>
        <p>The <c>TreeNode</c> class provides many helper functions that make the work
            done in the <c>BinarySearchTree</c> class methods much easier. The
            constructor for a <c>TreeNode</c>, along with these helper functions, is
            shown in <xref ref="bst_lst-bst2"/>. As you can see in the listing many of
            these helper functions help to classify a node according to its own
            position as a child, (left or right) and the kind of children the node
            has.
            The <c>TreeNode</c> class will also explicitly keep track
            of the parent as an attribute of each node. You will see why this is
            important when we discuss the implementation for the <c>del</c> operator.</p>
        <p>Another interesting aspect of the implementation of <c>TreeNode</c> in
            <xref ref="bst_lst-bst2"/> is that we use C++'s optional parameters.
            Optional parameters make it easy for us to create a <c>TreeNode</c> under
            several different circumstances. Sometimes we will want to construct a
            new <c>TreeNode</c> that already has both a <c>parent</c> and a <c>child</c>.
            With an existing parent and child, we can pass parent and child as
            parameters. At other times we will just create a <c>TreeNode</c> with the
            key-value pair, and we will not pass any parameters for <c>parent</c> or
            <c>child</c>. In this case, the default values of the optional parameters
            are used.</p>
        
        <listing xml:id="bst_lst-bst2">
            <caption><c>TreeNode</c> Class</caption>
            <program language="cpp" label="bst_lst-bst2-prog"><code>
class TreeNode{
    public:
        int key;
        string value;
        TreeNode *leftChild;
        TreeNode *rightChild;
        TreeNode *parent;

        TreeNode(int key, string val, TreeNode *parent = nullptr, TreeNode *left = nullptr, TreeNode *right = nullptr){
            this-&gt;key = key;
            this-&gt;value = val;
            this-&gt;leftChild = left;
            this-&gt;rightChild = right;
            this-&gt;parent = parent;
        }

        TreeNode *hasLeftChild(){
            return leftChild;
        }

        TreeNode *hasRightChild(){
            return rightChild;
        }

        bool isLeftChild(){
            return parent &amp;&amp; parent-&gt;leftChild == this;
        }

        bool isRightChild(){
            return parent &amp;&amp; parent-&gt;rightChild == this;
        }

        bool isRoot(){
            return !parent;
        }

        bool isLeaf(){
            return !(rightChild || leftChild);
        }

        bool hasAnyChildren(){
            return rightChild || leftChild;
        }

        bool hasBothChildren(){
            return rightChild &amp;&amp; leftChild;
        }

        void replaceNodeData(int key, string val, TreeNode *lc = nullptr, TreeNode *rc = nullptr){
            this-&gt;key = key;
            this-&gt;value = val;
            this-&gt;leftChild = lc;
            this-&gt;rightChild = rc;
            if (hasLeftChild()){
                leftChild-&gt;parent = this;
            }
            if (hasRightChild()){
                rightChild-&gt;parent = this;
            }
        }
    }
            </code></program>
        </listing>
        <p>Now that we have the <c>BinarySearchTree</c> shell and the <c>TreeNode</c> it
            is time to write the <c>put</c> method that will allow us to build our
            binary search tree. The <c>put</c> method is a method of the
            <c>BinarySearchTree</c> class. This method will check to see if the tree
            already has a root. If there is not a root then <c>put</c> will create a
            new <c>TreeNode</c> and install it as the root of the tree. If a root node
            is already in place then <c>put</c> calls the private, recursive, helper
            function <c>_put</c> to search the tree according to the following
            algorithm:</p>
        <p><ul>
            <li>
                <p>Starting at the root of the tree, search the binary tree comparing
                    the new key to the key in the current node. If the new key is less
                    than the current node, search the left subtree. If the new key is
                    greater than the current node, search the right subtree.</p>
            </li>
            <li>
                <p>When there is no left (or right) child to search, we have found the
                    position in the tree where the new node should be installed.</p>
            </li>
            <li>
                <p>To add a node to the tree, create a new <c>TreeNode</c> object and
                    insert the object at the point discovered in the previous step.</p>
            </li>
        </ul></p>
        <p><xref ref="bst_lst-bst3"/> shows the C++ code for inserting a new node in
            the tree. The <c>_put</c> function is written recursively following the
            steps outlined above. Notice that when a new child is inserted into the
            tree, the <c>currentNode</c> is passed to the new tree as the parent.</p>
        <p>One important problem with our implementation of insert is that
            duplicate keys are not handled properly. As our tree is implemented a
            duplicate key will create a new node with the same key in the
            right subtree of the node having the original key. The result of this is
            that the node with the new key will never be found during a search. A
            better way to handle the insertion of a duplicate key is for the value
            associated with the new key to replace the old value. We leave fixing
            this bug as an exercise for you.</p>
        
        <listing xml:id="bst_lst-bst3" names="lst_bst3">
            <caption><c>put</c> and <c>_put</c> Methods</caption>
            <program language="cpp" label="bst_lst-bst3-prog"><code>
void put(int key, string val){
    if (root){
        _put(key, val, root);
    }
    else{
        root = new TreeNode(key, val);
    }
    size = size + 1;
}

void _put(int key, string val, TreeNode *currentNode){
    if (key &lt; currentNode-&gt;key){
        if (currentNode-&gt;hasLeftChild()){
            _put(key, val, currentNode-&gt;leftChild);
        }
        else{
            currentNode-&gt;leftChild = new TreeNode(key, val, currentNode);
        }
    }
    else{
        if (currentNode-&gt;hasRightChild()){
            _put(key, val, currentNode-&gt;rightChild);
        }
        else{
            currentNode-&gt;rightChild = new TreeNode(key, val, currentNode);
        }
    }
}
            </code></program>
        </listing>
        <p><xref ref="bst_fig-bstput"/> illustrates the process for inserting a new node
            into a binary search tree. The lightly shaded nodes indicate the nodes
            that were visited during the insertion process.</p>
        
        <figure align="center" xml:id="bst_fig-bstput">
            <caption>Inserting a Node with Key = 19.</caption>
            <image source="Trees/bstput.png" width="80%">
            <description>
                <p>
                    A binary search tree (BST) illustrating the process of inserting a new node with the key &quot;19.&quot; 
                    The tree has &quot;17&quot; as the root node. The left subtree of &quot;17&quot; contains nodes &quot;5&quot; with left child &quot;2&quot; and right child &quot;16&quot;. 
                    The right subtree of &quot;17&quot; contains nodes &quot;35&quot; with a left child &quot;29&quot; and a right child labeled &quot;38.&quot; Node &quot;29&quot; has two children: 
                    &quot;33&quot; as its right child and a newly inserted node &quot;19&quot; as its left child. 
                    Lightly shaded nodes (&quot;17,&quot; &quot;29,&quot; and &quot;19&quot;) indicate the nodes visited during the insertion process. The newly added node &quot;19&quot; 
                    is depicted as darkly shaded to highlight it as the most recently added node.
                </p>
            </description>
            </image>
            </figure>
        <note>
            <title>Self Check</title>

    
        </note>
        <p>Once the tree is constructed, the next task is to implement the
            retrieval of a value for a given key. The <c>get</c> method is even easier
            than the <c>put</c> method because it simply searches the tree recursively
            until it gets to a non-matching leaf node or finds a matching key. When
            a matching key is found, the value of the node is returned.</p>
        <p><xref ref="bst_lst-bst4"/> shows the code for <c>get</c>  and <c>_get</c>. The search code in the <c>_get</c> method uses the same
            logic for choosing the left or right child as the <c>_put</c> method. Notice
            that the <c>_get</c> method returns a <c>TreeNode</c> to <c>get</c>, this allows
            <c>_get</c> to be used as a flexible helper method for other
            <c>BinarySearchTree</c> methods that may need to make use of other data
            from the <c>TreeNode</c> besides the value.</p>
        
        <listing xml:id="bst_lst-bst4" names="bst_lst-bst4">
            <caption><c>get</c> and <c>_get</c> Methods</caption>
            <program language="cpp" label="bst_lst-bst4-prog"><code>
string get(int key){
    if (root){
        TreeNode *res = _get(key, root);
        if (res)
            return res-&gt;value;
    }
    throw runtime_error(&quot;missing key&quot;);
}

TreeNode  *_get(int key, TreeNode *currentNode){
    if (!currentNode){
        return nullptr;
    }
    else if (currentNode-&gt;key == key){
        return currentNode;
    }
    else if (key &lt; currentNode-&gt;key){
        return _get(key, currentNode-&gt;leftChild);
    }
    else{
        return _get(key, currentNode-&gt;rightChild);
    }
}
            </code></program>
        </listing>
        <p>Finally, we turn our attention to the most challenging method in the
            binary search tree, the deletion of a key (see <xref ref="bst_lst-bst5"/>). The first task is to find the
            node to delete by searching the tree. If the tree has more than one node
            we search using the <c>_get</c> method to find the <c>TreeNode</c> that needs
            to be removed. If the tree only has a single node, that means we are
            removing the root of the tree, but we still must check to make sure the
            key of the root matches the key that is to be deleted. In either case if
            the key is not found the <c>del</c> operator raises an error.</p>
        
        <listing xml:id="bst_lst-bst5" names="lst_bst5">
            <caption><c>del</c> Method</caption>
            <program language="cpp" label="bst_lst-bst5-prog"><code>
void del(int key){
    if (size &gt; 1){
        TreeNode *nodeToRemove = _get(key, root);
        if (nodeToRemove){
            remove(nodeToRemove);
            size = size - 1;
        }
        else{
            cerr &lt;&lt; &quot;Error, key not in tree&quot; &lt;&lt; endl;
        }
    }
    else if (size == 1 &amp;&amp; root-&gt;key == key){
        root = nullptr;
        size = size - 1;
    }
    else{
        cerr &lt;&lt; &quot;Error, key not in tree&quot; &lt;&lt; endl;
    }
}
            </code></program>
        </listing>
        <p>Once we've found the node containing the key we want to delete, there
            are three cases that we must consider:</p>
        <p><ol marker="1">
            <li>
                <p>The node to be deleted has no children (see <xref ref="bst_fig-bstdel1"/>).</p>
            </li>
            <li>
                <p>The node to be deleted has only one child (see <xref ref="bst_fig-bstdel2"/>).</p>
            </li>
            <li>
                <p>The node to be deleted has two children (see <xref ref="bst_fig-bstdel3"/>).</p>
            </li>
        </ol></p>
        <p>The first case is straightforward (see <xref ref="bst_lst-bst6"/>). If the current node has no children
            all we need to do is delete the node and remove the reference to this
            node in the parent. The code for this case is shown in here.</p>
        
        <listing xml:id="bst_lst-bst6">
            <caption>Deleting a Node With No Children</caption>
            <program language="cpp" label="bst_lst-bst6-prog"><code>
if (currentNode-&gt;isLeaf()){ //leaf
    if (currentNode == currentNode-&gt;parent-&gt;leftChild){
        currentNode-&gt;parent-&gt;leftChild = nullptr;
    }
    else{
        currentNode-&gt;parent-&gt;rightChild = nullptr;
    }
}
            </code></program>
        </listing>
        <figure align="center" xml:id="bst_fig-bstdel1">
            <caption>Deleting Node 16, a Node without Children.</caption>
            <image source="Trees/bstdel1.png" width="80%">
            <description>
                <p>
                    A binary search tree (BST) showcasing the deletion of a leaf node, &quot;16.&quot; The initial tree contains node &quot;16&quot; as 
                    the right child of &quot;11&quot; in the left subtree of the root node &quot;17.&quot; After deletion, the modified tree no longer 
                    includes node &quot;16.&quot; The parent node &quot;11&quot; retains its left child, &quot;9,&quot; and the tree maintains its BST property. 
                    An arrow highlights the transformation from the initial tree to the updated structure.
                </p>
            </description>
            </image>
        </figure>
        <p>The second case is only slightly more complicated (see <xref ref="bst_lst-bst7"/>). If a node has only a
            single child, then we can simply promote the child to take the place of
            its parent. The code for this case is shown in the next listing. As
            you look at this code you will see that there are six cases to consider.
            Since the cases are symmetric with respect to either having a left or
            right child we will just discuss the case where the current node has a
            left child. The decision proceeds as follows:</p>
        <p><ol marker="1">
            <li>
                <p>If the current node is a left child then we only need to update the
                    parent reference of the left child to point to the parent of the
                    current node, and then update the left child reference of the parent
                    to point to the current node's left child.</p>
            </li>
            <li>
                <p>If the current node is a right child then we only need to update the
                    parent reference of the left child to point to the parent of the
                    current node, and then update the right child reference of the parent
                    to point to the current node's left child.</p>
            </li>
            <li>
                <p>If the current node has no parent, it must be the root. In this case
                    we will just replace the <c>key</c>, <c>value</c>, <c>leftChild</c>, and
                    <c>rightChild</c> data by calling the <c>replaceNodeData</c> method on the
                    root.</p>
            </li>
        </ol></p>

        <listing xml:id="bst_lst-bst7">
            <caption>Handling One Child Node</caption>
            <program language="cpp" label="bst_lst-bst7-prog"><code>
else{ // this node has one child
    if (currentNode-&gt;hasLeftChild()){
        if (currentNode-&gt;isLeftChild()){
            currentNode-&gt;leftChild-&gt;parent = currentNode-&gt;parent;
            currentNode-&gt;parent-&gt;leftChild = currentNode-&gt;leftChild;
        }
        else if (currentNode-&gt;isRightChild()){
            currentNode-&gt;leftChild-&gt;parent = currentNode-&gt;parent;
            currentNode-&gt;parent-&gt;rightChild = currentNode-&gt;leftChild;
        }
        else{
            currentNode-&gt;replaceNodeData(currentNode-&gt;leftChild-&gt;key,
                                         currentNode-&gt;leftChild-&gt;value,
                                         currentNode-&gt;leftChild-&gt;leftChild,
                                         currentNode-&gt;leftChild-&gt;rightChild);

        }
    }
    else{
        if (currentNode-&gt;isLeftChild()){
            currentNode-&gt;rightChild-&gt;parent = currentNode-&gt;parent;
            currentNode-&gt;parent-&gt;leftChild = currentNode-&gt;rightChild;
        }
        else if (currentNode-&gt;isRightChild()){
            currentNode-&gt;rightChild-&gt;parent = currentNode-&gt;parent;
            currentNode-&gt;parent-&gt;rightChild = currentNode-&gt;rightChild;
        }
        else{
            currentNode-&gt;replaceNodeData(currentNode-&gt;rightChild-&gt;key,
                                         currentNode-&gt;rightChild-&gt;value,
                                         currentNode-&gt;rightChild-&gt;leftChild,
                                         currentNode-&gt;rightChild-&gt;rightChild);
        }
    }
}
            </code></program>
        </listing>
        
        <figure align="center" xml:id="bst_fig-bstdel2">
            <caption>Deleting Node 25, a Node That Has a Single Child.</caption>
            <image source="Trees/bstdel2.png" width="80%"> 
            <description>
                <p>
                    A binary search tree (BST) illustrating the deletion of node &quot;25,&quot; which has a single child. Initially, 
                    node &quot;25&quot; is the right child of the root node &quot;17&quot; and has &quot;35&quot; as its single child. After deletion, 
                    node &quot;25&quot; is removed, and its child &quot;35&quot; takes its place in the tree. The tree maintains its BST property, 
                    with all nodes correctly positioned in their respective left or right subtrees. An arrow highlights the 
                    transition from the initial tree to the updated tree structure.
                </p>
            </description>
            </image>
        </figure>
        <p><idx>successor node</idx>The third case is the most difficult case to handle (see <xref ref="bst_lst-bst8"/>). If a node has two
            children, then it is unlikely that we can simply promote one of them to
            take the node's place. We can, however, search the tree for a node that
            can be used to replace the one scheduled for deletion. What we need is a
            node that will preserve the binary search tree relationships for both of
            the existing left and right subtrees. The node that will do this is the
            node that has the next-largest key in the tree. We call this node the
            <term>successor node</term>, and we will look at a way to find the successor shortly.
            The successor is guaranteed to have no more than one child, so we know
            how to remove it using the two cases for deletion that we have already
            implemented. Once the successor has been removed, we simply put it in
            the tree in place of the node to be deleted.</p>
        
        <figure align="center" xml:id="bst_fig-bstdel3">
            <caption>Deleting Node 5, a Node with Two Children.</caption>
            <image source="Trees/bstdel3.png" width="80%">
            <description>
                <p>
                    A binary search tree (BST) illustrating the deletion of a node with two children, specifically node &quot;5.&quot; 
                    The initial tree has &quot;17&quot; as the root. Node &quot;5,&quot; highlighted for deletion, has two children: &quot;2&quot; and &quot;11.&quot; 
                    To handle this case, the algorithm finds the successor node, which is the smallest node in the right subtree of &quot;5.&quot; 
                    The successor node, &quot;7,&quot; is identified and highlighted. 

                    The successor node &quot;7&quot; is removed from its original position and placed in the location of the deleted node &quot;5,&quot; 
                    preserving the BST properties. The updated tree maintains its hierarchical relationships, with all nodes correctly 
                    positioned according to the BST property. An arrow illustrates the transformation from the initial tree to the updated structure.
                </p>
            </description>
            </image>
        </figure>
        <p>The code to handle the third case is shown in <xref ref="bst_lst-bst8"/>.
            Notice that we make use of the helper methods <c>findSuccessor</c> and
            <c>findMin</c> to find the successor. To remove the successor, we make use
            of the method <c>spliceOut</c>. The reason we use <c>spliceOut</c> is that it
            goes directly to the node we want to splice out and makes the right
            changes. We could call <c>delete</c> recursively, but then we would waste
            time re-searching for the key node.</p>
        
        <listing xml:id="bst_lst-bst8" names="lst_bst8">
            <caption>Deleting a Node With Two Children</caption>
            <program language="cpp" label="bst_lst-bst8-prog"><code>
else if (currentNode-&gt;hasBothChildren()){ //interior
    TreeNode *succ = currentNode-&gt;findSuccessor();
    succ-&gt;spliceOut();
    currentNode-&gt;key = succ-&gt;key;
    currentNode-&gt;value = succ-&gt;value;
}
            </code></program>
        </listing>
        <p>The code to find the successor is shown below (see <xref ref="bst_lst-bst9"/>) and as
            you can see is a method of the <c>TreeNode</c> class. This code makes use
            of the same properties of binary search trees that cause an inorder
            traversal to print out the nodes in the tree from smallest to largest.
            There are three cases to consider when looking for the successor:</p>
        <p><ol marker="1">
            <li>
                <p>If the node has a right child, then the successor is the smallest key
                    in the right subtree.</p>
            </li>
            <li>
                <p>If the node has no right child and is the left child of its parent,
                    then the parent is the successor.</p>
            </li>
            <li>
                <p>If the node is the right child of its parent, and itself has no right
                    child, then the successor to this node is the successor of its
                    parent, excluding this node.</p>
            </li>
        </ol></p>
        <p>The first condition is the only one that matters for us when deleting a
            node from a binary search tree. However, the <c>findSuccessor</c> method
            has other uses that we will explore in the exercises at the end of this
            chapter.</p>
        <p>The <c>findMin</c> method is called to find the minimum key in a subtree.
            You should convince yourself that the minimum key in any binary
            search tree is the leftmost child of the tree. Therefore the <c>findMin</c>
            method simply follows the <c>leftChild</c> references in each node of the
            subtree until it reaches a node that does not have a left child.</p>
        
        <listing xml:id="bst_lst-bst9" names="lst_bst9">
            <caption><c>findSuccessor</c>, <c>findMin</c>, and <c>spliceOut</c> Methods</caption>
            <program language="cpp" label="bst_lst-bst9-prog"><code>
TreeNode *findSuccessor(){
    TreeNode *succ = nullptr;
    if (hasRightChild()){
        succ = rightChild-&gt;findMin();
    }
    else{
        if (parent){
            if (isLeftChild()){
                succ = parent;
            }
            else{
                parent-&gt;rightChild = nullptr;
                succ = parent-&gt;findSuccessor();
                parent-&gt;rightChild = this;
            }
        }
    }
    return succ;
}

TreeNode *findMin(){
    TreeNode *current = this;
    while (current-&gt;hasLeftChild()){
        current = current-&gt;leftChild;
    }
    return current;
}

void spliceOut(){
    if (isLeaf()){
        if (isLeftChild()){
            parent-&gt;leftChild = nullptr;
        }
        else{
            parent-&gt;rightChild = nullptr;
        }
    }
    else if (hasAnyChildren()){
        if (hasLeftChild()){
            if (isLeftChild()){
                parent-&gt;leftChild = leftChild;
            }
            else{
                parent-&gt;rightChild = rightChild;
            }
            leftChild-&gt;parent = parent;
        }
        else{
            if (isLeftChild()){
                parent-&gt;leftChild = rightChild;
            }
            else{
                parent-&gt;rightChild = rightChild;
            }
            rightChild-&gt;parent = parent;
        }
    }
}
            </code></program>
        </listing>

        <p>At this point you may want to download the entire file containing the
            full version of the <c>BinarySearchTree</c> and <c>TreeNode</c> classes shown in <xref ref="lst-bstwhole-cpp"/>.</p>

        
        <exploration xml:id="expl-bstwhole">
            <title>Complete Binary Search Tree</title>
            <task xml:id="lst-bstwhole-cpp" label="lst-bstwhole-cpp">
                <title>C++ Implementation</title>
                <statement><program xml:id="completebstcodecpp" interactive="activecode" language="cpp" label="completebstcodecpp-prog"><code>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstddef&gt;
#include &lt;string&gt;
using namespace std;

//The TreeNode class represents a node, or vertex, in a tree heirarchy.
class TreeNode{

    public:
        int key;
        string value;
        TreeNode *leftChild;
        TreeNode *rightChild;
        TreeNode *parent;

        // Using Optional parameters make it
        // easy for us to create a TreeNode under several different circumstances.
        TreeNode(int key, string val, TreeNode *parent = nullptr, TreeNode *left = nullptr, TreeNode *right = nullptr){
            this-&gt;key = key;
            this-&gt;value = val;
            this-&gt;leftChild = left;
            this-&gt;rightChild = right;
            this-&gt;parent = parent;
        }

        // Returns a pointer to the left child of this node.
        // If null, the child doesn't exist.
        TreeNode *hasLeftChild(){
            return leftChild;
        }

        // Returns a pointer to the right child of this node.
        // If null, the child doesn't exist.
        TreeNode *hasRightChild(){
            return rightChild;
        }

        //Returns a boolean indicating if this node is the left child of its parent.
        bool isLeftChild(){
            return parent &amp;&amp; parent-&gt;leftChild == this;
        }

        //Returns a boolean indicating if this node is the right child of its parent.
        bool isRightChild(){
            return parent &amp;&amp; parent-&gt;rightChild == this;
        }


        //Returns a boolean indicating if this node is a root node (has no parent).
        bool isRoot(){
            return !parent;
        }

        //Returns a boolean indicating if this node has no children.
        bool isLeaf(){
            return !(rightChild || leftChild);
        }

        // Returns a boolean indicating if this node has children.
        bool hasAnyChildren(){
            return rightChild || leftChild;
        }

        //Returns a boolean indicating if this node has both children.
        bool hasBothChildren(){
            return rightChild &amp;&amp; leftChild;
        }


        //Removes this node from the tree it exists in,
        //making it the root node of its own tree.
        void spliceOut(){
            if (isLeaf()){
                if (isLeftChild()){
                    parent-&gt;leftChild = nullptr;
                }
                else{
                    parent-&gt;rightChild = nullptr;
                }
            }
            else if (hasAnyChildren()){
                if (hasLeftChild()){
                    if (isLeftChild()){
                        parent-&gt;leftChild = leftChild;
                    }
                    else{
                        parent-&gt;rightChild = rightChild;
                    }
                    leftChild-&gt;parent = parent;
                }
                else{
                    if (isLeftChild()){
                        parent-&gt;leftChild = rightChild;
                    }
                    else{
                        parent-&gt;rightChild = rightChild;
                    }
                    rightChild-&gt;parent = parent;
                }
            }
        }

        // Uses same properties of binary search tree
        // that cause an inorder traversal to print out the
        // nodes in the tree from smallest to largest.
        TreeNode *findSuccessor(){
            TreeNode *succ = nullptr;
            if (hasRightChild()){
                succ = rightChild-&gt;findMin();
            }
            else{
                if (parent){
                    if (isLeftChild()){
                        succ = parent;
                    }
                    else{
                        parent-&gt;rightChild = nullptr;
                        succ = parent-&gt;findSuccessor();
                        parent-&gt;rightChild = this;
                    }
                }
            }
            return succ;
        }

        //Finds the leftmost node out of all of this node's children.
        TreeNode *findMin(){
            TreeNode *current = this;
            while (current-&gt;hasLeftChild()){
                current = current-&gt;leftChild;
            }
            return current;
        }

        //Sets the variables of this node. lc/rc are left child and right child.
        void replaceNodeData(int key, string value, TreeNode *lc = nullptr, TreeNode *rc = nullptr){
            this-&gt;key = key;
            this-&gt;value = value;
            this-&gt;leftChild = lc;
            this-&gt;rightChild = rc;
            if (hasLeftChild()){
                leftChild-&gt;parent = this;
            }

            if (hasRightChild()){
                rightChild-&gt;parent = this;
            }
        }
};


class BinarySearchTree{

    // references the TreeNode
    // that is the root of the binary search tree.
    private:
        TreeNode *root;
        int size;

        /*searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*/
        /* When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*/
        /*To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*/
        // this is all done recursively
        void _put(int key, string val, TreeNode *currentNode){
            if (key &lt; currentNode-&gt;key){
                if (currentNode-&gt;hasLeftChild()){
                    _put(key, val, currentNode-&gt;leftChild);
                }
                else{
                    currentNode-&gt;leftChild = new TreeNode(key, val, currentNode);
                }
            }
            else{
                if (currentNode-&gt;hasRightChild()){
                    _put(key, val, currentNode-&gt;rightChild);
                }
                else{
                    currentNode-&gt;rightChild = new TreeNode(key, val, currentNode);
                }
            }
        }

        // Uses the same search method as _put, and returns
        // a TreeNode to get
        TreeNode  *_get(int key, TreeNode *currentNode){
            if (!currentNode){
                return nullptr;
            }
            else if (currentNode-&gt;key == key){
                return currentNode;
            }
            else if (key &lt; currentNode-&gt;key){
                return _get(key, currentNode-&gt;leftChild);
            }
            else{
                return _get(key, currentNode-&gt;rightChild);
            }
        }

    public:
        BinarySearchTree(){
            root = nullptr;
            size = 0;
        }

        int length(){
            return size;
        }

        // Checks to see if the tree has a root,
        // if there is not a root then it will create a new TreeNode
        // and install it as the root of the tree.
        // If a root node is already in place than it calls _put
        // to search the tree
        void put(int key, string val){
            if (root){
                _put(key, val, root);
            }
            else{
                root = new TreeNode(key, val);
            }
            size = size + 1;
        }

        // prints string associated with key to console
        string get(int key){
            if (root){
                TreeNode *res = _get(key, root);
                if (res){
                    return res-&gt;value;
                }
                else{
                    return 0;
                }
            }
            else{
                return 0;
            }
        }

        // checks to make sure the key of the root matches the key that is to be deleted.
        // In either case if the key is not found an error is raised.
        // If the node is found and has no childeren it is deleted
        // If the node has a single child, the child takes the place of the parent.
        // Look at explanation for listing 10
        void del(int key){
            if (size &gt; 1){
                TreeNode *nodeToRemove = _get(key, root);
                if (nodeToRemove){
                    remove(nodeToRemove);
                    size = size - 1;
                }
                else{
                    cerr &lt;&lt; &quot;Error, key not in tree&quot; &lt;&lt; endl;
                }
            }
            else if (size == 1 &amp;&amp; root-&gt;key == key){
                root = nullptr;
                size = size - 1;
            }
            else{
                cerr &lt;&lt; &quot;Error, key not in tree&quot; &lt;&lt; endl;
            }
        }

        void remove(TreeNode *currentNode){
            if (currentNode-&gt;isLeaf()){ //leaf
                if (currentNode == currentNode-&gt;parent-&gt;leftChild){
                    currentNode-&gt;parent-&gt;leftChild = nullptr;
                }
                else{
                    currentNode-&gt;parent-&gt;rightChild = nullptr;
                }
            }
            else if (currentNode-&gt;hasBothChildren()){ //interior
                TreeNode *succ = currentNode-&gt;findSuccessor();
                succ-&gt;spliceOut();
                currentNode-&gt;key = succ-&gt;key;
                currentNode-&gt;value = succ-&gt;value;
            }
            else{ // this node has one child
                if (currentNode-&gt;hasLeftChild()){
                    if (currentNode-&gt;isLeftChild()){
                        currentNode-&gt;leftChild-&gt;parent = currentNode-&gt;parent;
                        currentNode-&gt;parent-&gt;leftChild = currentNode-&gt;leftChild;
                    }
                    else if (currentNode-&gt;isRightChild()){
                        currentNode-&gt;leftChild-&gt;parent = currentNode-&gt;parent;
                        currentNode-&gt;parent-&gt;rightChild = currentNode-&gt;leftChild;
                    }
                    else{
                        currentNode-&gt;replaceNodeData(currentNode-&gt;leftChild-&gt;key,
                                                     currentNode-&gt;leftChild-&gt;value,
                                                     currentNode-&gt;leftChild-&gt;leftChild,
                                                     currentNode-&gt;leftChild-&gt;rightChild);

                    }
                }
                else{
                    if (currentNode-&gt;isLeftChild()){
                        currentNode-&gt;rightChild-&gt;parent = currentNode-&gt;parent;
                        currentNode-&gt;parent-&gt;leftChild = currentNode-&gt;rightChild;
                    }
                    else if (currentNode-&gt;isRightChild()){
                        currentNode-&gt;rightChild-&gt;parent = currentNode-&gt;parent;
                        currentNode-&gt;parent-&gt;rightChild = currentNode-&gt;rightChild;
                    }
                    else{
                        currentNode-&gt;replaceNodeData(currentNode-&gt;rightChild-&gt;key,
                                                     currentNode-&gt;rightChild-&gt;value,
                                                     currentNode-&gt;rightChild-&gt;leftChild,
                                                     currentNode-&gt;rightChild-&gt;rightChild);
                    }
                }
            }
        }
};

int main(){

    BinarySearchTree *mytree = new BinarySearchTree();
    mytree-&gt;put(3, &quot;red&quot;);
    mytree-&gt;put(4, &quot;blue&quot;);
    mytree-&gt;put(6, &quot;yellow&quot;);
    mytree-&gt;put(2, &quot;at&quot;);

    cout &lt;&lt; mytree-&gt;get(6) &lt;&lt; endl;
    cout &lt;&lt; mytree-&gt;get(2) &lt;&lt; endl;

    return 0;
}
                </code></program></statement>
            </task>
            <task xml:id="lst-bstwhole-py" label="lst-bstwhole-py">
                <title>Python Implementation</title>
                <statement><program xml:id="completebstcodepy" interactive="activecode" language="python" label="completebstcodepy-prog"><code>
#The TreeNode class represents a node, or vertex, in a tree heirarchy.
class TreeNode:
    def __init__(self,key,val,left=None,right=None,parent=None):
        self.key = key
        self.value = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    &quot;&quot;&quot; Returns a pointer to the left child of this node.
     If None, the child doesn't exist.&quot;&quot;&quot;
    def hasLeftChild(self):
        return self.leftChild

    &quot;&quot;&quot; Returns the right child, or None if it doesn't exist.&quot;&quot;&quot;
    def hasRightChild(self):
        return self.rightChild

    # Returns a boolean indicating if this node is the left child of its parent.
    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    # Returns a boolean indicating if this node is the right child of its parent.
    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    # Returns a boolean indicating if this node is a root node (has no parents).
    def isRoot(self):
        return not self.parent

    # Returns a boolean indicating if this node has no children.
    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    # Returns a boolean indicating if this node has children.
    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    # Returns a boolean indicating if this node has both childeren.
    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    &quot;&quot;&quot; Removes this node from the tree it exists in,
    making it the root node of its own tree.&quot;&quot;&quot;
    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.hasLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    &quot;&quot;&quot; Uses same properties of binary search tree
        that cause an inorder traversal to find
        nodes in the tree from smallest to largest. &quot;&quot;&quot;
    def findSuccessor(self):
        succ = None
        if self.hasRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                   if self.isLeftChild():
                       succ = self.parent
                   else:
                       self.parent.rightChild = None
                       succ = self.parent.findSuccessor()
                       self.parent.rightChild = self
        return succ

    #Finds the leftmost node out of all of this node's children.
    def findMin(self):
        current = self
        while current.hasLeftChild():
            current = current.leftChild
        return current

    # Sets the variables of this node. lc/rc are left child and right child.
    def replaceNodeData(self,key,value,lc,rc):
        self.key = key
        self.value = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self


class BinarySearchTree:

    # references the TreeNode
    # that is the root of the binary search tree.
    def __init__(self):
        self.root = None
        self.size = 0

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    &quot;&quot;&quot;Checks to see if the tree has a root,
    if there is not a root then it will create a new TreeNode
    and install it as the root of the tree.
    If a root node is already in place than it calls _put
    to search the tree&quot;&quot;&quot;
    def put(self,key,val):
        if self.root:
            self._put(key,val,self.root)
        else:
            self.root = TreeNode(key,val)
        self.size = self.size + 1

    &quot;&quot;&quot;searches the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.*\
       When there is no left (or right) child to search, we have found the position in the tree where the new node should be installed.*\
       To add a node to the tree, create a new TreeNode object and insert the object at the point discovered in the previous step.*\
       this is all done recursively&quot;&quot;&quot;
    def _put(self,key,val,currentNode):
        if key &lt; currentNode.key:
            if currentNode.hasLeftChild():
                   self._put(key,val,currentNode.leftChild)
            else:
                   currentNode.leftChild = TreeNode(key,val,parent=currentNode)
        else:
            if currentNode.hasRightChild():
                   self._put(key,val,currentNode.rightChild)
            else:
                   currentNode.rightChild = TreeNode(key,val,parent=currentNode)

    # prints string associated with key to console
    def get(self,key):
       if self.root:
           res = self._get(key,self.root)
           if res:
                  return res.value
           else:
                  return None
       else:
           return None

    # Uses the same search method as _put, and returns
    # a TreeNode to get
    def _get(self,key,currentNode):
       if not currentNode:
           return None
       elif currentNode.key == key:
           return currentNode
       elif key &lt; currentNode.key:
           return self._get(key,currentNode.leftChild)
       else:
           return self._get(key,currentNode.rightChild)

    #def __contains__(self,key):
     #  if self._get(key,self.root):
      #    return True
       #else:
        #   return False

    &quot;&quot;&quot; Checks to make sure the key of the root matches the key that is to be deleted.
        In either case if the key is not found an error is raised.
        If the node is found and has no childeren it is deleted
        If the node has a single child, the child takes the place of the parent.
        Look at explination for listing 10 &quot;&quot;&quot;
    def delete(self,key):
      if self.size &gt; 1:
         nodeToRemove = self._get(key,self.root)
         if nodeToRemove:
             self.remove(nodeToRemove)
             self.size = self.size-1
         else:
             raise KeyError('Error, key not in tree')
      elif self.size == 1 and self.root.key == key:
         self.root = None
         self.size = self.size - 1
      else:
         raise KeyError('Error, key not in tree')

    # Removes the specified currentNode from this tree.
    def remove(self,currentNode):
         if currentNode.isLeaf(): #leaf
           if currentNode == currentNode.parent.leftChild:
               currentNode.parent.leftChild = None
           else:
               currentNode.parent.rightChild = None
         elif currentNode.hasBothChildren(): #interior
           succ = currentNode.findSuccessor()
           succ.spliceOut()
           currentNode.key = succ.key
           currentNode.value = succ.value

         else: # this node has one child
           if currentNode.hasLeftChild():
             if currentNode.isLeftChild():
                 currentNode.leftChild.parent = currentNode.parent
                 currentNode.parent.leftChild = currentNode.leftChild
             elif currentNode.isRightChild():
                 currentNode.leftChild.parent = currentNode.parent
                 currentNode.parent.rightChild = currentNode.leftChild
             else:
                 currentNode.replaceNodeData(currentNode.leftChild.key,
                                    currentNode.leftChild.value,
                                    currentNode.leftChild.leftChild,
                                    currentNode.leftChild.rightChild)
           else:
             if currentNode.isLeftChild():
                 currentNode.rightChild.parent = currentNode.parent
                 currentNode.parent.leftChild = currentNode.rightChild
             elif currentNode.isRightChild():
                 currentNode.rightChild.parent = currentNode.parent
                 currentNode.parent.rightChild = currentNode.rightChild
             else:
                 currentNode.replaceNodeData(currentNode.rightChild.key,
                                    currentNode.rightChild.value,
                                    currentNode.rightChild.leftChild,
                                    currentNode.rightChild.rightChild)


def main():

    mytree = BinarySearchTree()
    mytree.put(3, &quot;red&quot;)
    mytree.put(4, &quot;blue&quot;)
    mytree.put(6, &quot;yellow&quot;)
    mytree.put(2, &quot;at&quot;)

    print(mytree.get(6))
    print(mytree.get(2))

main()
                </code></program></statement>
            </task>
        </exploration>
            <reading-questions xml:id="rq-search-tree-impl">
                <title>Reading Questions</title>
                
                <exercise label="question1_2">
                    <statement>
            
                    <p>How many children can a node have in a binary search tree?</p>
            
                    </statement>
            <choices>
            
                        <choice>
                            <statement>
                                <p>At least 4</p>
                            </statement>
                            <feedback>
                                <p>Incorrect. Refer back to the definition of a binary search tree.</p>
                            </feedback>
                        </choice>
            
                        <choice>
                            <statement>
                                <p>At most 3</p>
                            </statement>
                            <feedback>
                                <p>Incorrect.</p>
                            </feedback>
                        </choice>
            
                        <choice>
                            <statement>
                                <p>At least 1</p>
                            </statement>
                            <feedback>
                                <p>Incorrect, it has a limit.</p>
                            </feedback>
                        </choice>
            
                        <choice correct="yes">
                            <statement>
                                <p>At most 2</p>
                            </statement>
                            <feedback>
                                <p>Correct!</p>
                            </feedback>
                        </choice>
            </choices>
            
                </exercise>
                <exercise label="bst_1">
                    <statement>
            
                        <p>Which of the trees shows a correct binary search tree given that the keys were
                            inserted in the following order 5, 30, 2, 40, 25, 4.</p>
            
                    </statement>
            <choices>
            
                        <choice>
                            <statement>
                                <p><image source="Trees/bintree_a.png" width="50%"><description><p/></description></image></p>
                            </statement>
                            <feedback>
                                <p>Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.</p>
                            </feedback>
                        </choice>
            
                        <choice correct="yes">
                            <statement>
                                <p><image source="Trees/bintree_b.png" width="50%"><description><p/></description></image></p>
                            </statement>
                            <feedback>
                                <p>good job.</p>
                            </feedback>
                        </choice>
            
                        <choice>
                            <statement>
                                <p><image source="Trees/bintree_c.png" width="50%"><description><p/></description></image></p>
                            </statement>
                            <feedback>
                                <p>This looks like a binary tree that satisfies the full tree property needed for a heap.</p>
                            </feedback>
                        </choice>
            </choices>
            
                </exercise>
                
            </reading-questions>
    </section>
