<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h3 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">5.12.1</span><span class="period">.</span><span class="space"> </span><span class="title">Recursive Change Calculator.</span>
</h3>
<article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h4>
<pre class="program"><code class="language-cpp">//Recursive example of trying to get the least amount of coins to make up an amount of change.

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int recMC_greedy(vector&lt;int&gt; coinValueList, int change){
        if (change == 0){ //base case if, change is 0, then the number of coins have been finalized
            return 0;
        }
        else{
            int cur_max =* max_element(coinValueList.begin(), coinValueList.end());//use the maximum in the list to see how many of these can be used to form the sum
            int count=int(change/cur_max); //find how many of the max is needed to make the change so that the number of coins used is minimum
            coinValueList.erase(std::remove(coinValueList.begin(), coinValueList.end(), cur_max), coinValueList.end()); //erasing the current max so that a different max can be
                                                                                                                        //used in next recursion and continue the greedy process
            return count + recMC_greedy(coinValueList, change-cur_max * count); //returns the counts of the coins using recursion
            }
}

int main() {
  int arr2[] = {1, 5, 10, 21, 25};
  vector&lt;int&gt; coinValueList(arr2, arr2 + (sizeof(arr2)/ sizeof(arr2[0])));  //Initializing vector
  cout&lt;&lt;recMC_greedy(coinValueList, 63)&lt;&lt;endl; //using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21
  return 0;                                  //but greedy algorithm gives 6 coins which is not the most optimum solution
}
</code></pre></article><article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h4>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="prog-change1-py-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="prog-change1-py-prog_editor" data-question_label="" data-codelens="true">#Recursive example of trying to get the least amount of coins to make up an amount of change.

def recMC_greedy(coinValueList,change):
  if change == 0:  #base case if, change is 0, then the number of coins have been finalized
    return 0
  else:
    cur_max = max(coinValueList) #use the maximum in the list to see how many of these can be used to form the sum
    count = change//cur_max #find how many of the max is needed to make the change so that the number of coins used is minimum
    index = coinValueList.index(cur_max)
    del coinValueList[index]   #erasing the current max so that a different max can be
                               #used in next recursion and continue the greedy process
    return count + recMC_greedy(coinValueList, change-cur_max * count) #returns the counts of the coins using recursion

def main():
  print(recMC_greedy([1, 5, 10, 21, 25], 63)) #using the greedy algorithm for the edge case 63 whose optimal solution is 3 coins of 21
                                         #but greedy algorithm gives 6 coins which is not the most optimum solution
main()
</textarea></div></div></div></article></article><span class="incontext"><a href="recursion_dynamic-programming.html#expl-lst-change1-cpp" class="internal">in-context</a></span>
</body>
</html>
