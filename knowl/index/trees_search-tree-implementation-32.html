<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h3 class="heading"><span class="type">Paragraph</span></h3>
<div class="para">The third case is the most difficult case to handle (see <a href="trees_search-tree-implementation.html#bst_lst-bst8" class="xref" data-knowl="./knowl/xref/bst_lst-bst8.html" data-reveal-label="Reveal" data-close-label="Close" title="Listing 8.13.14">Listing 8.13.14</a>). If a node has two children, then it is unlikely that we can simply promote one of them to take the node’s place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the <dfn class="terminology">successor node</dfn>, and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.</div>
<span class="incontext"><a class="internal" href="trees_search-tree-implementation.html#trees_search-tree-implementation-32">in-context</a></span>
</body>
</html>
