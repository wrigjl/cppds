<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h4 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">8.10.1</span><span class="period">.</span><span class="space"> </span><span class="title">Complete Heap Implementation.</span>
</h4>
<article class="task exercise-like"><h5 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h5>
<pre class="program"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// uses a vector to creat a Binar Heap
class BinHeap{

private:
    vector&lt;int&gt; heapvector;
    int currentSize;

public:
    // initializes the vector and an attribute currentSize
    // as 0 to allow for interger division.
    BinHeap(vector&lt;int&gt; heapvector){
        this-&gt;heapvector = heapvector;
        this-&gt;currentSize = 0;
    }

    // prelocates and item as far up in the
    // tree as possible to maintain
    // the Heap property
    void percUp(int i){
        while ((i / 2) &gt; 0){
            if (this-&gt;heapvector[i] &lt; this-&gt;heapvector[i/2]){
                int tmp = this-&gt;heapvector[i/2];
                this-&gt;heapvector[i/2] = this-&gt;heapvector[i];
                this-&gt;heapvector[i] = tmp;
            }
            i = i/2;
        }

    }

    // appends item to the end of the vector
    void insert(int k){
        this-&gt;heapvector.push_back(k);
        this-&gt;currentSize = this-&gt;currentSize + 1;
        this-&gt;percUp(this-&gt;currentSize);
    }

    // prelocates and item as far up in the
    // tree as possible to maintain
    // the Heap property
    void percDown(int i){
        while ((i*2) &lt;= this-&gt;currentSize){
            int mc = this-&gt;minChild(i);
            if (this-&gt;heapvector[i] &gt; this-&gt;heapvector[mc]){
                int tmp = this-&gt;heapvector[i];
                this-&gt;heapvector[i] = this-&gt;heapvector[mc];
                this-&gt;heapvector[mc] = tmp;
            }
            i = mc;
        }
    }

    int minChild(int i){
        if (((i*2)+1) &gt; this-&gt;currentSize){
            return i * 2;
        }
        else{
            if (this-&gt;heapvector[i*2] &lt; this-&gt;heapvector[(i*2)+1]){
                return i * 2;
            }
            else{
                return (i * 2) + 1;
            }
        }
    }

    // restores full complince with the heap structure
    // and heap order properties after the root is removed
    // by  taking the last item and moving it to the root position
    // and pushing the new root node down the tree to its proper postion.
    int delMin(){
        int retval = this-&gt;heapvector[1];
        this-&gt;heapvector[1] = this-&gt;heapvector[this-&gt;currentSize];
        this-&gt;currentSize = this-&gt;currentSize - 1;
        this-&gt;heapvector.pop_back();
        this-&gt;percDown(1);
        return retval;
    }

    void buildheap(vector&lt;int&gt; avector){
        int i = avector.size() / 2;
        this-&gt;currentSize = avector.size();
        this-&gt;heapvector.insert(this-&gt;heapvector.end(), avector.begin(), avector.end());
        while (i &gt; 0){
            this-&gt;percDown(i);
            i = i - 1;
        }
    }

    bool isEmpty(){
        if (this-&gt;heapvector.size()&gt;0){
            return false;
        }
        return true;
    }

    int findMin(){
        return this-&gt;heapvector[1];
    }
};


int main(){
    int arr[] = {9, 5, 6, 2, 3};
    vector&lt;int&gt; a(arr,arr+(sizeof(arr)/ sizeof(arr[0])));

    vector&lt;int&gt; vec;
    vec.push_back(0);

    BinHeap *bh = new BinHeap(vec);
    bh-&gt;buildheap(a);

    cout &lt;&lt; bh-&gt;delMin() &lt;&lt; endl;
    cout &lt;&lt; bh-&gt;delMin() &lt;&lt; endl;
    cout &lt;&lt; bh-&gt;delMin() &lt;&lt; endl;
    cout &lt;&lt; bh-&gt;delMin() &lt;&lt; endl;
    cout &lt;&lt; bh-&gt;delMin() &lt;&lt; endl;

    return 0;
}
</code></pre></article><article class="task exercise-like"><h5 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h5>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="prog-heapwhole-py-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="prog-heapwhole-py-prog_editor" data-question_label="" data-codelens="true"># uses a vector to create a Binary Heap
class BinHeap:
    """initializes the vector and an attribute currentSize
    as 0 to allow for interger division."""
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0


    """ prelocates and item as far up in the
    tree as possible to maintain
    the Heap property """
    def percUp(self,i):
        while i // 2 &gt; 0:
            if self.heapList[i] &lt; self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    # appends item to the end of the vector
    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    """ prelocates and item as far down in the
    tree as possible to maintain
    the Heap property """
    def percDown(self,i):
        while (i * 2) &lt;= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] &gt; self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self,i):
        if i * 2 + 1 &gt; self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] &lt; self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1

    """ restores full complince with the heap structure
    and heap order properties after the root is removed
    by  taking the last item and moving it to the root position
    and pushing the new root node down the tree to its proper postion."""
    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self,alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i &gt; 0):
            self.percDown(i)
            i = i - 1

def main():

    bh = BinHeap()
    bh.buildHeap([9,5,6,2,3])

    print(bh.delMin())
    print(bh.delMin())
    print(bh.delMin())
    print(bh.delMin())
    print(bh.delMin())

main()
</textarea></div></div></div></article></article><span class="incontext"><a href="trees_binary-heap-implementation.html#expl-heapwhole" class="internal">in-context</a></span>
</body>
</html>
