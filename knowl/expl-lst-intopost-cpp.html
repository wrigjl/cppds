<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h4 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">3.9.1</span><span class="period">.</span><span class="space"> </span><span class="title">Infix to Postfix Conversion.</span>
</h4>
<article class="task exercise-like"><h5 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h5>
<pre class="program"><code class="language-cpp">//Converts an infix expression to a postfix expression.

#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

string infixToPostfix(string infixexpr) {
    //performs the postfix process.
    unordered_map &lt;char,int&gt; prec;
    prec['*']=3;
    prec['/']=3;
    prec['+']=2;
    prec['-']=2;
    prec['(']=1;
    stack&lt;char&gt; opStack;
    vector&lt;char&gt; postfixVector;
    string letsnums = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    for (char token:infixexpr) {
        //for each character in infixexpr
        if (token == ' ') {
            continue;
        }
        else if (letsnums.find(token)&lt;=letsnums.length()) { //finds if the token is inside of letsnums
            postfixVector.emplace_back(token); // appends to the end of the container.
        } else if (token == '(') {
            opStack.push(token);
        } else if (token == ')') {
            char topToken;
            topToken = opStack.top();
            opStack.pop();
            while (topToken != '(') {
                postfixVector.emplace_back(topToken);
                topToken=opStack.top();
                opStack.pop();
            }
        } else { //if the token is not inside of letsnums.
            while (!opStack.empty() &amp;&amp; (prec[opStack.top()]&gt;=prec[token])) //while the stack is not empty and
                                                                           //the top item of the stack is on a
                                                                           //higher level of PEMDAS than token.
            {
                postfixVector.emplace_back(opStack.top());
                opStack.pop();
                }
            opStack.push(token);
        }
    }
    while (!opStack.empty()) {
        postfixVector.emplace_back(opStack.top());
        opStack.pop();
    }

    string s(postfixVector.begin(),postfixVector.end());

    return s;
}

int main() {
    cout &lt;&lt;"infix: A * B + C * D\n" &lt;&lt; "postfix: ";
    cout &lt;&lt; infixToPostfix("A * B + C * D") &lt;&lt; endl;
    cout &lt;&lt; "infix: ( A + B ) * C - ( D - E ) * ( F + G )\n" &lt;&lt; "postfix: ";
    cout &lt;&lt; infixToPostfix("( A + B ) * C - ( D - E ) * ( F + G )") &lt;&lt; endl;

    return 0;
}
</code></pre></article><article class="task exercise-like"><h5 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h5>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="intopost-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="intopost-prog_editor" data-question_label="" data-codelens="true">#Converts an infix expression to a postfix expression.

from pythonds.basic.stack import Stack

def infixToPostfix(infixexpr):
    #performs the postfix process.
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1
    opStack = Stack()
    postfixList = []
    tokenList = infixexpr.split()

    for token in tokenList:
        #for each character in infixexpr
        if token in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" or token in "0123456789":
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and (prec[opStack.peek()] &gt;= prec[token]): #while the stack is not empty and
                                                                                     #the top item of the stack is on a
                                                                                     #higher level of PEMDAS than token.
                  postfixList.append(opStack.pop())
            opStack.push(token)

    while not opStack.isEmpty():
        postfixList.append(opStack.pop())
    return " ".join(postfixList)

def main():
    print(infixToPostfix("A * B + C * D"))
    print(infixToPostfix("( A + B ) * C - ( D - E ) * ( F + G )"))
main()
</textarea></div></div></div></article></article><span class="incontext"><a href="linear-basic_infix-prefix-and-postfix-expressions.html#expl-lst-intopost-cpp" class="internal">in-context</a></span>
</body>
</html>
