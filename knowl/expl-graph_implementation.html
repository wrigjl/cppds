<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h3 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">9.6.1</span><span class="period">.</span><span class="space"> </span><span class="title">Directed Graph Implementation.</span>
</h3>
<article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h4>
<pre class="program"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
using namespace std;

class Vertex {
public:
        int id;
        map&lt;int, int&gt; connectedTo;

                //Empty constructor.
        Vertex() {
        }

                //Constructor that defines the key of the vertex.
        Vertex(int key) {
                id = key;
        }

                //Adds a neighbor to this vertex with the specified ID and weight.
        void addNeighbor(int nbr, int weight = 0) {
                connectedTo[nbr] = weight;
        }
                //Returns a vector (e.g, list) of vertices connected to this one.
        vector&lt;int&gt; getConnections() {
                vector&lt;int&gt; keys;
                // Use of iterator to find all keys
                for (map&lt;int, int&gt;::iterator it = connectedTo.begin();
                        it != connectedTo.end();
                        ++it) {
                        keys.push_back(it-&gt;first);
                }
                return keys;
        }

                //Returns the ID of this vertex.
        int getId() {
                return id;
        }

                //Returns the weight of the connection between this vertex and the specified neighbor.
        int getWeight(int nbr) {
                return connectedTo[nbr];
        }

                //Output stream overload operator for printing to the screen.
        friend ostream &amp;operator&lt;&lt;(ostream &amp;, Vertex &amp;);
};

ostream &amp;operator&lt;&lt;(ostream &amp;stream, Vertex &amp;vert) {
        vector&lt;int&gt; connects = vert.getConnections();
        for (unsigned int i = 0; i &lt; connects.size(); i++) {
                stream &lt;&lt; "( " &lt;&lt; vert.id &lt;&lt; " , " &lt;&lt; connects[i] &lt;&lt; " ) \n";
        }

        return stream;
}

class Graph {
public:
        map&lt;int, Vertex&gt; vertList;
        int numVertices;

                //Empty constructor.
        Graph() {
                numVertices = 0;
        }

                //Adds the specified vertex and returns a copy of it.
        Vertex addVertex(int key) {
                numVertices++;
                Vertex newVertex = Vertex(key);
                this-&gt;vertList[key] = newVertex;
                return newVertex;
        }

                //Returns the vertex with the specified ID.
                //Will return NULl if the vertex doesn't exist.
        Vertex *getVertex(int n) {
                for (map&lt;int, Vertex&gt;::iterator it = vertList.begin();
                        it != vertList.end();
                        ++it) {
                        if (it-&gt;first == n) {
                                // Forced to use pntr due to possibility of returning NULL
                                Vertex *vpntr = &amp;vertList[n];
                                return vpntr;
                        } else {
                                return NULL;
                        }
                }
        }
                //Returns a boolean indicating if an index with the specified ID exists.
        bool contains(int n) {
                for (map&lt;int, Vertex&gt;::iterator it = vertList.begin();
                        it != vertList.end();
                        ++it) {
                        if (it-&gt;first == n) {
                                return true;
                        }
                }
                return false;
        }

                //Adds an edge between vertices F and T with a weight equivalent to cost.
        void addEdge(int f, int t, int cost = 0) {
                if (!this-&gt;contains(f)) {
                        cout &lt;&lt; f &lt;&lt; " was not found, adding!" &lt;&lt; endl;
                        this-&gt;addVertex(f);
                }
                if (!this-&gt;contains(t)) {
                        cout &lt;&lt; t &lt;&lt; " was not found, adding!" &lt;&lt; endl;
                }
                vertList[f].addNeighbor(t, cost);
        }

                //Returns a vector (e.g, list) of all vertices in this graph.
        vector&lt;int&gt; getVertices() {
                vector&lt;int&gt; verts;

                for (map&lt;int, Vertex&gt;::iterator it = vertList.begin();
                        it != vertList.end();
                        ++it) {
                        verts.push_back(it-&gt;first);
                }
                return verts;
        }

                //Overloaded Output stream operator for printing to the screen
        friend ostream &amp;operator&lt;&lt;(ostream &amp;, Graph &amp;);
};

ostream &amp;operator&lt;&lt;(ostream &amp;stream, Graph &amp;grph) {
        for (unsigned int i = 0; i &lt; grph.vertList.size(); i++) {
                stream &lt;&lt; grph.vertList[i];
        }

        return stream;
}

int main() {
        Graph g;

        for (int i = 0; i &lt; 6; i++) {
                g.addVertex(i);
        }

        g.addEdge(0, 1, 5);
        g.addEdge(0, 5, 2);
        g.addEdge(1, 2, 4);
        g.addEdge(2, 3, 9);
        g.addEdge(3, 4, 7);
        g.addEdge(3, 5, 3);
        g.addEdge(4, 0, 1);
        g.addEdge(5, 4, 8);
        g.addEdge(5, 2, 1);

        cout &lt;&lt; g &lt;&lt; endl;

        return 0;
}
</code></pre></article><article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h4>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="graph_implementation_py-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="graph_implementation_py-prog_editor" data-question_label="" data-codelens="true">class Vertex:
        # Contructor that specifies the key of the vertex.
        def __init__(self, key):
                self.id = key
                self.connectedTo = {}
                # Adds a neighbor with the specified weight.
        def addNeighbor(self, nbr, weight=0):
                self.connectedTo[nbr] = weight
        
                # Converts this vertex to a string representation.
        def __str__(self):
                return str(self.id) + ' connectedTo: ' + str(
                [x.id for x in self.connectedTo])
        
                # Returns the list of vertex IDs that are connected to this one.
        def getConnections(self):
                return self.connectedTo.keys()
        
                # Returns the ID of this vertex.
        def getId(self):
                return self.id
        
                # Returns the weight of this vertex in relation to the specified neighbor.
        def getWeight(self, nbr):
                return self.connectedTo[nbr]
        
        
class Graph:
        # Empty constructor.
        def __init__(self):
                self.vertList = {}
                self.numVertices = 0
                # Adds a vertex with the specified ID (key) and returns it.
        def addVertex(self, key):
                self.numVertices = self.numVertices + 1
                newVertex = Vertex(key)
                self.vertList[key] = newVertex
                return newVertex

        # Returns the vertex (or None if nonexistant) with the specified ID n.
        def getVertex(self, n):
                if n in self.vertList:
                        return self.vertList[n]
                else:
                        return None
        
        # Returns a boolean indicating if the specified vertex ID is in this graph.
        def __contains__(self, n):
                return n in self.vertList
        
        # Adds an edge between F and T with a weight of cost.
        def addEdge(self, f, t, cost=0):
                if f not in self.vertList:
                        self.addVertex(f)
                if t not in self.vertList:
                        self.addVertex(t)
                self.vertList[f].addNeighbor(self.vertList[t], cost)
        
        # Returns a list of all vertices in this graph.
        def getVertices(self):
                return self.vertList.keys()
        
        # Iteration overload (useful in python).
        def __iter__(self):
                return iter(self.vertList.values())
        
        
def main():
        g = Graph()
        for i in range(6):
                g.addVertex(i)
        
        g.addEdge(0, 1, 5)
        g.addEdge(0, 5, 2)
        g.addEdge(1, 2, 4)
        g.addEdge(2, 3, 9)
        g.addEdge(3, 4, 7)
        g.addEdge(3, 5, 3)
        g.addEdge(4, 0, 1)
        g.addEdge(5, 4, 8)
        g.addEdge(5, 2, 1)
        
        for v in g:
                for w in v.getConnections():
                        print("( %s , %s )" % (v.getId(), w.getId()))
        
        
main()
</textarea></div></div></div></article></article><span class="incontext"><a href="graphs_implementation.html#expl-graph_implementation" class="internal">in-context</a></span>
</body>
</html>
