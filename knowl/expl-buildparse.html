<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h3 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">8.5.1</span><span class="period">.</span><span class="space"> </span><span class="title">Building A Parse Tree.</span>
</h3>
<article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h4>
<pre class="program"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;stack&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;


class BinaryTree {

    private:
        string key;
        BinaryTree *leftChild;
        BinaryTree *rightChild;
    public:
        BinaryTree(string rootObj){
            this-&gt;key = rootObj;
            this-&gt;leftChild = NULL;
            this-&gt;rightChild = NULL;
        }

        void insertLeft(string newNode){
            if (this-&gt;leftChild == NULL){
                this-&gt;leftChild = new BinaryTree(newNode);
            }
            else {
                BinaryTree *t = new BinaryTree(newNode);
                t-&gt;leftChild = this-&gt;leftChild;
                this-&gt;leftChild = t;
            }
        }

        void insertRight(string newNode){
            if (this-&gt;rightChild == NULL){
                this-&gt;rightChild = new BinaryTree(newNode);
            }
            else {
                BinaryTree *t = new BinaryTree(newNode);
                t-&gt;rightChild = this-&gt;rightChild;
                this-&gt;rightChild = t;
            }
        }

        BinaryTree *getRightChild(){
            return this-&gt;rightChild;
        }

        BinaryTree *getLeftChild(){
            return this-&gt;leftChild;
        }

        void setRootVal(string obj){
            this-&gt;key = obj;
        }

        string getRootVal(){
            return this-&gt;key;
        }
};
        
BinaryTree *buildParseTree(const string&amp; expr){
    string buf;

    // build vector from space delimited tokens
    stringstream ss(expr);
    vector&lt;string&gt; tokenlist;
    while (ss &gt;&gt; buf)
        tokenlist.push_back(buf);

    BinaryTree *root = new BinaryTree("");
    stack&lt;BinaryTree*&gt; parentStack;
    parentStack.push(root);
    BinaryTree *currentTree = root;

    for (size_t i = 0; i &lt; tokenlist.size(); i++){
        if (tokenlist[i] == "("){
            // rule 1: open parenthesis
            currentTree-&gt;insertLeft("");
            parentStack.push(currentTree);
            currentTree = currentTree-&gt;getLeftChild();
        } else if (tokenlist[i] == "+" || tokenlist[i] == "-" ||
                   tokenlist[i] == "/" || tokenlist[i] == "*"){
            // rule 2: operator
            currentTree-&gt;setRootVal(tokenlist[i]);
            currentTree-&gt;insertRight("");
            parentStack.push(currentTree);
            currentTree = currentTree-&gt;getRightChild();
        } else if (tokenlist[i] == ")") {
            // rule 4: closing parenthesis
            currentTree = parentStack.top();
            parentStack.pop();
        } else {
            // rule 3: number
            currentTree-&gt;setRootVal(tokenlist[i]);
            BinaryTree *parent = parentStack.top();
            parentStack.pop();
            currentTree = parent;
        }
    }

    return root;
}

void postorder(BinaryTree *tree){
    if (tree != NULL){
        postorder(tree-&gt;getLeftChild());
        postorder(tree-&gt;getRightChild());
        cout &lt;&lt; tree-&gt;getRootVal() &lt;&lt; endl;
    }
}

int main() {

    BinaryTree *pt = buildParseTree("( ( 10 + 5 ) * 3 )");

    postorder(pt);

    return 0;
}
</code></pre></article><article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h4>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="prog-buildparse-py-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="prog-buildparse-py-prog_editor" data-question_label="" data-codelens="true">from pythonds.basic.stack import Stack
from pythonds.trees.binaryTree import BinaryTree

def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree

    for i in fplist:
        if i == '(': # adds a new node as the left child of the current node, and descend to the left child
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()

        elif i in ['+', '-', '*', '/']:
            currentTree.setRootVal(i) # adds a new node as the right child of the current node, and descend to the left child
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()

        elif i == ')':
            currentTree = pStack.pop()

        elif i not in ['+', '-', '*', '/', ')']: # sets root value of the current node to the operator represented by the current token or number.
            try:
                currentTree.setRootVal(int(i))
                parent = pStack.pop()
                currentTree = parent

            except ValueError:
                raise ValueError("token '{}' is not a valid integer".format(i))

    return eTree

def main():
    pt = buildParseTree("( ( 10 + 5 ) * 3 )")
    pt.postorder()  #defined and explained in the next section
main()
</textarea></div></div></div></article></article><span class="incontext"><a href="trees_parse-tree.html#expl-buildparse" class="internal">in-context</a></span>
</body>
</html>
