<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="task exercise-like"><h5 class="heading">
<span class="type">Task</span><span xmlns:pf="https://prefigure.org" class="space"> </span><span class="codenumber">3.9.1.a</span><span xmlns:pf="https://prefigure.org" class="period">.</span><span xmlns:pf="https://prefigure.org" class="space"> </span><span class="title">C++ Implementation.</span>
</h5>
<pre class="program"><code class="language-cpp">//Converts an infix expression to a postfix expression.

#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

string infixToPostfix(string infixexpr) {
    //performs the postfix process.
    unordered_map &lt;char,int&gt; prec;
    prec['*']=3;
    prec['/']=3;
    prec['+']=2;
    prec['-']=2;
    prec['(']=1;
    stack&lt;char&gt; opStack;
    vector&lt;char&gt; postfixVector;
    string letsnums = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    for (char token:infixexpr) {
        //for each character in infixexpr
        if (token == ' ') {
            continue;
        }
        else if (letsnums.find(token)&lt;=letsnums.length()) { //finds if the token is inside of letsnums
            postfixVector.emplace_back(token); // appends to the end of the container.
        } else if (token == '(') {
            opStack.push(token);
        } else if (token == ')') {
            char topToken;
            topToken = opStack.top();
            opStack.pop();
            while (topToken != '(') {
                postfixVector.emplace_back(topToken);
                topToken=opStack.top();
                opStack.pop();
            }
        } else { //if the token is not inside of letsnums.
            while (!opStack.empty() &amp;&amp; (prec[opStack.top()]&gt;=prec[token])) //while the stack is not empty and
                                                                           //the top item of the stack is on a
                                                                           //higher level of PEMDAS than token.
            {
                postfixVector.emplace_back(opStack.top());
                opStack.pop();
                }
            opStack.push(token);
        }
    }
    while (!opStack.empty()) {
        postfixVector.emplace_back(opStack.top());
        opStack.pop();
    }

    string s(postfixVector.begin(),postfixVector.end());

    return s;
}

int main() {
    cout &lt;&lt;"infix: A * B + C * D\n" &lt;&lt; "postfix: ";
    cout &lt;&lt; infixToPostfix("A * B + C * D") &lt;&lt; endl;
    cout &lt;&lt; "infix: ( A + B ) * C - ( D - E ) * ( F + G )\n" &lt;&lt; "postfix: ";
    cout &lt;&lt; infixToPostfix("( A + B ) * C - ( D - E ) * ( F + G )") &lt;&lt; endl;

    return 0;
}
</code></pre></article><span class="incontext"><a class="internal" href="linear-basic_infix-prefix-and-postfix-expressions.html#lst-intopost-cpp">in-context</a></span>
</body>
</html>
