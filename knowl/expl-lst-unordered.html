<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="exploration project-like"><h3 class="heading">
<span class="type">Exploration</span><span class="space"> </span><span class="codenumber">4.5.1</span><span class="period">.</span><span class="space"> </span><span class="title">Unordered List Implementations.</span>
</h3>
<article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(a)</span><span class="space"> </span><span class="title">C++ Implementation.</span>
</h4>
<pre class="program"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//creates a node class
class Node {
    //defines data, and next as a pointer.
    private:
        int data; //data in the beginning node
        Node *next; //pointer to the next node

    public:
        Node(int initdata) {
                data = initdata; //the initialized data is set as the head
                next = NULL; //the next node is set as NULL, as there is no next node yet.
        }

        int getData() { //function that return data of a given node.
                return data;
        }

        Node *getNext() { // pointer that gets the next node
                return next;
        }

        void setData(int newData) { // sets data in node
                data = newData;
        }

        void setNext(Node *newnext) {
                next = newnext;
        }
};

    // creates unorderedlist that points to the head of the linked list
class UnorderedList {
    public:
            Node *head;

            UnorderedList() { // makes the head node equal to null
                    head = NULL;
            }

        bool isEmpty() { // the head node is empty if it is null
            return head == NULL;
        }

        void add(int item) { //cerates a "temp" pointer that adds the new node to the head of the list
            Node *temp = new Node(item);
            temp-&gt;setNext(head);
            head = temp;
        }

        int size() { //cereates a "current" pointer that iterates through the list until it reaches null
            Node *current = head;
            int count = 0;
            while (current != NULL) {
                count++;
                current = current-&gt;getNext();
            }

            return count;
        }

        // creates "current" pointer that iterates through the list
        // untli it finds the item being searched for, and returns a boolean value

        bool search(int item) {
            Node *current = head;
            while (current != NULL) {
                if (current-&gt;getData() == item) {
                    return true;
                } else {
                    current = current-&gt;getNext();
                }
            }
            return false;
        }

        // uses current and previous pointer to iterate through the lists
        // finds the items that is searched for, and removes it

        void remove(int item) {
            Node *current = head;
            Node *previous = NULL;
            bool found = false;
            while (!found) {
                if (current-&gt;getData() == item) {
                    found = true;
                } else {
                    previous = current;
                    current = current-&gt;getNext();
                }
            }
            if (previous == NULL) {
                head = current-&gt;getNext();
            } else {
                previous-&gt;setNext(current-&gt;getNext());
            }
        }

        friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const UnorderedList&amp; ol);
};

ostream&amp; operator&lt;&lt;(ostream&amp; os, const UnorderedList&amp; ol) {
    Node *current = ol.head;
    while (current != NULL) {
        os&lt;&lt;current-&gt;getData()&lt;&lt;endl;
        current = current-&gt;getNext();
    }
    return os;
}


int main() {
    UnorderedList mylist;
    mylist.add(31);
    mylist.add(77);
    mylist.add(17);
    mylist.add(93);
    mylist.add(26);
    mylist.add(54);

    cout&lt;&lt;"SIZE: "&lt;&lt;mylist.size()&lt;&lt;endl;
    cout&lt;&lt;"contains 93?\t"&lt;&lt;mylist.search(93)&lt;&lt;endl;
    cout&lt;&lt;"contains 100?\t"&lt;&lt;mylist.search(100)&lt;&lt;endl&lt;&lt;endl;

    mylist.add(100);
    cout&lt;&lt;"contains 100?\t"&lt;&lt;mylist.search(100)&lt;&lt;endl&lt;&lt;endl;
    cout&lt;&lt;"SIZE: "&lt;&lt;mylist.size()&lt;&lt;endl;

    mylist.remove(54);
    cout&lt;&lt;"SIZE: "&lt;&lt;mylist.size()&lt;&lt;endl;
    mylist.remove(93);
    cout&lt;&lt;"SIZE: "&lt;&lt;mylist.size()&lt;&lt;endl;
    mylist.remove(31);
    cout&lt;&lt;"SIZE: "&lt;&lt;mylist.size()&lt;&lt;endl;
    mylist.search(93);

    cout&lt;&lt;"MY LIST: "&lt;&lt;endl&lt;&lt;mylist;
        return 0;
}
</code></pre></article><article class="task exercise-like"><h4 class="heading">
<span class="codenumber">(b)</span><span class="space"> </span><span class="title">Python Implementation.</span>
</h4>
<div class="ptx-runestone-container"><div class="runestone explainer ac_section "><div data-component="activecode" id="lst_unordered_py-prog"><textarea data-lang="python" data-timelimit="25000" data-audio="" data-coach="true" style="visibility: hidden;" id="lst_unordered_py-prog_editor" data-question_label="" data-codelens="true">class Node:
    def __init__(self, initdata):
        self.data = initdata
        self.next = None

    def get_data(self):
        return self.data

    def get_next(self):
        return self.next

    def set_next(self, new_next):
        self.next = new_next

class UnorderedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head is None

    def add(self, item):
        temp = Node(item)
        temp.set_next(self.head)
        self.head = temp

    def search(self, item):
        current = self.head
        while current is not None:
            if current.get_data() == item:
                return True
            current = current.get_next()
        return False

    def remove(self, item):
        current = self.head
        previous = None
        while current is not None:
            if current.get_data() == item:
                if previous is None:
                    self.head = current.get_next()
                else:
                    previous.set_next(current.get_next())
                return
            previous = current
            current = current.get_next()

# Example usage
mylist = UnorderedList()
mylist.add(31)
mylist.add(77)
mylist.add(17)
mylist.add(93)
mylist.add(26)
mylist.add(54)

print("Search for 93:", mylist.search(93))
print("Search for 100:", mylist.search(100))

mylist.remove(54)
print("Search for 54 after removal:", mylist.search(54))
</textarea></div></div></div></article></article><span class="incontext"><a href="linear-linked_unordered-linked-list.html#expl-lst-unordered" class="internal">in-context</a></span>
</body>
</html>
